From ff1bd28dbfd0e0e1dd93a0da2b46cfc1e2543073 Mon Sep 17 00:00:00 2001
From: Michal Hrusecky <Michal@Hrusecky.net>
Date: Fri, 22 Feb 2019 08:30:39 +0100
Subject: [PATCH] Turris Omnia: Improved suppport
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Karel Kočí <karel.koci@nic.cz>
---
 ...nia-Add-separate-DTS-for-SFP-support.patch | 870 ++++++++++++++++++
 ...Omnia-second-ethernet-connection-to-.patch |  39 +
 .../8890-turris-omnia-led-driver.patch        | 317 +++++++
 ...91-turris-omnia-custom-led-functions.patch | 269 ++++++
 ...8892-turris-omnia-enable-leds-in-dts.patch | 102 ++
 5 files changed, 1597 insertions(+)
 create mode 100644 target/linux/mvebu/patches-4.19/8888-Turris-Omnia-Add-separate-DTS-for-SFP-support.patch
 create mode 100644 target/linux/mvebu/patches-4.19/8889-Reenable-Turris-Omnia-second-ethernet-connection-to-.patch
 create mode 100644 target/linux/mvebu/patches-4.19/8890-turris-omnia-led-driver.patch
 create mode 100644 target/linux/mvebu/patches-4.19/8891-turris-omnia-custom-led-functions.patch
 create mode 100644 target/linux/mvebu/patches-4.19/8892-turris-omnia-enable-leds-in-dts.patch

diff --git a/target/linux/mvebu/patches-4.19/8888-Turris-Omnia-Add-separate-DTS-for-SFP-support.patch b/target/linux/mvebu/patches-4.19/8888-Turris-Omnia-Add-separate-DTS-for-SFP-support.patch
new file mode 100644
index 0000000..4f7190c
--- /dev/null
+++ b/target/linux/mvebu/patches-4.19/8888-Turris-Omnia-Add-separate-DTS-for-SFP-support.patch
@@ -0,0 +1,870 @@
+From bfc96ed32855077d2959f617aa285d1ec9fbb07d Mon Sep 17 00:00:00 2001
+From: Tomas Hlavacek <tmshlvck@gmail.com>
+Date: Sat, 11 Aug 2018 21:21:50 +0200
+Subject: [PATCH] Turris Omnia: Add separate DTS for SFP support
+
+The Turris Omnia board contains dual-personality ethernet NIC eth2 with
+two operation modes: 1) SFP cage and 2) metalic 1000BASE-X PHY.
+Differential pair carrying SGMII/1000BASE-X of eth2 is wired through a
+switch driven by the module-detect signal from the SFP cage. The pin status
+can be read through I2C GPIO expander chip in userspace when the sfp
+driver module is unloaded and / or in U-Boot prior to the start of the
+kernel and the proper DTS file can be selected for the (floolowing) boot.
+
+Split DTS for Turris Omnia (that does not have any support for SFP cage)
+into three files:
+  armada-385-turris-omnia.dtsi - common base
+  armada-385-turris-omnia-sfp.dts - DT with the SFP configuration and
+PHY disabled
+  armada-385-turris-omnia-phy.dts - DT with the PHY configuration and
+SFP disabled
+
+Current DSA driver does not allow multiple CPU ports and Turris Omnia
+has two RGMII iterfaces wired between CPU and DSA switch.
+Disable the second CPU port until there is a suitable driver to use it.
+---
+ arch/arm/boot/dts/Makefile                    |  3 +-
+ .../boot/dts/armada-385-turris-omnia-phy.dts  | 26 ++++++++++++++
+ .../boot/dts/armada-385-turris-omnia-sfp.dts  | 27 ++++++++++++++
+ ...omnia.dts => armada-385-turris-omnia.dtsi} | 36 +++++++++++--------
+ 4 files changed, 77 insertions(+), 15 deletions(-)
+ create mode 100644 arch/arm/boot/dts/armada-385-turris-omnia-phy.dts
+ create mode 100644 arch/arm/boot/dts/armada-385-turris-omnia-sfp.dts
+ rename arch/arm/boot/dts/{armada-385-turris-omnia.dts => armada-385-turris-omnia.dtsi} (91%)
+
+--- a/arch/arm/boot/dts/Makefile
++++ b/arch/arm/boot/dts/Makefile
+@@ -1155,7 +1155,8 @@ dtb-$(CONFIG_MACH_ARMADA_38X) += \
+ 	armada-385-linksys-rango.dtb \
+ 	armada-385-linksys-shelby.dtb \
+ 	armada-385-synology-ds116.dtb \
+-	armada-385-turris-omnia.dtb \
++	armada-385-turris-omnia-phy.dtb \
++	armada-385-turris-omnia-sfp.dtb \
+ 	armada-388-clearfog.dtb \
+ 	armada-388-clearfog-base.dtb \
+ 	armada-388-clearfog-pro.dtb \
+--- /dev/null
++++ b/arch/arm/boot/dts/armada-385-turris-omnia-phy.dts
+@@ -0,0 +1,26 @@
++// SPDX-License-Identifier: (GPL-2.0 OR MIT)
++/*
++ * Device Tree file for the Turris Omnia
++ *
++ * Copyright (C) 2016 Uwe Kleine-König <uwe@kleine-koenig.org>
++ * Copyright (C) 2016-2019 Tomas Hlavacek <tmshlvkc@gmail.com>
++ *
++ * Schematic available at https://www.turris.cz/doc/_media/rtrom01-schema.pdf
++ */
++
++/dts-v1/;
++
++#include <dt-bindings/gpio/gpio.h>
++#include <dt-bindings/input/input.h>
++#include "armada-385.dtsi"
++
++#include "armada-385-turris-omnia.dtsi"
++
++&phy1 {
++	status = "okay";
++};
++
++&eth2 {
++        phy-mode = "sgmii";
++        phy = <&phy1>;
++};
+--- /dev/null
++++ b/arch/arm/boot/dts/armada-385-turris-omnia-sfp.dts
+@@ -0,0 +1,27 @@
++// SPDX-License-Identifier: (GPL-2.0 OR MIT)
++/*
++ * Device Tree file for the Turris Omnia
++ *
++ * Copyright (C) 2016 Uwe Kleine-König <uwe@kleine-koenig.org>
++ * Copyright (C) 2016-2019 Tomas Hlavacek <tmshlvkc@gmail.com>
++ *
++ * Schematic available at https://www.turris.cz/doc/_media/rtrom01-schema.pdf
++ */
++
++/dts-v1/;
++
++#include <dt-bindings/gpio/gpio.h>
++#include <dt-bindings/input/input.h>
++#include "armada-385.dtsi"
++
++#include "armada-385-turris-omnia.dtsi"
++
++&sfp {
++	status = "okay";
++};
++
++&eth2 {
++	phy-mode = "sgmii";
++	managed = "in-band-status";
++	sfp = <&sfp>;
++};
+--- a/arch/arm/boot/dts/armada-385-turris-omnia.dts
++++ /dev/null
+@@ -1,359 +0,0 @@
+-// SPDX-License-Identifier: (GPL-2.0 OR MIT)
+-/*
+- * Device Tree file for the Turris Omnia
+- *
+- * Copyright (C) 2016 Uwe Kleine-König <uwe@kleine-koenig.org>
+- * Copyright (C) 2016 Tomas Hlavacek <tmshlvkc@gmail.com>
+- *
+- * Schematic available at https://www.turris.cz/doc/_media/rtrom01-schema.pdf
+- */
+-
+-/dts-v1/;
+-
+-#include <dt-bindings/gpio/gpio.h>
+-#include <dt-bindings/input/input.h>
+-#include "armada-385.dtsi"
+-
+-/ {
+-	model = "Turris Omnia";
+-	compatible = "cznic,turris-omnia", "marvell,armada385", "marvell,armada380";
+-
+-	chosen {
+-		stdout-path = &uart0;
+-	};
+-
+-	memory {
+-		device_type = "memory";
+-		reg = <0x00000000 0x40000000>; /* 1024 MB */
+-	};
+-
+-	soc {
+-		ranges = <MBUS_ID(0xf0, 0x01) 0 0xf1000000 0x100000
+-			  MBUS_ID(0x01, 0x1d) 0 0xfff00000 0x100000
+-			  MBUS_ID(0x09, 0x19) 0 0xf1100000 0x10000
+-			  MBUS_ID(0x09, 0x15) 0 0xf1110000 0x10000>;
+-
+-		internal-regs {
+-
+-			/* USB part of the PCIe2/USB 2.0 port */
+-			usb@58000 {
+-				status = "okay";
+-			};
+-
+-			sata@a8000 {
+-				status = "okay";
+-			};
+-
+-			sdhci@d8000 {
+-				pinctrl-names = "default";
+-				pinctrl-0 = <&sdhci_pins>;
+-				status = "okay";
+-
+-				bus-width = <8>;
+-				no-1-8-v;
+-				non-removable;
+-			};
+-
+-			usb3@f0000 {
+-				status = "okay";
+-			};
+-
+-			usb3@f8000 {
+-				status = "okay";
+-			};
+-		};
+-
+-		pcie {
+-			status = "okay";
+-
+-			pcie@1,0 {
+-				/* Port 0, Lane 0 */
+-				status = "okay";
+-			};
+-
+-			pcie@2,0 {
+-				/* Port 1, Lane 0 */
+-				status = "okay";
+-			};
+-
+-			pcie@3,0 {
+-				/* Port 2, Lane 0 */
+-				status = "okay";
+-			};
+-		};
+-	};
+-};
+-
+-/* Connected to 88E6176 switch, port 6 */
+-&eth0 {
+-	pinctrl-names = "default";
+-	pinctrl-0 = <&ge0_rgmii_pins>;
+-	status = "okay";
+-	phy-mode = "rgmii";
+-
+-	fixed-link {
+-		speed = <1000>;
+-		full-duplex;
+-	};
+-};
+-
+-/* Connected to 88E6176 switch, port 5 */
+-&eth1 {
+-	pinctrl-names = "default";
+-	pinctrl-0 = <&ge1_rgmii_pins>;
+-	status = "okay";
+-	phy-mode = "rgmii";
+-
+-	fixed-link {
+-		speed = <1000>;
+-		full-duplex;
+-	};
+-};
+-
+-/* WAN port */
+-&eth2 {
+-	status = "okay";
+-	phy-mode = "sgmii";
+-	phy = <&phy1>;
+-};
+-
+-&i2c0 {
+-	pinctrl-names = "default";
+-	pinctrl-0 = <&i2c0_pins>;
+-	status = "okay";
+-
+-	i2cmux@70 {
+-		compatible = "nxp,pca9547";
+-		#address-cells = <1>;
+-		#size-cells = <0>;
+-		reg = <0x70>;
+-		status = "okay";
+-
+-		i2c@0 {
+-			#address-cells = <1>;
+-			#size-cells = <0>;
+-			reg = <0>;
+-
+-			/* STM32F0 command interface at address 0x2a */
+-			/* leds device (in STM32F0) at address 0x2b */
+-
+-			eeprom@54 {
+-				compatible = "atmel,24c64";
+-				reg = <0x54>;
+-
+-				/* The EEPROM contains data for bootloader.
+-				 * Contents:
+-				 * 	struct omnia_eeprom {
+-				 * 		u32 magic; (=0x0341a034 in LE)
+-				 *		u32 ramsize; (in GiB)
+-				 * 		char regdomain[4];
+-				 * 		u32 crc32;
+-				 * 	};
+-				 */
+-			};
+-		};
+-
+-		i2c@1 {
+-			#address-cells = <1>;
+-			#size-cells = <0>;
+-			reg = <1>;
+-
+-			/* routed to PCIe0/mSATA connector (CN7A) */
+-		};
+-
+-		i2c@2 {
+-			#address-cells = <1>;
+-			#size-cells = <0>;
+-			reg = <2>;
+-
+-			/* routed to PCIe1/USB2 connector (CN61A) */
+-		};
+-
+-		i2c@3 {
+-			#address-cells = <1>;
+-			#size-cells = <0>;
+-			reg = <3>;
+-
+-			/* routed to PCIe2 connector (CN62A) */
+-		};
+-
+-		i2c@4 {
+-			#address-cells = <1>;
+-			#size-cells = <0>;
+-			reg = <4>;
+-
+-			/* routed to SFP+ */
+-		};
+-
+-		i2c@5 {
+-			#address-cells = <1>;
+-			#size-cells = <0>;
+-			reg = <5>;
+-
+-			/* ATSHA204A at address 0x64 */
+-		};
+-
+-		i2c@6 {
+-			#address-cells = <1>;
+-			#size-cells = <0>;
+-			reg = <6>;
+-
+-			/* exposed on pin header */
+-		};
+-
+-		i2c@7 {
+-			#address-cells = <1>;
+-			#size-cells = <0>;
+-			reg = <7>;
+-
+-			pcawan: gpio@71 {
+-				/*
+-				 * GPIO expander for SFP+ signals and
+-				 * and phy irq
+-				 */
+-				compatible = "nxp,pca9538";
+-				reg = <0x71>;
+-
+-				pinctrl-names = "default";
+-				pinctrl-0 = <&pcawan_pins>;
+-
+-				interrupt-parent = <&gpio1>;
+-				interrupts = <14 IRQ_TYPE_LEVEL_LOW>;
+-
+-				gpio-controller;
+-				#gpio-cells = <2>;
+-			};
+-		};
+-	};
+-};
+-
+-&mdio {
+-	pinctrl-names = "default";
+-	pinctrl-0 = <&mdio_pins>;
+-	status = "okay";
+-
+-	phy1: phy@1 {
+-		status = "okay";
+-		compatible = "ethernet-phy-id0141.0DD1", "ethernet-phy-ieee802.3-c22";
+-		reg = <1>;
+-
+-		/* irq is connected to &pcawan pin 7 */
+-	};
+-
+-	/* Switch MV88E6176 at address 0x10 */
+-	switch@10 {
+-		compatible = "marvell,mv88e6085";
+-		#address-cells = <1>;
+-		#size-cells = <0>;
+-		dsa,member = <0 0>;
+-
+-		reg = <0x10>;
+-
+-		ports {
+-			#address-cells = <1>;
+-			#size-cells = <0>;
+-
+-			ports@0 {
+-				reg = <0>;
+-				label = "lan0";
+-			};
+-
+-			ports@1 {
+-				reg = <1>;
+-				label = "lan1";
+-			};
+-
+-			ports@2 {
+-				reg = <2>;
+-				label = "lan2";
+-			};
+-
+-			ports@3 {
+-				reg = <3>;
+-				label = "lan3";
+-			};
+-
+-			ports@4 {
+-				reg = <4>;
+-				label = "lan4";
+-			};
+-
+-			ports@5 {
+-				reg = <5>;
+-				label = "cpu";
+-				ethernet = <&eth1>;
+-				phy-mode = "rgmii-id";
+-
+-				fixed-link {
+-					speed = <1000>;
+-					full-duplex;
+-				};
+-			};
+-
+-			/* port 6 is connected to eth0 */
+-		};
+-	};
+-};
+-
+-&pinctrl {
+-	pcawan_pins: pcawan-pins {
+-		marvell,pins = "mpp46";
+-		marvell,function = "gpio";
+-	};
+-
+-	spi0cs0_pins: spi0cs0-pins {
+-		marvell,pins = "mpp25";
+-		marvell,function = "spi0";
+-	};
+-
+-	spi0cs1_pins: spi0cs1-pins {
+-		marvell,pins = "mpp26";
+-		marvell,function = "spi0";
+-	};
+-};
+-
+-&spi0 {
+-	pinctrl-names = "default";
+-	pinctrl-0 = <&spi0_pins &spi0cs0_pins>;
+-	status = "okay";
+-
+-	spi-nor@0 {
+-		compatible = "spansion,s25fl164k", "jedec,spi-nor";
+-		#address-cells = <1>;
+-		#size-cells = <1>;
+-		reg = <0>;
+-		spi-max-frequency = <40000000>;
+-
+-		partitions {
+-			compatible = "fixed-partitions";
+-			#address-cells = <1>;
+-			#size-cells = <1>;
+-
+-			partition@0 {
+-				reg = <0x0 0x00100000>;
+-				label = "U-Boot";
+-			};
+-
+-			partition@100000 {
+-				reg = <0x00100000 0x00700000>;
+-				label = "Rescue system";
+-			};
+-		};
+-	};
+-
+-	/* MISO, MOSI, SCLK and CS1 are routed to pin header CN11 */
+-};
+-
+-&uart0 {
+-	/* Pin header CN10 */
+-	pinctrl-names = "default";
+-	pinctrl-0 = <&uart0_pins>;
+-	status = "okay";
+-};
+-
+-&uart1 {
+-	/* Pin header CN11 */
+-	pinctrl-names = "default";
+-	pinctrl-0 = <&uart1_pins>;
+-	status = "okay";
+-};
+--- /dev/null
++++ b/arch/arm/boot/dts/armada-385-turris-omnia.dtsi
+@@ -0,0 +1,400 @@
++/*
++ * Device Tree file for the Turris Omnia
++ *
++ * Copyright (C) 2016 Uwe Kleine-König <uwe@kleine-koenig.org>
++ * Copyright (C) 2016-2019 Tomas Hlavacek <tmshlvkc@gmail.com>
++ *
++ * This file is dual-licensed: you can use it either under the terms
++ * of the GPL or the X11 license, at your option. Note that this dual
++ * licensing only applies to this file, and not this project as a
++ * whole.
++ *
++ *  a) This file is licensed under the terms of the GNU General Public
++ *     License version 2.  This program is licensed "as is" without
++ *     any warranty of any kind, whether express or implied.
++ *
++ * Or, alternatively,
++ *
++ *  b) Permission is hereby granted, free of charge, to any person
++ *     obtaining a copy of this software and associated documentation
++ *     files (the "Software"), to deal in the Software without
++ *     restriction, including without limitation the rights to use,
++ *     copy, modify, merge, publish, distribute, sublicense, and/or
++ *     sell copies of the Software, and to permit persons to whom the
++ *     Software is furnished to do so, subject to the following
++ *     conditions:
++ *
++ *     The above copyright notice and this permission notice shall be
++ *     included in all copies or substantial portions of the Software.
++ *
++ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
++ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
++ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
++ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
++ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
++ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
++ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
++ *     OTHER DEALINGS IN THE SOFTWARE.
++ */
++
++/*
++ * Schematic available at https://www.turris.cz/doc/_media/rtrom01-schema.pdf
++ */
++
++#include <dt-bindings/gpio/gpio.h>
++#include <dt-bindings/input/input.h>
++#include "armada-385.dtsi"
++
++/ {
++	model = "Turris Omnia";
++	compatible = "cznic,turris-omnia", "marvell,armada385", "marvell,armada380";
++
++	chosen {
++		stdout-path = &uart0;
++	};
++
++	memory {
++		device_type = "memory";
++		reg = <0x00000000 0x40000000>; /* 1024 MB */
++	};
++
++	soc {
++		ranges = <MBUS_ID(0xf0, 0x01) 0 0xf1000000 0x100000
++			  MBUS_ID(0x01, 0x1d) 0 0xfff00000 0x100000
++			  MBUS_ID(0x09, 0x19) 0 0xf1100000 0x10000
++			  MBUS_ID(0x09, 0x15) 0 0xf1110000 0x10000>;
++
++		internal-regs {
++
++			/* USB part of the PCIe2/USB 2.0 port */
++			usb@58000 {
++				status = "okay";
++			};
++
++			sata@a8000 {
++				status = "okay";
++			};
++
++			sdhci@d8000 {
++				pinctrl-names = "default";
++				pinctrl-0 = <&sdhci_pins>;
++				status = "okay";
++
++				bus-width = <8>;
++				no-1-8-v;
++				non-removable;
++			};
++
++			usb3@f0000 {
++				status = "okay";
++			};
++
++			usb3@f8000 {
++				status = "okay";
++			};
++		};
++
++		pcie {
++			status = "okay";
++
++			pcie@1,0 {
++				/* Port 0, Lane 0 */
++				status = "okay";
++			};
++
++			pcie@2,0 {
++				/* Port 1, Lane 0 */
++				status = "okay";
++			};
++
++			pcie@3,0 {
++				/* Port 2, Lane 0 */
++				status = "okay";
++			};
++		};
++	};
++
++	sfp: sfp {
++		compatible = "sff,sfp";
++		status = "disabled";
++		i2c-bus = <&i2csfp>;
++		tx-fault-gpios = <&sfpgpio 0 GPIO_ACTIVE_HIGH>;
++		tx-disable-gpios = <&sfpgpio 1 GPIO_ACTIVE_HIGH>;
++		rate-select0-gpios = <&sfpgpio 2 GPIO_ACTIVE_HIGH>;
++		los-gpios = <&sfpgpio 3 GPIO_ACTIVE_HIGH>;
++		mod-def0-gpios = <&sfpgpio 4 GPIO_ACTIVE_LOW>;
++	};
++};
++
++/* Disable eth0 unless there is DSA driver supporting two CPU ports. */
++/* Connected to 88E6176 switch, port 6 */
++/* &eth0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&ge0_rgmii_pins>;
++	status = "okay";
++	phy-mode = "rgmii";
++
++	fixed-link {
++		speed = <1000>;
++		full-duplex;
++	};
++}; */
++
++/* Connected to 88E6176 switch, port 5 */
++&eth1 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&ge1_rgmii_pins>;
++	status = "okay";
++	phy-mode = "rgmii";
++
++	fixed-link {
++		speed = <1000>;
++		full-duplex;
++	};
++};
++
++/* WAN dual-personality port */
++&eth2 {
++        status = "okay";
++};
++
++&i2c0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&i2c0_pins>;
++	status = "okay";
++
++	i2cmux@70 {
++		compatible = "nxp,pca9547";
++		#address-cells = <1>;
++		#size-cells = <0>;
++		reg = <0x70>;
++		status = "okay";
++
++		i2c@0 {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			reg = <0>;
++
++			/* STM32F0 command interface at address 0x2a */
++			/* leds device (in STM32F0) at address 0x2b */
++
++			eeprom@54 {
++				compatible = "atmel,24c64";
++				reg = <0x54>;
++
++				/* The EEPROM contains data for bootloader.
++				 * Contents:
++				 * 	struct omnia_eeprom {
++				 * 		u32 magic; (=0x0341a034 in LE)
++				 *		u32 ramsize; (in GiB)
++				 * 		char regdomain[4];
++				 * 		u32 crc32;
++				 * 	};
++				 */
++			};
++		};
++
++		i2c@1 {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			reg = <1>;
++
++			/* routed to PCIe0/mSATA connector (CN7A) */
++		};
++
++		i2c@2 {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			reg = <2>;
++
++			/* routed to PCIe1/USB2 connector (CN61A) */
++		};
++
++		i2c@3 {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			reg = <3>;
++
++			/* routed to PCIe2 connector (CN62A) */
++		};
++
++		i2csfp: i2c@4 {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			reg = <4>;
++
++			/* routed to SFP+ */
++		};
++
++		i2c@5 {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			reg = <5>;
++
++			/* ATSHA204A at address 0x64 */
++		};
++
++		i2c@6 {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			reg = <6>;
++
++			/* exposed on pin header */
++		};
++
++		i2c@7 {
++			#address-cells = <1>;
++			#size-cells = <0>;
++			reg = <7>;
++
++			sfpgpio: gpio@71 {
++				/*
++				 * GPIO expander for SFP+ signals and
++				 * and phy irq
++				 */
++				compatible = "nxp,pca9538";
++				reg = <0x71>;
++
++				pinctrl-names = "default";
++				pinctrl-0 = <&wanint_pins>;
++
++				interrupt-parent = <&gpio1>;
++				interrupts = <14 IRQ_TYPE_LEVEL_LOW>;
++
++				gpio-controller;
++				#gpio-cells = <2>;
++			};
++		};
++	};
++};
++
++&mdio {
++	pinctrl-names = "default";
++	pinctrl-0 = <&mdio_pins>;
++	status = "okay";
++
++	phy1: phy@1 {
++		status = "disabled";
++		compatible = "ethernet-phy-id0141.0DD1", "ethernet-phy-ieee802.3-c22";
++		reg = <1>;
++
++		/* irq is connected to &pcawan pin 7 */
++	};
++
++	/* Switch MV88E6176 at address 0x10 */
++	switch@10 {
++		compatible = "marvell,mv88e6085";
++		#address-cells = <1>;
++		#size-cells = <0>;
++		dsa,member = <0 0>;
++
++		reg = <0x10>;
++
++		ports {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			ports@0 {
++				reg = <0>;
++				label = "lan0";
++			};
++
++			ports@1 {
++				reg = <1>;
++				label = "lan1";
++			};
++
++			ports@2 {
++				reg = <2>;
++				label = "lan2";
++			};
++
++			ports@3 {
++				reg = <3>;
++				label = "lan3";
++			};
++
++			ports@4 {
++				reg = <4>;
++				label = "lan4";
++			};
++
++			ports@5 {
++				reg = <5>;
++				label = "cpu";
++				ethernet = <&eth1>;
++				phy-mode = "rgmii-id";
++
++				fixed-link {
++					speed = <1000>;
++					full-duplex;
++				};
++			};
++
++			/* port 6 is connected to eth0 */
++		};
++	};
++};
++
++&pinctrl {
++	wanint_pins: wanint-pins {
++		marvell,pins = "mpp46";
++		marvell,function = "gpio";
++	};
++
++	spi0cs0_pins: spi0cs0-pins {
++		marvell,pins = "mpp25";
++		marvell,function = "spi0";
++	};
++
++	spi0cs1_pins: spi0cs1-pins {
++		marvell,pins = "mpp26";
++		marvell,function = "spi0";
++	};
++};
++
++&spi0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&spi0_pins &spi0cs0_pins>;
++	status = "okay";
++
++	spi-nor@0 {
++		compatible = "spansion,s25fl164k", "jedec,spi-nor";
++		#address-cells = <1>;
++		#size-cells = <1>;
++		reg = <0>;
++		spi-max-frequency = <40000000>;
++
++		partitions {
++			compatible = "fixed-partitions";
++			#address-cells = <1>;
++			#size-cells = <1>;
++
++			partition@0 {
++				reg = <0x0 0x00100000>;
++				label = "U-Boot";
++			};
++
++			partition@100000 {
++				reg = <0x00100000 0x00700000>;
++				label = "Rescue system";
++			};
++		};
++	};
++
++	/* MISO, MOSI, SCLK and CS1 are routed to pin header CN11 */
++};
++
++&uart0 {
++	/* Pin header CN10 */
++	pinctrl-names = "default";
++	pinctrl-0 = <&uart0_pins>;
++	status = "okay";
++};
++
++&uart1 {
++	/* Pin header CN11 */
++	pinctrl-names = "default";
++	pinctrl-0 = <&uart1_pins>;
++	status = "okay";
++};
diff --git a/target/linux/mvebu/patches-4.19/8889-Reenable-Turris-Omnia-second-ethernet-connection-to-.patch b/target/linux/mvebu/patches-4.19/8889-Reenable-Turris-Omnia-second-ethernet-connection-to-.patch
new file mode 100644
index 0000000..fc7f13e
--- /dev/null
+++ b/target/linux/mvebu/patches-4.19/8889-Reenable-Turris-Omnia-second-ethernet-connection-to-.patch
@@ -0,0 +1,39 @@
+From a7c04d8029e3f4c8b4e01b73502e885494132d8c Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Karel=20Ko=C4=8D=C3=AD?= <karel.koci@nic.cz>
+Date: Mon, 11 Mar 2019 13:21:04 +0100
+Subject: [PATCH] Reenable Turris Omnia second ethernet connection to switch
+
+When we disable this link we not only cause all links to be shifted
+down it also causes for some reason null pointer dereference kernel
+panic on phy0 reconfiguration.
+---
+ arch/arm/boot/dts/armada-385-turris-omnia.dtsi | 5 ++---
+ 1 file changed, 2 insertions(+), 3 deletions(-)
+
+diff --git a/arch/arm/boot/dts/armada-385-turris-omnia.dtsi b/arch/arm/boot/dts/armada-385-turris-omnia.dtsi
+index e216c653e013..17146f7af49b 100644
+--- a/arch/arm/boot/dts/armada-385-turris-omnia.dtsi
++++ b/arch/arm/boot/dts/armada-385-turris-omnia.dtsi
+@@ -115,9 +115,8 @@
+ 	};
+ };
+ 
+-/* Disable eth0 unless there is DSA driver supporting two CPU ports. */
+ /* Connected to 88E6176 switch, port 6 */
+-/* &eth0 {
++&eth0 {
+ 	pinctrl-names = "default";
+ 	pinctrl-0 = <&ge0_rgmii_pins>;
+ 	status = "okay";
+@@ -127,7 +126,7 @@
+ 		speed = <1000>;
+ 		full-duplex;
+ 	};
+-}; */
++};
+ 
+ /* Connected to 88E6176 switch, port 5 */
+ &eth1 {
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.19/8890-turris-omnia-led-driver.patch b/target/linux/mvebu/patches-4.19/8890-turris-omnia-led-driver.patch
new file mode 100644
index 0000000..9207290
--- /dev/null
+++ b/target/linux/mvebu/patches-4.19/8890-turris-omnia-led-driver.patch
@@ -0,0 +1,317 @@
+From d906c53c7433b3f20f4210284ec9b174c91f24c8 Mon Sep 17 00:00:00 2001
+From: Tomas Hlavacek <tmshlvck@gmail.com>
+Date: Thu, 16 Jun 2016 17:44:22 +0200
+Subject: [PATCH] Turris Omnia: Add LED driver for MCU LED driver
+
+Add leds-omnia driver that implements plain LED interface.
+
+Turris Omnia board have sophisticated but unfotunatelly completely proprietary I2C LED driver implemented in the MCU on the board.
+
+The I2C protocol description will be published in https://www.turris.cz/en/hardware .
+
+The driver does not allow to control proprietary functions that are hard to map to the Linux LED API:
+
+ * per-led brigtness - the only two states (LED on/off) are supported, even though each LED supports individual PWM based 8-bit RGB
+
+ * global_brightness - fast common PWM for all LEDs (can be decreased/increased by the HW button)
+
+ * color - slow PWM color functionality for each LED (the LEDs are RGB triplets, but the MCU abstraction makes it hard to do the usual RGB mapping)
+
+ * autonomous operation - each LED can operate autonomously (being driven by MCU based on the assigned indicator output from PHY/ethernet switch/PCI cards etc.), autonomous mode is on by default when the Linux led driver is not loaded. Once the Linux LED driver is loaded and once an individual LED is accessed (by setting the brightness) for the first time, it changes to the non-autonomous mode and it can not be set back to autonomous operation mode from the Linux LED driver without unloading it. When this driver is removed all LEDs are set back to autonomous mode.
+
+The MCU supports setting all LEDs at once by setting the virtual 12th LED. This (hackish) feature is supported as well.
+---
+ drivers/leds/Kconfig      |   7 ++
+ drivers/leds/Makefile     |   1 +
+ drivers/leds/leds-omnia.c | 259 ++++++++++++++++++++++++++++++++++++++
+ 3 files changed, 267 insertions(+)
+ create mode 100644 drivers/leds/leds-omnia.c
+
+--- a/drivers/leds/Kconfig
++++ b/drivers/leds/Kconfig
+@@ -681,6 +681,13 @@ config LEDS_SC27XX_BLTC
+ 	  This driver can also be built as a module. If so the module will be
+ 	  called leds-sc27xx-bltc.
+ 
++config LEDS_OMNIA
++	tristate "LED support for the Turris Omnia board"
++	depends on LEDS_CLASS
++	help
++	  Say Y here to include support for the LED driver on Turris Omnia
++	  board.
++
+ comment "LED driver for blink(1) USB RGB LED is under Special HID drivers (HID_THINGM)"
+ 
+ config LEDS_BLINKM
+--- a/drivers/leds/Makefile
++++ b/drivers/leds/Makefile
+@@ -78,6 +78,7 @@ obj-$(CONFIG_LEDS_MT6323)		+= leds-mt632
+ obj-$(CONFIG_LEDS_LM3692X)		+= leds-lm3692x.o
+ obj-$(CONFIG_LEDS_SC27XX_BLTC)		+= leds-sc27xx-bltc.o
+ obj-$(CONFIG_LEDS_LM3601X)		+= leds-lm3601x.o
+++obj-$(CONFIG_LEDS_OMNIA)		+= leds-omnia.o
+ 
+ # LED SPI Drivers
+ obj-$(CONFIG_LEDS_CR0014114)		+= leds-cr0014114.o
+--- /dev/null
++++ b/drivers/leds/leds-omnia.c
+@@ -0,0 +1,259 @@
++/*
++ * Copyright 2016 CZ.NIC, z.s.p.o.
++ *
++ * Author: Tomas Hlavacek <tmshlvck@gmail.com>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License version 2 as
++ * published by the Free Software Foundation. 
++ */
++
++#include <linux/module.h>
++#include <linux/delay.h>
++#include <linux/string.h>
++#include <linux/ctype.h>
++#include <linux/leds.h>
++#include <linux/err.h>
++#include <linux/i2c.h>
++#include <linux/slab.h>
++#include <linux/of.h>
++
++#define MAX_LEDS 13
++#define ALL_LEDS_INDEX 12
++
++#define LED_AUTONOMOUS_ADDR 3
++#define LED_ONOFF_ADDR 4
++
++
++
++struct omnia_platform_data {
++        struct led_platform_data leds;
++};
++
++static const struct i2c_device_id omnia_id[] = {
++	{ "omnia", 0 },
++	{ }
++};
++MODULE_DEVICE_TABLE(i2c, omnia_id);
++
++struct omnia_led_mcu {
++	struct mutex mutex;
++	struct i2c_client *client;
++	struct omnia_led *leds;
++};
++
++struct omnia_led {
++	struct omnia_led_mcu *chip;
++	struct led_classdev led_cdev;
++	int led_num; /* 0 .. 11 + 12=ALL */
++	char name[32];
++	u8 autonomous;
++};
++
++static int omnia_led_brightness_set(struct omnia_led *led,
++				enum led_brightness brightness)
++{
++	int ret;
++
++	mutex_lock(&led->chip->mutex);
++
++	ret = i2c_smbus_write_byte_data(led->chip->client, LED_ONOFF_ADDR,
++			(led->led_num | ((brightness != LED_OFF)<<4)));
++
++	mutex_unlock(&led->chip->mutex);
++	return ret;
++}
++
++static int omnia_led_autonomous_set(struct omnia_led *led, int autonomous)
++{
++	int ret, i;
++
++	mutex_lock(&led->chip->mutex);
++
++	if (led->autonomous == (autonomous != 0)) {
++		mutex_unlock(&led->chip->mutex);
++		return 0;
++	}
++
++	led->autonomous = (autonomous != 0);
++
++	if (led->led_num == ALL_LEDS_INDEX) {
++		for (i=0; i<(MAX_LEDS-1); i++)
++			led->chip->leds[i].autonomous = led->autonomous;
++	}
++
++	ret = i2c_smbus_write_byte_data(led->chip->client, LED_AUTONOMOUS_ADDR,
++			(u8)(led->led_num | ((!led->autonomous) << 4)));
++
++	mutex_unlock(&led->chip->mutex);
++	return ret;
++}
++
++static int omnia_led_set(struct led_classdev *led_cdev,
++	enum led_brightness value)
++{
++	struct omnia_led *led;
++	int ret;
++
++	led = container_of(led_cdev, struct omnia_led, led_cdev);
++
++	if (led->autonomous) {
++		ret = omnia_led_autonomous_set(led, 0);
++		if (ret < 0)
++			return ret;
++	}
++
++	return omnia_led_brightness_set(led, value);
++}
++
++static struct omnia_platform_data *
++omnia_dt_init(struct i2c_client *client)
++{
++	struct device_node *np = client->dev.of_node, *child;
++	struct omnia_platform_data *pdata;
++	struct led_info *leds;
++	int count;
++
++	count = of_get_child_count(np);
++	if (!count || count > MAX_LEDS)
++		return ERR_PTR(-ENODEV);
++
++	leds = devm_kzalloc(&client->dev,
++			sizeof(struct led_info) * MAX_LEDS, GFP_KERNEL);
++	if (!leds)
++		return ERR_PTR(-ENOMEM);
++
++	for_each_child_of_node(np, child) {
++		u32 reg;
++		int res;
++
++		res = of_property_read_u32(child, "reg", &reg);
++		if ((res != 0) || (reg >= MAX_LEDS))
++			continue;
++		leds[reg].name =
++			of_get_property(child, "label", NULL) ? : child->name;
++		leds[reg].default_trigger =
++			of_get_property(child, "linux,default-trigger", NULL);
++	}
++	pdata = devm_kzalloc(&client->dev,
++			     sizeof(struct omnia_platform_data), GFP_KERNEL);
++	if (!pdata)
++		return ERR_PTR(-ENOMEM);
++
++	pdata->leds.leds = leds;
++	pdata->leds.num_leds = MAX_LEDS;
++
++	return pdata;
++}
++
++static const struct of_device_id of_omnia_match[] = {
++	{ .compatible = "turris-leds,omnia", },
++	{},
++};
++MODULE_DEVICE_TABLE(of, of_omnia_match);
++
++static int omnia_probe(struct i2c_client *client,
++					const struct i2c_device_id *id)
++{
++	struct omnia_led_mcu *chip;
++	struct omnia_led *leds;
++	struct omnia_platform_data *pdata;
++	int i, err;
++
++	pdata = dev_get_platdata(&client->dev);
++
++	if (!pdata) {
++		pdata = omnia_dt_init(client);
++		if (IS_ERR(pdata)) {
++			dev_warn(&client->dev, "could not parse configuration\n");
++			pdata = NULL;
++		}
++	}
++
++	chip = devm_kzalloc(&client->dev, sizeof(*chip),
++				GFP_KERNEL);
++	if (!chip)
++		return -ENOMEM;
++	leds = devm_kzalloc(&client->dev, MAX_LEDS * sizeof(*leds),
++				GFP_KERNEL);
++	if (!leds)
++		return -ENOMEM;
++
++	i2c_set_clientdata(client, chip);
++
++	mutex_init(&chip->mutex);
++	chip->client = client;
++	chip->leds = leds;
++
++	for (i = 0; i < MAX_LEDS; i++) {
++		leds[i].led_num = i;
++		leds[i].chip = chip;
++
++		/* Platform data can specify LED names and default triggers */
++		if (pdata && i < pdata->leds.num_leds) {
++			if (pdata->leds.leds[i].name)
++				snprintf(leds[i].name,
++					 sizeof(leds[i].name), "omnia-led:%s",
++					 pdata->leds.leds[i].name);
++			if (pdata->leds.leds[i].default_trigger)
++				leds[i].led_cdev.default_trigger =
++					pdata->leds.leds[i].default_trigger;
++		}
++		if (!pdata || i >= pdata->leds.num_leds ||
++						!pdata->leds.leds[i].name)
++			snprintf(leds[i].name, sizeof(leds[i].name),
++				 "omnia-led:%d", i);
++
++		leds[i].led_cdev.name = leds[i].name;
++		leds[i].led_cdev.brightness_set_blocking = omnia_led_set;
++
++		err = led_classdev_register(&client->dev, &leds[i].led_cdev);
++		if (err < 0)
++			goto exit;
++
++		/* Set AUTO for all LEDs by default */
++		leds[i].autonomous = 0;
++		omnia_led_autonomous_set(&leds[i], 1);
++	}
++
++	return 0;
++
++exit:
++	while (i--) {
++		led_classdev_unregister(&leds[i].led_cdev);
++	}
++
++	return err;
++}
++
++static int omnia_remove(struct i2c_client *client)
++{
++	struct omnia_led_mcu *chip = i2c_get_clientdata(client);
++	int i;
++
++	for (i = 0; i < MAX_LEDS; i++) {
++		led_classdev_unregister(&chip->leds[i].led_cdev);
++
++		/* Set AUTO for the LED */
++		omnia_led_autonomous_set(&chip->leds[i], 1);
++	}
++
++	return 0;
++}
++
++static struct i2c_driver omnia_driver = {
++	.driver = {
++		.name	= "leds-omnia",
++		.of_match_table = of_match_ptr(of_omnia_match),
++	},
++	.probe	= omnia_probe,
++	.remove	= omnia_remove,
++	.id_table = omnia_id,
++};
++
++module_i2c_driver(omnia_driver);
++
++MODULE_AUTHOR("Tomas Hlavacek <tmshlvck@gmail.com>");
++MODULE_DESCRIPTION("Turris Omnia LED driver");
++MODULE_LICENSE("GPL v2");
++
diff --git a/target/linux/mvebu/patches-4.19/8891-turris-omnia-custom-led-functions.patch b/target/linux/mvebu/patches-4.19/8891-turris-omnia-custom-led-functions.patch
new file mode 100644
index 0000000..739d30c
--- /dev/null
+++ b/target/linux/mvebu/patches-4.19/8891-turris-omnia-custom-led-functions.patch
@@ -0,0 +1,269 @@
+From d8f1b754703e91bb5156e27e4f0ad5d974328200 Mon Sep 17 00:00:00 2001
+From: Tomas Hlavacek <tmshlvck@gmail.com>
+Date: Fri, 22 Feb 2019 20:52:33 +0100
+Subject: [PATCH] Turris Omnia: Add proprietary part of LED driver
+
+Add proprietary part of leds-omnia driver that implements Linux LED interfacei.
+
+On top of that driver that is able to set non-autonomous mode and use slow PWM to drive individual LEDs and also the 12th virtual ALL LED add following sysfs files for setting:
+
+global_brightness - [0..100] = PWM base for all the LEDs. It is the maximum intensity. Particular colors on each LED might be decreased individually.
+
+color - [0..255] [0..255] [0..255] = PWM for each color on each LED.
+
+autonomous [0|1] = 1=MCU drives the LED according to its default function, blink from Linux LED driver is ignored; 0=Linux LED driver sets brightness/blink.
+---
+ drivers/leds/leds-omnia.c | 195 ++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 195 insertions(+)
+
+diff --git a/drivers/leds/leds-omnia.c b/drivers/leds/leds-omnia.c
+index 0e10e806556e..38d8c8251b2f 100644
+--- a/drivers/leds/leds-omnia.c
++++ b/drivers/leds/leds-omnia.c
+@@ -23,6 +23,9 @@
+ 
+ #define LED_AUTONOMOUS_ADDR 3
+ #define LED_ONOFF_ADDR 4
++#define LED_COLOR_ADDR 5
++#define GLOB_BRIGHTNESS_READ 8
++#define GLOB_BRIGHTNESS_WRITE 7
+ 
+ 
+ 
+@@ -48,6 +51,9 @@ struct omnia_led {
+ 	int led_num; /* 0 .. 11 + 12=ALL */
+ 	char name[32];
+ 	u8 autonomous;
++	u8 r;
++	u8 g;
++	u8 b;
+ };
+ 
+ static int omnia_led_brightness_set(struct omnia_led *led,
+@@ -89,6 +95,59 @@ static int omnia_led_autonomous_set(struct omnia_led *led, int autonomous)
+ 	return ret;
+ }
+ 
++static int omnia_glob_brightness_set(struct omnia_led_mcu *chip,
++					int glob_brightness)
++{
++	int ret;
++
++	mutex_lock(&chip->mutex);
++
++	ret = i2c_smbus_write_byte_data(chip->client, GLOB_BRIGHTNESS_WRITE,
++						(u8)glob_brightness);
++
++	mutex_unlock(&chip->mutex);
++	return ret;
++}
++
++static int omnia_glob_brightness_get(struct omnia_led_mcu *chip)
++{
++	int ret;
++
++	mutex_lock(&chip->mutex);
++
++	ret = i2c_smbus_read_byte_data(chip->client, GLOB_BRIGHTNESS_READ);
++
++	mutex_unlock(&chip->mutex);
++	return ret;
++}
++
++static int omnia_led_color_set(struct omnia_led *led, u8 r, u8 g, u8 b)
++{
++	int ret, i;
++	u8 buf[5];
++
++	buf[0] = LED_COLOR_ADDR;
++	buf[1] = led->led_num;
++	buf[2] = r;
++	buf[3] = g;
++	buf[4] = b;
++
++	mutex_lock(&led->chip->mutex);
++
++	ret = i2c_master_send(led->chip->client, buf, 5);
++
++	if (led->led_num == ALL_LEDS_INDEX) {
++		for (i=0; i<(MAX_LEDS-1); i++) {
++			led->chip->leds[i].r = led->r;
++			led->chip->leds[i].g = led->g;
++			led->chip->leds[i].b = led->b;
++		}
++	}
++
++	mutex_unlock(&led->chip->mutex);
++	return -(ret<=0);
++}
++
+ static int omnia_led_set(struct led_classdev *led_cdev,
+ 	enum led_brightness value)
+ {
+@@ -146,6 +205,98 @@ omnia_dt_init(struct i2c_client *client)
+ 	return pdata;
+ }
+ 
++static ssize_t global_brightness_show(struct device *d,
++                struct device_attribute *attr, char *buf)
++{
++	struct i2c_client *client = to_i2c_client(d);
++	struct omnia_led_mcu *chip = i2c_get_clientdata(client);
++
++	return scnprintf(buf, PAGE_SIZE, "%d\n",
++				omnia_glob_brightness_get(chip));
++}
++
++static ssize_t global_brightness_store(struct device *d,
++                struct device_attribute *attr, const char *buf, size_t count)
++{
++	struct i2c_client *client = to_i2c_client(d);
++        struct omnia_led_mcu *chip = i2c_get_clientdata(client);
++	int ret;
++	int global_brightness;
++
++	if ((sscanf(buf, "%i", &global_brightness)) != 1)
++		return -EINVAL;
++
++	ret = omnia_glob_brightness_set(chip, global_brightness);
++	if (ret < 0)
++		return ret;
++
++	return count;
++}
++static DEVICE_ATTR_RW(global_brightness);
++
++static ssize_t autonomous_show(struct device *d,
++                struct device_attribute *attr, char *buf)
++{
++	struct led_classdev *led_cdev = dev_get_drvdata(d);
++	struct omnia_led *led =
++			container_of(led_cdev, struct omnia_led, led_cdev);
++
++	return scnprintf(buf, PAGE_SIZE, "%d\n", led->autonomous);
++}
++
++static ssize_t autonomous_store(struct device *d,
++                struct device_attribute *attr, const char *buf, size_t count)
++{
++	int ret, autonomous;
++	struct led_classdev *led_cdev = dev_get_drvdata(d);
++	struct omnia_led *led =
++			container_of(led_cdev, struct omnia_led, led_cdev);
++
++	if ((sscanf(buf, "%i", &autonomous)) != 1)
++		return -EINVAL;
++
++	ret = omnia_led_autonomous_set(led, autonomous);
++	if (ret < 0)
++		return ret;
++
++	led->autonomous = autonomous;
++	return count;
++}
++static DEVICE_ATTR_RW(autonomous);
++
++static ssize_t color_show(struct device *d,
++                struct device_attribute *attr, char *buf)
++{
++	struct led_classdev *led_cdev = dev_get_drvdata(d);
++	struct omnia_led *led =
++			container_of(led_cdev, struct omnia_led, led_cdev);
++
++	return scnprintf(buf, PAGE_SIZE, "%d %d %d\n", led->r, led->g, led->b);
++}
++
++static ssize_t color_store(struct device *d,
++                struct device_attribute *attr, const char *buf, size_t count)
++{
++	int ret, r, g, b;
++	struct led_classdev *led_cdev = dev_get_drvdata(d);
++	struct omnia_led *led =
++			container_of(led_cdev, struct omnia_led, led_cdev);
++
++	if ((sscanf(buf, "%i %i %i", &r, &g, &b)) != 3)
++		return -EINVAL;
++
++	ret = omnia_led_color_set(led, r, g, b);
++	if (ret < 0)
++		return ret;
++
++	led->r = r;
++	led->g = g;
++	led->b = b;
++	return count;
++}
++static DEVICE_ATTR_RW(color);
++
++
+ static const struct of_device_id of_omnia_match[] = {
+ 	{ .compatible = "turris-leds,omnia", },
+ 	{},
+@@ -211,15 +362,52 @@ static int omnia_probe(struct i2c_client *client,
+ 		if (err < 0)
+ 			goto exit;
+ 
++		err = device_create_file(leds[i].led_cdev.dev,
++						&dev_attr_autonomous);
++		if (err < 0) {
++			dev_err(leds[i].led_cdev.dev,
++				"failed to create attribute autonomous\n");
++			goto exit;
++		}
++
++		err = device_create_file(leds[i].led_cdev.dev,
++						&dev_attr_color);
++		if (err < 0) {
++			dev_err(leds[i].led_cdev.dev,
++				"failed to create attribute color\n");
++			goto exit;
++		}
++
+ 		/* Set AUTO for all LEDs by default */
+ 		leds[i].autonomous = 0;
+ 		omnia_led_autonomous_set(&leds[i], 1);
++
++		/* Set brightness to LED_OFF by default */
++		omnia_led_brightness_set(&leds[i], LED_OFF);
++
++		/* MCU default color is white */
++		leds[i].r = 255;
++		leds[i].g = 255;
++		leds[i].b = 255;
++	}
++
++	err = device_create_file(&client->dev, &dev_attr_global_brightness);
++	if (err < 0) {
++		dev_err(&client->dev,
++			"failed to create attribute global_brightness\n");
++		goto exit;
+ 	}
+ 
+ 	return 0;
+ 
+ exit:
++	device_remove_file(&client->dev, &dev_attr_global_brightness);
+ 	while (i--) {
++		device_remove_file(chip->leds[i].led_cdev.dev,
++			&dev_attr_color);
++		device_remove_file(chip->leds[i].led_cdev.dev,
++			&dev_attr_autonomous);
++
+ 		led_classdev_unregister(&leds[i].led_cdev);
+ 	}
+ 
+@@ -231,7 +419,14 @@ static int omnia_remove(struct i2c_client *client)
+ 	struct omnia_led_mcu *chip = i2c_get_clientdata(client);
+ 	int i;
+ 
++	device_remove_file(&client->dev, &dev_attr_global_brightness);
++
+ 	for (i = 0; i < MAX_LEDS; i++) {
++		device_remove_file(chip->leds[i].led_cdev.dev,
++			&dev_attr_color);
++		device_remove_file(chip->leds[i].led_cdev.dev,
++			&dev_attr_autonomous);
++
+ 		led_classdev_unregister(&chip->leds[i].led_cdev);
+ 
+ 		/* Set AUTO for the LED */
diff --git a/target/linux/mvebu/patches-4.19/8892-turris-omnia-enable-leds-in-dts.patch b/target/linux/mvebu/patches-4.19/8892-turris-omnia-enable-leds-in-dts.patch
new file mode 100644
index 0000000..c162f22
--- /dev/null
+++ b/target/linux/mvebu/patches-4.19/8892-turris-omnia-enable-leds-in-dts.patch
@@ -0,0 +1,102 @@
+From d5945cfa05deba62d79d9f75ab3308047f459c51 Mon Sep 17 00:00:00 2001
+From: Tomas Hlavacek <tmshlvck@gmail.com>
+Date: Thu, 16 Jun 2016 17:51:26 +0200
+Subject: [PATCH] Turris Omnia: Add Omnia LED driver to DT
+
+Add configuration for the leds-omnia driver.
+
+Use the labels from enclosure as the LED names. Use I2C address 0x2b.
+
+The MCU on Omnia board have three I2C slave addresses: 0x2a, 0x2b and 0x2c.
+
+0x2a should be used from userspace applications
+0x2b should be used from kernel LED driver
+0x2c is the special address for bootloader image transfer
+---
+ .../arm/boot/dts/armada-385-turris-omnia.dtsi | 73 +++++++++++++++++++
+ 1 file changed, 73 insertions(+)
+
+diff --git a/arch/arm/boot/dts/armada-385-turris-omnia.dtsi b/arch/arm/boot/dts/armada-385-turris-omnia.dtsi
+index 5045015ce823..d968cda97113 100644
+--- a/arch/arm/boot/dts/armada-385-turris-omnia.dtsi
++++ b/arch/arm/boot/dts/armada-385-turris-omnia.dtsi
+@@ -143,6 +143,79 @@
+ 				 * 	};
+ 				 */
+ 			};
++
++			leds@2b {
++				compatible = "turris-leds,omnia";
++				reg = <0x2b>;
++
++				#address-cells = <1>;
++				#size-cells = <0>;
++
++				led0 {
++					label = "user2";
++					reg = <0x0>;
++				};
++
++				led1 {
++					label = "user1";
++					reg = <0x1>;
++				};
++
++				led2 {
++					label = "pci3";
++					reg = <0x2>;
++				};
++
++				led3 {
++					label = "pci2";
++					reg = <0x3>;
++				};
++
++				led4 {
++					label = "pci1";
++					reg = <0x4>;
++				};
++
++				led5 {
++					label = "wan";
++					reg = <0x5>;
++				};
++
++				led6 {
++					label = "lan4";
++					reg = <0x6>;
++				};
++
++				led7 {
++					label = "lan3";
++					reg = <0x7>;
++				};
++
++				led8 {
++					label = "lan2";
++					reg = <0x8>;
++				};
++
++				led9 {
++					label = "lan1";
++					reg = <0x9>;
++				};
++
++				led10 {
++					label = "lan0";
++					reg = <0xa>;
++				};
++
++				led11 {
++					label = "power";
++					reg = <0xb>;
++				};
++
++		                led12 {
++					label = "all";
++					reg = <0xc>;
++				};
++			};
+ 		};
+ 
+ 		i2c@1 {
-- 
2.22.0

