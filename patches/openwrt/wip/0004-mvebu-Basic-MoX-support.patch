From 6fac8cb130087b61496d7662bd7f802580b46d5b Mon Sep 17 00:00:00 2001
From: Michal Hrusecky <Michal@Hrusecky.net>
Date: Wed, 7 Mar 2018 17:10:32 +0100
Subject: [PATCH] mvebu: Basic MoX support
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Adding basic support for CZ.NICs MoX board.

Signed-off-by: Michal Hrusecky <Michal@Hrusecky.net>
Signed-off-by: Karel Kočí <karel.koci@nic.cz>
---
 target/linux/mvebu/config-4.14                |   1 +
 target/linux/mvebu/image/cortex-a53.mk        |  11 +
 ...ark-allow-to-specify-link-capability.patch |  43 -
 ...ecure-remove-null-check-before-kfree.patch |  34 +
 ...cure-do-not-use-areq-result-for-part.patch |  63 ++
 ...nside-secure-remove-extra-empty-line.patch |  28 +
 ...-inside-secure-fix-typo-in-a-comment.patch |  29 +
 ...-inside-secure-remove-useless-memset.patch |  30 +
 ...cure-refrain-from-unneeded-invalidat.patch |  91 ++
 ...cure-EBUSY-is-not-an-error-on-async-.patch |  35 +
 ...cure-move-cipher-crypto-mode-to-requ.patch |  76 ++
 ...cure-remove-unused-parameter-in-inva.patch |  74 ++
 ...cure-move-request-dequeueing-into-a-.patch | 204 ++++
 ...cure-use-threaded-IRQs-for-result-ha.patch | 136 +++
 ...-secure-dequeue-all-requests-at-once.patch | 179 ++++
 ...inside-secure-increase-the-ring-size.patch |  37 +
 ...cure-acknowledge-the-result-requests.patch |  62 ++
 ...cure-handle-more-result-requests-whe.patch |  70 ++
 ...cure-retry-to-proceed-the-request-la.patch | 103 ++
 ...7-crypto-inside-secure-EIP97-support.patch | 841 ++++++++++++++++
 ...cure-make-function-safexcel_try_push.patch |  38 +
 ...cure-do-not-overwrite-the-threshold-.patch |  40 +
 ...cure-keep-the-requests-push-pop-sync.patch | 136 +++
 ...cure-unmap-the-result-in-the-hash-se.patch |  42 +
 ...cure-move-hash-result-dma-mapping-to.patch | 115 +++
 ...cure-move-cache-result-dma-mapping-t.patch | 152 +++
 ...cure-fix-missing-unlock-on-error-in-.patch |  36 +
 ...-secure-improve-clock-initialization.patch |  48 +
 ...cure-fix-clock-resource-by-adding-a-.patch | 146 +++
 ...cure-move-the-digest-to-the-request-.patch | 161 +++
 ...cure-fix-typo-s-allways-always-in-a-.patch |  45 +
 ...secure-fix-a-typo-in-a-register-name.patch |  45 +
 ...e-secure-improve-the-send-error-path.patch |  50 +
 ...cure-do-not-access-buffers-mapped-to.patch |  46 +
 ...de-secure-improve-the-skcipher-token.patch |  36 +
 ...cure-the-context-ipad-opad-should-us.patch |  42 +
 ...to-inside-secure-hmac-sha256-support.patch | 174 ++++
 ...to-inside-secure-hmac-sha224-support.patch | 110 +++
 ...arvell-armada-37xx-add-a-crypto-node.patch |  42 +
 ...0038-net-mvneta-tx-queue-workaround.patch} |  17 +-
 ...0-net-mvneta-hack-fix-phy_interface.patch} |  11 +-
 ...e-MVNETA_CAUSE_PSC_SYNC_CHANGE-inte.patch} |  18 +-
 ...a-add-module-EEPROM-reading-support.patch} |  13 +-
 ...d-phy-remove-fixed_phy_update_state.patch} |  17 +-
 ...eprom-ethtool-access-into-netdev-co.patch} |  38 +-
 ...p-use-netdev-sfp_bus-for-start-stop.patch} |   9 +-
 ...armada-37xx-periph-cosmetic-changes.patch} |  21 +-
 ...37xx-periph-prepare-cpu-clk-to-be-u.patch} |  25 +-
 ...37xx-periph-add-DVFS-support-for-cp.patch} |  20 +-
 ...eq-Add-DVFS-support-for-Armada-37xx.patch} |  18 +-
 ...SPI-mode-before-asserting-chip-sele.patch} |  18 +-
 ...rvell-Fix-A37xx-UART0-register-size.patch} |  11 +-
 ...-marvell-armada-37xx-add-UART-clock.patch} |   9 +-
 ...-armada-37xx-add-nodes-allowing-cpu.patch} |  13 +-
 ...s-marvell-armada37xx-Add-eth0-alias.patch} |   9 +-
 ...host-and-device-to-the-same-MAX-pay.patch} |  45 +-
 ...rdvark-disable-LOS-state-by-default.patch} |  32 +-
 ...9-net-mvneta-move-port-configuration.patch | 106 ++
 ...060-net-mvneta-add-1000BaseX-support.patch |  65 ++
 ...7xx-account-for-const-type-of-of_dev.patch |  40 +
 ...3700-Set-frequency-limits-at-startup.patch |  46 +
 ...Allow-to-enable-or-disable-FIFO-mode.patch |  51 +
 ...64-spi-a3700-Add-full-duplex-support.patch | 169 ++++
 ...-endianness-swapping-functions-when-.patch |  51 +
 ...-endianness-swapping-for-full-duplex.patch |  66 ++
 ...7xx-Add-edge-both-type-gpio-irq-supp.patch | 109 ++
 ...7xx-Stop-using-struct-gpio_chip.irq_.patch |  49 +
 ...l-armada-37xx-remove-unused-variable.patch |  35 +
 ...mv88e6xxx-Fix-name-of-switch-88E6141.patch |  35 +
 ...d-phy_interface_mode_is_8023z-helper.patch |  59 ++
 ...metic-fixes-to-phylink-sfp-sfp-bus.c.patch | 246 +++++
 .../90073-sfp-fix-sparse-warning.patch        |  30 +
 ...-t-guess-support-from-connector-type.patch |  57 ++
 ...rt-for-1000Base-PX-and-1000Base-BX10.patch |  60 ++
 ...et-dsa-Add-PHYLINK-switch-operations.patch | 102 ++
 ...net-dsa-Eliminate-dsa_slave_get_link.patch |  50 +
 ...Provide-PHY-interface-to-mac_link_-u.patch |  84 ++
 ...nk-Allow-specifying-PHY-device-flags.patch |  71 ++
 ...link-Use-PHY-device-interface-if-N-A.patch |  35 +
 ...net-phy-phylink-Remove-error-message.patch |  35 +
 ...0082-net-dsa-Plug-in-PHYLINK-support.patch | 577 +++++++++++
 ...lper-for-configuring-2500BaseX-modes.patch |  74 ++
 ...et-dsa-mv88e6xxx-add-PHYLINK-support.patch | 213 ++++
 ...8e6xxx-Add-support-to-enabling-pause.patch | 171 ++++
 ...et-dsa-mv88e6xxx-add-phylink-support.patch | 705 +++++++++++++
 ...-mv88e6xxx-Refactor-SERDES-lane-code.patch | 284 ++++++
 ...88e6xxx-6390-vs-6390X-SERDES-support.patch | 126 +++
 ...v88e6xxx-88E6141-6341-SERDES-support.patch |  87 ++
 ...xxx-Rename-sgmii-10g-power-functions.patch |  65 ++
 ...x-Add-serdes-register-read-write-hel.patch | 107 ++
 ...x-2500Base-X-uses-the-1000Base-X-SER.patch |  34 +
 ...t-dsa-mv88e6xxx-Cache-the-port-cmode.patch | 439 +++++++++
 ...x-Power-on-off-SERDES-on-cmode-chang.patch |  53 +
 ...x-link-mv88e6xxx_port-to-mv88e6xxx_c.patch |  48 +
 ...x-Add-SERDES-phydev_mac_change-up-fo.patch | 361 +++++++
 ...x-Re-setup-interrupts-on-CMODE-chang.patch | 108 ++
 ...e6xxx-Poll-when-no-interrupt-defined.patch | 249 +++++
 ...mv88e6xxx-Add-missing-g1-IRQ-numbers.patch |  41 +
 ...v88e6xxx-Add-number-of-internal-PHYs.patch | 257 +++++
 ...x-Add-MDIO-interrupts-for-internal-P.patch | 135 +++
 ...x-Fix-PHY-interrupts-by-parameterisi.patch | 263 +++++
 ...8e6xxx-Fix-interrupt-name-for-g2-irq.patch |  41 +
 ...4-net-dsa-mv88e6xxx-Fix-irq-free-ing.patch |  31 +
 ...v88e6xxx-Use-the-DT-IRQ-trigger-mode.patch |  38 +
 ...8e6xxx-Call-the-common-IRQ-free-code.patch |  31 +
 ...v88e6xxx-Fix-IRQ-when-loading-module.patch |  43 +
 ...x-fix-races-between-lock-and-irq-fre.patch | 102 ++
 ...-dsa-mv88e6xxx-Share-main-switch-IRQ.patch |  29 +
 ...x-Fix-88E6141-6341-2500mbps-SERDES-s.patch | 103 ++
 ...eta-Fix-napi-structure-mixup-on-arma.patch | 107 ++
 ...fix-mvneta_config_rss-on-armada-3700.patch |  77 ++
 ...-armada-37xx-Correct-mpp-definitions.patch | 108 ++
 ...l-armada-37xx-mark-the-gpio-controll.patch |  56 ++
 ...ivers-mfd-Add-support-for-Moxtet-bus.patch | 764 ++++++++++++++
 ...dd-support-for-GPIOs-over-Moxtet-bus.patch | 280 ++++++
 ...support-for-Armada-37xx-CPU-watchdog.patch | 461 +++++++++
 ...hdog-Document-armada-37xx-wdt-bindin.patch |  52 +
 ...tchdog-add-documentation-for-armada-.patch |  37 +
 ...l-armada-37xx-add-nodes-to-support-w.patch |  44 +
 ...drvark-warm-reset-the-cores-and-card.patch | 121 +++
 ...support-for-Armada-37xx-rWTM-mailbox.patch | 328 ++++++
 ...ell-armada37xx-add-rWTM-mailbox-node.patch |  38 +
 ...-Add-Turris-Mox-rWTM-firmware-driver.patch | 454 +++++++++
 ...-marvell-Add-DTS-file-for-Turris-Mox.patch | 931 ++++++++++++++++++
 ...64-restart-Armada-3700-restart-code.patch} |   6 +-
 ...-cpufreq-armada-37xx-Fix-clock-leak.patch} |   0
 ...37xx-periph-Fix-switching-CPU-rate-.patch} |   0
 ...37xx-periph-Fix-wrong-return-value-.patch} |   0
 ...37xx-periph-Remove-unused-var-num_p.patch} |   0
 129 files changed, 14149 insertions(+), 176 deletions(-)
 delete mode 100644 target/linux/mvebu/patches-4.14/527-PCI-aardvark-allow-to-specify-link-capability.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90001-crypto-inside-secure-remove-null-check-before-kfree.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90002-crypto-inside-secure-do-not-use-areq-result-for-part.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90003-crypto-inside-secure-remove-extra-empty-line.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90004-crypto-inside-secure-fix-typo-in-a-comment.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90005-crypto-inside-secure-remove-useless-memset.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90006-crypto-inside-secure-refrain-from-unneeded-invalidat.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90007-crypto-inside-secure-EBUSY-is-not-an-error-on-async-.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90008-crypto-inside-secure-move-cipher-crypto-mode-to-requ.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90009-crypto-inside-secure-remove-unused-parameter-in-inva.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90010-crypto-inside-secure-move-request-dequeueing-into-a-.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90011-crypto-inside-secure-use-threaded-IRQs-for-result-ha.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90012-crypto-inside-secure-dequeue-all-requests-at-once.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90013-crypto-inside-secure-increase-the-ring-size.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90014-crypto-inside-secure-acknowledge-the-result-requests.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90015-crypto-inside-secure-handle-more-result-requests-whe.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90016-crypto-inside-secure-retry-to-proceed-the-request-la.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90017-crypto-inside-secure-EIP97-support.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90018-crypto-inside-secure-make-function-safexcel_try_push.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90019-crypto-inside-secure-do-not-overwrite-the-threshold-.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90020-crypto-inside-secure-keep-the-requests-push-pop-sync.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90021-crypto-inside-secure-unmap-the-result-in-the-hash-se.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90022-crypto-inside-secure-move-hash-result-dma-mapping-to.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90023-crypto-inside-secure-move-cache-result-dma-mapping-t.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90024-crypto-inside-secure-fix-missing-unlock-on-error-in-.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90025-crypto-inside-secure-improve-clock-initialization.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90026-crypto-inside-secure-fix-clock-resource-by-adding-a-.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90027-crypto-inside-secure-move-the-digest-to-the-request-.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90028-crypto-inside-secure-fix-typo-s-allways-always-in-a-.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90029-crypto-inside-secure-fix-a-typo-in-a-register-name.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90030-crypto-inside-secure-improve-the-send-error-path.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90031-crypto-inside-secure-do-not-access-buffers-mapped-to.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90032-crypto-inside-secure-improve-the-skcipher-token.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90033-crypto-inside-secure-the-context-ipad-opad-should-us.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90034-crypto-inside-secure-hmac-sha256-support.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90035-crypto-inside-secure-hmac-sha224-support.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90036-arm64-dts-marvell-armada-37xx-add-a-crypto-node.patch
 rename target/linux/mvebu/patches-4.14/{300-mvneta-tx-queue-workaround.patch => 90038-net-mvneta-tx-queue-workaround.patch} (64%)
 rename target/linux/mvebu/patches-4.14/{404-net-mvneta-hack-fix-phy_interface.patch => 90040-net-mvneta-hack-fix-phy_interface.patch} (65%)
 rename target/linux/mvebu/patches-4.14/{405-net-mvneta-disable-MVNETA_CAUSE_PSC_SYNC_CHANGE-inte.patch => 90041-net-mvneta-disable-MVNETA_CAUSE_PSC_SYNC_CHANGE-inte.patch} (72%)
 rename target/linux/mvebu/patches-4.14/{406-net-mvneta-add-module-EEPROM-reading-support.patch => 90042-net-mvneta-add-module-EEPROM-reading-support.patch} (74%)
 rename target/linux/mvebu/patches-4.14/{407-phy-fixed-phy-remove-fixed_phy_update_state.patch => 90043-phy-fixed-phy-remove-fixed_phy_update_state.patch} (78%)
 rename target/linux/mvebu/patches-4.14/{408-sfp-move-module-eeprom-ethtool-access-into-netdev-co.patch => 90044-sfp-move-module-eeprom-ethtool-access-into-netdev-co.patch} (78%)
 rename target/linux/mvebu/patches-4.14/{409-sfp-use-netdev-sfp_bus-for-start-stop.patch => 90045-sfp-use-netdev-sfp_bus-for-start-stop.patch} (79%)
 rename target/linux/mvebu/patches-4.14/{503-clk-mvebu-armada-37xx-periph-cosmetic-changes.patch => 90048-clk-mvebu-armada-37xx-periph-cosmetic-changes.patch} (73%)
 rename target/linux/mvebu/patches-4.14/{504-clk-mvebu-armada-37xx-periph-prepare-cpu-clk-to-be-u.patch => 90049-clk-mvebu-armada-37xx-periph-prepare-cpu-clk-to-be-u.patch} (85%)
 rename target/linux/mvebu/patches-4.14/{505-clk-mvebu-armada-37xx-periph-add-DVFS-support-for-cp.patch => 90050-clk-mvebu-armada-37xx-periph-add-DVFS-support-for-cp.patch} (93%)
 rename target/linux/mvebu/patches-4.14/{506-cpufreq-Add-DVFS-support-for-Armada-37xx.patch => 90051-cpufreq-Add-DVFS-support-for-Armada-37xx.patch} (93%)
 rename target/linux/mvebu/patches-4.14/{501-spi-a3700-Change-SPI-mode-before-asserting-chip-sele.patch => 90052-spi-a3700-Change-SPI-mode-before-asserting-chip-sele.patch} (74%)
 rename target/linux/mvebu/patches-4.14/{500-arm64-dts-marvell-Fix-A37xx-UART0-register-size.patch => 90053-arm64-dts-marvell-Fix-A37xx-UART0-register-size.patch} (73%)
 rename target/linux/mvebu/patches-4.14/{502-arm64-dts-marvell-armada-37xx-add-UART-clock.patch => 90054-arm64-dts-marvell-armada-37xx-add-UART-clock.patch} (74%)
 rename target/linux/mvebu/patches-4.14/{507-arm64-dts-marvell-armada-37xx-add-nodes-allowing-cpu.patch => 90055-arm64-dts-marvell-armada-37xx-add-nodes-allowing-cpu.patch} (73%)
 rename target/linux/mvebu/patches-4.14/{520-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch => 90056-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch} (59%)
 rename target/linux/mvebu/patches-4.14/{524-PCI-aardvark-set-host-and-device-to-the-same-MAX-payload-size.patch => 90057-PCI-aardvark-set-host-and-device-to-the-same-MAX-pay.patch} (72%)
 rename target/linux/mvebu/patches-4.14/{526-PCI-aardvark-disable-LOS-state-by-default.patch => 90058-PCI-aardvark-disable-LOS-state-by-default.patch} (50%)
 create mode 100644 target/linux/mvebu/patches-4.14/90059-net-mvneta-move-port-configuration.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90060-net-mvneta-add-1000BaseX-support.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90061-pinctrl-armada-37xx-account-for-const-type-of-of_dev.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90062-spi-a3700-Set-frequency-limits-at-startup.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90063-spi-a3700-Allow-to-enable-or-disable-FIFO-mode.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90064-spi-a3700-Add-full-duplex-support.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90065-spi-a3700-Remove-endianness-swapping-functions-when-.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90066-spi-a3700-Remove-endianness-swapping-for-full-duplex.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90067-pinctrl-armada-37xx-Add-edge-both-type-gpio-irq-supp.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90068-pinctrl-armada-37xx-Stop-using-struct-gpio_chip.irq_.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90069-pinctrl-armada-37xx-remove-unused-variable.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90070-net-dsa-mv88e6xxx-Fix-name-of-switch-88E6141.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90071-phy-add-phy_interface_mode_is_8023z-helper.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90072-net-phy-Cosmetic-fixes-to-phylink-sfp-sfp-bus.c.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90073-sfp-fix-sparse-warning.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90074-sfp-don-t-guess-support-from-connector-type.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90075-sfp-add-support-for-1000Base-PX-and-1000Base-BX10.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90076-net-dsa-Add-PHYLINK-switch-operations.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90077-net-dsa-Eliminate-dsa_slave_get_link.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90078-net-phy-phylink-Provide-PHY-interface-to-mac_link_-u.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90079-net-phy-phylink-Allow-specifying-PHY-device-flags.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90080-net-phy-phylink-Use-PHY-device-interface-if-N-A.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90081-net-phy-phylink-Remove-error-message.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90082-net-dsa-Plug-in-PHYLINK-support.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90083-phylink-add-helper-for-configuring-2500BaseX-modes.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90084-net-dsa-mv88e6xxx-add-PHYLINK-support.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90085-net-dsa-mv88e6xxx-Add-support-to-enabling-pause.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90086-net-dsa-mv88e6xxx-add-phylink-support.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90087-net-dsa-mv88e6xxx-Refactor-SERDES-lane-code.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90088-net-dsa-mv88e6xxx-6390-vs-6390X-SERDES-support.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90089-net-dsa-mv88e6xxx-88E6141-6341-SERDES-support.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90090-net-dsa-mv88e6xxx-Rename-sgmii-10g-power-functions.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90091-net-dsa-mv88e6xxx-Add-serdes-register-read-write-hel.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90092-net-dsa-mv88e6xxx-2500Base-X-uses-the-1000Base-X-SER.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90093-net-dsa-mv88e6xxx-Cache-the-port-cmode.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90094-net-dsa-mv88e6xxx-Power-on-off-SERDES-on-cmode-chang.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90095-net-dsa-mv88e6xxx-link-mv88e6xxx_port-to-mv88e6xxx_c.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90096-net-dsa-mv88e6xxx-Add-SERDES-phydev_mac_change-up-fo.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90097-net-dsa-mv88e6xxx-Re-setup-interrupts-on-CMODE-chang.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90098-net-dsa-mv88e6xxx-Poll-when-no-interrupt-defined.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90099-net-dsa-mv88e6xxx-Add-missing-g1-IRQ-numbers.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90100-net-dsa-mv88e6xxx-Add-number-of-internal-PHYs.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90101-net-dsa-mv88e6xxx-Add-MDIO-interrupts-for-internal-P.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90102-net-dsa-mv88e6xxx-Fix-PHY-interrupts-by-parameterisi.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90103-net-dsa-mv88e6xxx-Fix-interrupt-name-for-g2-irq.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90104-net-dsa-mv88e6xxx-Fix-irq-free-ing.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90105-net-dsa-mv88e6xxx-Use-the-DT-IRQ-trigger-mode.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90106-net-dsa-mv88e6xxx-Call-the-common-IRQ-free-code.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90107-net-dsa-mv88e6xxx-Fix-IRQ-when-loading-module.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90108-net-dsa-mv88e6xxx-fix-races-between-lock-and-irq-fre.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90109-net-dsa-mv88e6xxx-Share-main-switch-IRQ.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90110-net-dsa-mc88e6xxx-Fix-88E6141-6341-2500mbps-SERDES-s.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90111-net-ethernet-mvneta-Fix-napi-structure-mixup-on-arma.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90112-net-mvneta-fix-mvneta_config_rss-on-armada-3700.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90113-pinctrl-armada-37xx-Correct-mpp-definitions.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90114-arm64-dts-marvell-armada-37xx-mark-the-gpio-controll.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90115-drivers-mfd-Add-support-for-Moxtet-bus.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90116-drivers-gpio-Add-support-for-GPIOs-over-Moxtet-bus.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90117-watchdog-Add-support-for-Armada-37xx-CPU-watchdog.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90118-dt-bindings-watchdog-Document-armada-37xx-wdt-bindin.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90119-documentation-watchdog-add-documentation-for-armada-.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90120-arm64-dts-marvell-armada-37xx-add-nodes-to-support-w.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90121-PCI-aadrvark-warm-reset-the-cores-and-card.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90122-mailbox-Add-support-for-Armada-37xx-rWTM-mailbox.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90123-arm64-dts-marvell-armada37xx-add-rWTM-mailbox-node.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90124-crypto-Add-Turris-Mox-rWTM-firmware-driver.patch
 create mode 100644 target/linux/mvebu/patches-4.14/90125-ARM64-dts-marvell-Add-DTS-file-for-Turris-Mox.patch
 rename target/linux/mvebu/patches-4.14/{9999-arm64-restart-Armada-3700-restart-code.patch => 90126-arm64-restart-Armada-3700-restart-code.patch} (89%)
 rename target/linux/mvebu/patches-4.14/{509-cpufreq-armada-37xx-Fix-clock-leak.patch => 9509-cpufreq-armada-37xx-Fix-clock-leak.patch} (100%)
 rename target/linux/mvebu/patches-4.14/{510-clk-mvebu-armada-37xx-periph-Fix-switching-CPU-rate-.patch => 99510-clk-mvebu-armada-37xx-periph-Fix-switching-CPU-rate-.patch} (100%)
 rename target/linux/mvebu/patches-4.14/{511-clk-mvebu-armada-37xx-periph-Fix-wrong-return-value-.patch => 99511-clk-mvebu-armada-37xx-periph-Fix-wrong-return-value-.patch} (100%)
 rename target/linux/mvebu/patches-4.14/{512-clk-mvebu-armada-37xx-periph-Remove-unused-var-num_p.patch => 99512-clk-mvebu-armada-37xx-periph-Remove-unused-var-num_p.patch} (100%)

diff --git a/target/linux/mvebu/config-4.14 b/target/linux/mvebu/config-4.14
index 7b26c9b..1cfce96 100644
--- a/target/linux/mvebu/config-4.14
+++ b/target/linux/mvebu/config-4.14
@@ -379,6 +379,7 @@ CONFIG_NEED_DMA_MAP_STATE=y
 CONFIG_NEON=y
 # CONFIG_NET_CLS_CGROUP is not set
 CONFIG_NET_DSA=y
+CONFIG_NET_DSA_MV88E6060=y
 CONFIG_NET_DSA_MV88E6XXX=y
 CONFIG_NET_DSA_MV88E6XXX_GLOBAL2=y
 CONFIG_NET_DSA_TAG_DSA=y
diff --git a/target/linux/mvebu/image/cortex-a53.mk b/target/linux/mvebu/image/cortex-a53.mk
index d7014d6..4c5baf5 100644
--- a/target/linux/mvebu/image/cortex-a53.mk
+++ b/target/linux/mvebu/image/cortex-a53.mk
@@ -27,6 +27,17 @@ define Device/globalscale_espressobin-v7-emmc
   DEVICE_DTS := armada-3720-espressobin-v7-emmc
 endef
 TARGET_DEVICES += globalscale_espressobin-v7-emmc
+ 
+define Device/cznic-mox
+  KERNEL_NAME := Image dtbs
+  KERNEL := kernel-bin
+  DEVICE_TITLE := MOX (CZ.NICs Marvell Armada 3720 Based Board)
+  DEVICE_PACKAGES := kmod-usb-core kmod-usb2 kmod-usb3 kmod-usb-storage
+  DEVICE_DTS := armada-3720-turris-mox
+  DTS_DIR := $(DTS_DIR)/marvell
+  SUPPORTED_DEVICES := cznic,mox
+endef
+TARGET_DEVICES += cznic-mox
 
 define Device/marvell_armada-3720-db
   $(call Device/Default-arm64)
diff --git a/target/linux/mvebu/patches-4.14/527-PCI-aardvark-allow-to-specify-link-capability.patch b/target/linux/mvebu/patches-4.14/527-PCI-aardvark-allow-to-specify-link-capability.patch
deleted file mode 100644
index fb57f41..0000000
--- a/target/linux/mvebu/patches-4.14/527-PCI-aardvark-allow-to-specify-link-capability.patch
+++ /dev/null
@@ -1,43 +0,0 @@
-From f70b629e488cc3f2a325ac35476f4f7ae502c5d0 Mon Sep 17 00:00:00 2001
-From: Tomasz Maciej Nowak <tmn505@gmail.com>
-Date: Thu, 14 Jun 2018 14:24:40 +0200
-Subject: [PATCH 1/2] PCI: aardvark: allow to specify link capability
-
-Use DT of_pci_get_max_link_speed() facility to allow specifying link
-capability. If none or unspecified value is given it falls back to gen2,
-which is default for Armada 3700 SoC.
-
-Signed-off-by: Tomasz Maciej Nowak <tmn505@gmail.com>
----
- drivers/pci/host/pci-aardvark.c | 11 +++++++++--
- 1 file changed, 9 insertions(+), 2 deletions(-)
-
---- a/drivers/pci/host/pci-aardvark.c
-+++ b/drivers/pci/host/pci-aardvark.c
-@@ -272,6 +272,8 @@ static void advk_pcie_set_ob_win(struct
- 
- static void advk_pcie_setup_hw(struct advk_pcie *pcie)
- {
-+	struct device *dev = &pcie->pdev->dev;
-+	struct device_node *node = dev->of_node;
- 	u32 reg;
- 	int i;
- 
-@@ -311,10 +313,15 @@ static void advk_pcie_setup_hw(struct ad
- 		PCIE_CORE_CTRL2_TD_ENABLE;
- 	advk_writel(pcie, reg, PCIE_CORE_CTRL2_REG);
- 
--	/* Set GEN2 */
-+	/* Set GEN */
- 	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
- 	reg &= ~PCIE_GEN_SEL_MSK;
--	reg |= SPEED_GEN_2;
-+	if (of_pci_get_max_link_speed(node) == 1)
-+		reg |= SPEED_GEN_1;
-+	else if (of_pci_get_max_link_speed(node) == 3)
-+		reg |= SPEED_GEN_3;
-+	else
-+		reg |= SPEED_GEN_2;
- 	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
- 
- 	/* Set lane X1 */
diff --git a/target/linux/mvebu/patches-4.14/90001-crypto-inside-secure-remove-null-check-before-kfree.patch b/target/linux/mvebu/patches-4.14/90001-crypto-inside-secure-remove-null-check-before-kfree.patch
new file mode 100644
index 0000000..54d3142
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90001-crypto-inside-secure-remove-null-check-before-kfree.patch
@@ -0,0 +1,34 @@
+From 54d412c96f00249ea9f561843e1400ace9e3ee18 Mon Sep 17 00:00:00 2001
+From: Himanshu Jha <himanshujha199640@gmail.com>
+Date: Sun, 27 Aug 2017 02:45:30 +0530
+Subject: [PATCH 001/126] crypto: inside-secure - remove null check before
+ kfree
+
+Kfree on NULL pointer is a no-op and therefore checking is redundant.
+
+Signed-off-by: Himanshu Jha <himanshujha199640@gmail.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 6 ++----
+ 1 file changed, 2 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 69f29776591a..46c2e15c0931 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -326,10 +326,8 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 		ctx->base.cache_sz = 0;
+ 	}
+ free_cache:
+-	if (ctx->base.cache) {
+-		kfree(ctx->base.cache);
+-		ctx->base.cache = NULL;
+-	}
++	kfree(ctx->base.cache);
++	ctx->base.cache = NULL;
+ 
+ unlock:
+ 	spin_unlock_bh(&priv->ring[ring].egress_lock);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90002-crypto-inside-secure-do-not-use-areq-result-for-part.patch b/target/linux/mvebu/patches-4.14/90002-crypto-inside-secure-do-not-use-areq-result-for-part.patch
new file mode 100644
index 0000000..b845ade
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90002-crypto-inside-secure-do-not-use-areq-result-for-part.patch
@@ -0,0 +1,63 @@
+From a619454a13ccfe855c4a968ddbcbd4fb01e3d72c Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Mon, 11 Dec 2017 12:10:58 +0100
+Subject: [PATCH 002/126] crypto: inside-secure - do not use areq->result for
+ partial results
+
+This patches update the SafeXcel driver to stop using the crypto
+ahash_request result field for partial results (i.e. on updates).
+Instead the driver local safexcel_ahash_req state field is used, and
+only on final operations the ahash_request result buffer is updated.
+
+Fixes: 1b44c5a60c13 ("crypto: inside-secure - add SafeXcel EIP197 crypto engine driver")
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 10 +++++-----
+ 1 file changed, 5 insertions(+), 5 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 46c2e15c0931..c20c4db12190 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -37,7 +37,7 @@ struct safexcel_ahash_req {
+ 	int nents;
+ 
+ 	u8 state_sz;    /* expected sate size, only set once */
+-	u32 state[SHA256_DIGEST_SIZE / sizeof(u32)];
++	u32 state[SHA256_DIGEST_SIZE / sizeof(u32)] __aligned(sizeof(u32));
+ 
+ 	u64 len;
+ 	u64 processed;
+@@ -130,7 +130,7 @@ static int safexcel_handle_req_result(struct safexcel_crypto_priv *priv, int rin
+ 	struct ahash_request *areq = ahash_request_cast(async);
+ 	struct crypto_ahash *ahash = crypto_ahash_reqtfm(areq);
+ 	struct safexcel_ahash_req *sreq = ahash_request_ctx(areq);
+-	int cache_len, result_sz = sreq->state_sz;
++	int cache_len;
+ 
+ 	*ret = 0;
+ 
+@@ -151,8 +151,8 @@ static int safexcel_handle_req_result(struct safexcel_crypto_priv *priv, int rin
+ 	spin_unlock_bh(&priv->ring[ring].egress_lock);
+ 
+ 	if (sreq->finish)
+-		result_sz = crypto_ahash_digestsize(ahash);
+-	memcpy(sreq->state, areq->result, result_sz);
++		memcpy(areq->result, sreq->state,
++		       crypto_ahash_digestsize(ahash));
+ 
+ 	if (sreq->nents) {
+ 		dma_unmap_sg(priv->dev, areq->src, sreq->nents, DMA_TO_DEVICE);
+@@ -292,7 +292,7 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 	/* Add the token */
+ 	safexcel_hash_token(first_cdesc, len, req->state_sz);
+ 
+-	ctx->base.result_dma = dma_map_single(priv->dev, areq->result,
++	ctx->base.result_dma = dma_map_single(priv->dev, req->state,
+ 					      req->state_sz, DMA_FROM_DEVICE);
+ 	if (dma_mapping_error(priv->dev, ctx->base.result_dma)) {
+ 		ret = -EINVAL;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90003-crypto-inside-secure-remove-extra-empty-line.patch b/target/linux/mvebu/patches-4.14/90003-crypto-inside-secure-remove-extra-empty-line.patch
new file mode 100644
index 0000000..45698aa
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90003-crypto-inside-secure-remove-extra-empty-line.patch
@@ -0,0 +1,28 @@
+From 2290a7921f4f798754e89c171322e912f500505e Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:43 +0100
+Subject: [PATCH 003/126] crypto: inside-secure - remove extra empty line
+
+Cosmetic patch removing an extra empty line between header inclusions.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 1 -
+ 1 file changed, 1 deletion(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index c20c4db12190..37e7fcd2f54b 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -14,7 +14,6 @@
+ #include <linux/dma-mapping.h>
+ #include <linux/dmapool.h>
+ 
+-
+ #include "safexcel.h"
+ 
+ struct safexcel_ahash_ctx {
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90004-crypto-inside-secure-fix-typo-in-a-comment.patch b/target/linux/mvebu/patches-4.14/90004-crypto-inside-secure-fix-typo-in-a-comment.patch
new file mode 100644
index 0000000..b7f716c
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90004-crypto-inside-secure-fix-typo-in-a-comment.patch
@@ -0,0 +1,29 @@
+From 565e38295d82ed2845817f31ac0353683d47a57a Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:44 +0100
+Subject: [PATCH 004/126] crypto: inside-secure - fix typo in a comment
+
+Cosmetic patch fixing one typo in one of the driver's comments.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 37e7fcd2f54b..50c28da35b0d 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -522,7 +522,7 @@ static int safexcel_ahash_cache(struct ahash_request *areq)
+ 		return areq->nbytes;
+ 	}
+ 
+-	/* We could'nt cache all the data */
++	/* We couldn't cache all the data */
+ 	return -E2BIG;
+ }
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90005-crypto-inside-secure-remove-useless-memset.patch b/target/linux/mvebu/patches-4.14/90005-crypto-inside-secure-remove-useless-memset.patch
new file mode 100644
index 0000000..acd329f
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90005-crypto-inside-secure-remove-useless-memset.patch
@@ -0,0 +1,30 @@
+From fdbd3a52cdd843e43d3f0202b2664715f05b715b Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:45 +0100
+Subject: [PATCH 005/126] crypto: inside-secure - remove useless memset
+
+This patch removes an useless memset in the ahash_export function, as
+the zeroed buffer will be entirely overridden the next line.
+
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 1 -
+ 1 file changed, 1 deletion(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 50c28da35b0d..8ed46ff4cbf9 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -642,7 +642,6 @@ static int safexcel_ahash_export(struct ahash_request *areq, void *out)
+ 	export->processed = req->processed;
+ 
+ 	memcpy(export->state, req->state, req->state_sz);
+-	memset(export->cache, 0, crypto_ahash_blocksize(ahash));
+ 	memcpy(export->cache, req->cache, crypto_ahash_blocksize(ahash));
+ 
+ 	return 0;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90006-crypto-inside-secure-refrain-from-unneeded-invalidat.patch b/target/linux/mvebu/patches-4.14/90006-crypto-inside-secure-refrain-from-unneeded-invalidat.patch
new file mode 100644
index 0000000..257ddae
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90006-crypto-inside-secure-refrain-from-unneeded-invalidat.patch
@@ -0,0 +1,91 @@
+From 69f773763fd9d11cc7b9fd1cb0990f8f3070689e Mon Sep 17 00:00:00 2001
+From: Ofer Heifetz <oferh@marvell.com>
+Date: Thu, 14 Dec 2017 15:26:47 +0100
+Subject: [PATCH 006/126] crypto: inside-secure - refrain from unneeded
+ invalidations
+
+The check to know if an invalidation is needed (i.e. when the context
+changes) is done even if the context does not exist yet. This happens
+when first setting a key for ciphers and/or hmac operations.
+
+This commits adds a check in the _setkey functions to only check if an
+invalidation is needed when a context exists, as there is no need to
+perform this check otherwise.
+
+Signed-off-by: Ofer Heifetz <oferh@marvell.com>
+[Antoine: commit message and added a comment and reworked one of the
+checks]
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ .../crypto/inside-secure/safexcel_cipher.c    | 10 ++++----
+ drivers/crypto/inside-secure/safexcel_hash.c  | 24 ++++++++++++-------
+ 2 files changed, 22 insertions(+), 12 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_cipher.c b/drivers/crypto/inside-secure/safexcel_cipher.c
+index 29cf7e00b574..6d8bc6a3fe5b 100644
+--- a/drivers/crypto/inside-secure/safexcel_cipher.c
++++ b/drivers/crypto/inside-secure/safexcel_cipher.c
+@@ -78,10 +78,12 @@ static int safexcel_aes_setkey(struct crypto_skcipher *ctfm, const u8 *key,
+ 		return ret;
+ 	}
+ 
+-	for (i = 0; i < len / sizeof(u32); i++) {
+-		if (ctx->key[i] != cpu_to_le32(aes.key_enc[i])) {
+-			ctx->base.needs_inv = true;
+-			break;
++	if (ctx->base.ctxr_dma) {
++		for (i = 0; i < len / sizeof(u32); i++) {
++			if (ctx->key[i] != cpu_to_le32(aes.key_enc[i])) {
++				ctx->base.needs_inv = true;
++				break;
++			}
+ 		}
+ 	}
+ 
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 8ed46ff4cbf9..955c242da244 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -535,10 +535,16 @@ static int safexcel_ahash_enqueue(struct ahash_request *areq)
+ 
+ 	req->needs_inv = false;
+ 
+-	if (req->processed && ctx->digest == CONTEXT_CONTROL_DIGEST_PRECOMPUTED)
+-		ctx->base.needs_inv = safexcel_ahash_needs_inv_get(areq);
+-
+ 	if (ctx->base.ctxr) {
++		if (!ctx->base.needs_inv && req->processed &&
++		    ctx->digest == CONTEXT_CONTROL_DIGEST_PRECOMPUTED)
++			/* We're still setting needs_inv here, even though it is
++			 * cleared right away, because the needs_inv flag can be
++			 * set in other functions and we want to keep the same
++			 * logic.
++			 */
++			ctx->base.needs_inv = safexcel_ahash_needs_inv_get(areq);
++
+ 		if (ctx->base.needs_inv) {
+ 			ctx->base.needs_inv = false;
+ 			req->needs_inv = true;
+@@ -936,11 +942,13 @@ static int safexcel_hmac_sha1_setkey(struct crypto_ahash *tfm, const u8 *key,
+ 	if (ret)
+ 		return ret;
+ 
+-	for (i = 0; i < SHA1_DIGEST_SIZE / sizeof(u32); i++) {
+-		if (ctx->ipad[i] != le32_to_cpu(istate.state[i]) ||
+-		    ctx->opad[i] != le32_to_cpu(ostate.state[i])) {
+-			ctx->base.needs_inv = true;
+-			break;
++	if (ctx->base.ctxr) {
++		for (i = 0; i < SHA1_DIGEST_SIZE / sizeof(u32); i++) {
++			if (ctx->ipad[i] != le32_to_cpu(istate.state[i]) ||
++			    ctx->opad[i] != le32_to_cpu(ostate.state[i])) {
++				ctx->base.needs_inv = true;
++				break;
++			}
+ 		}
+ 	}
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90007-crypto-inside-secure-EBUSY-is-not-an-error-on-async-.patch b/target/linux/mvebu/patches-4.14/90007-crypto-inside-secure-EBUSY-is-not-an-error-on-async-.patch
new file mode 100644
index 0000000..121f9de
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90007-crypto-inside-secure-EBUSY-is-not-an-error-on-async-.patch
@@ -0,0 +1,35 @@
+From f824118314de0dc82137ce531dc5fdcf4739e77d Mon Sep 17 00:00:00 2001
+From: Ofer Heifetz <oferh@marvell.com>
+Date: Thu, 14 Dec 2017 15:26:48 +0100
+Subject: [PATCH 007/126] crypto: inside-secure - EBUSY is not an error on
+ async request
+
+When initializing the IVs crypto_ahash_update() is called, which at some
+point will call crypto_enqueue_request(). This function can return
+-EBUSY when no resource is available and the request is queued. Since
+this is a valid case, -EBUSY shouldn't be treated as an error.
+
+Signed-off-by: Ofer Heifetz <oferh@marvell.com>
+[Antoine: commit message]
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 955c242da244..f32985e56668 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -870,7 +870,7 @@ static int safexcel_hmac_init_iv(struct ahash_request *areq,
+ 	req->last_req = true;
+ 
+ 	ret = crypto_ahash_update(areq);
+-	if (ret && ret != -EINPROGRESS)
++	if (ret && ret != -EINPROGRESS && ret != -EBUSY)
+ 		return ret;
+ 
+ 	wait_for_completion_interruptible(&result.completion);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90008-crypto-inside-secure-move-cipher-crypto-mode-to-requ.patch b/target/linux/mvebu/patches-4.14/90008-crypto-inside-secure-move-cipher-crypto-mode-to-requ.patch
new file mode 100644
index 0000000..5a45ff5
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90008-crypto-inside-secure-move-cipher-crypto-mode-to-requ.patch
@@ -0,0 +1,76 @@
+From a89a2c002de40ab39933cd559e10c74b4b8dc087 Mon Sep 17 00:00:00 2001
+From: Ofer Heifetz <oferh@marvell.com>
+Date: Thu, 14 Dec 2017 15:26:49 +0100
+Subject: [PATCH 008/126] crypto: inside-secure - move cipher crypto mode to
+ request context
+
+The cipher direction can be different for requests within the same
+transformation context. This patch moves the direction flag from the
+context to the request scope.
+
+Signed-off-by: Ofer Heifetz <oferh@marvell.com>
+[Antoine: commit message]
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_cipher.c | 11 +++++++----
+ 1 file changed, 7 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_cipher.c b/drivers/crypto/inside-secure/safexcel_cipher.c
+index 6d8bc6a3fe5b..5af0c890646d 100644
+--- a/drivers/crypto/inside-secure/safexcel_cipher.c
++++ b/drivers/crypto/inside-secure/safexcel_cipher.c
+@@ -27,7 +27,6 @@ struct safexcel_cipher_ctx {
+ 	struct safexcel_context base;
+ 	struct safexcel_crypto_priv *priv;
+ 
+-	enum safexcel_cipher_direction direction;
+ 	u32 mode;
+ 
+ 	__le32 key[8];
+@@ -35,6 +34,7 @@ struct safexcel_cipher_ctx {
+ };
+ 
+ struct safexcel_cipher_req {
++	enum safexcel_cipher_direction direction;
+ 	bool needs_inv;
+ };
+ 
+@@ -97,12 +97,15 @@ static int safexcel_aes_setkey(struct crypto_skcipher *ctfm, const u8 *key,
+ }
+ 
+ static int safexcel_context_control(struct safexcel_cipher_ctx *ctx,
++				    struct crypto_async_request *async,
+ 				    struct safexcel_command_desc *cdesc)
+ {
+ 	struct safexcel_crypto_priv *priv = ctx->priv;
++	struct skcipher_request *req = skcipher_request_cast(async);
++	struct safexcel_cipher_req *sreq = skcipher_request_ctx(req);
+ 	int ctrl_size;
+ 
+-	if (ctx->direction == SAFEXCEL_ENCRYPT)
++	if (sreq->direction == SAFEXCEL_ENCRYPT)
+ 		cdesc->control_data.control0 |= CONTEXT_CONTROL_TYPE_CRYPTO_OUT;
+ 	else
+ 		cdesc->control_data.control0 |= CONTEXT_CONTROL_TYPE_CRYPTO_IN;
+@@ -245,7 +248,7 @@ static int safexcel_aes_send(struct crypto_async_request *async,
+ 		n_cdesc++;
+ 
+ 		if (n_cdesc == 1) {
+-			safexcel_context_control(ctx, cdesc);
++			safexcel_context_control(ctx, async, cdesc);
+ 			safexcel_cipher_token(ctx, async, cdesc, req->cryptlen);
+ 		}
+ 
+@@ -469,7 +472,7 @@ static int safexcel_aes(struct skcipher_request *req,
+ 	int ret, ring;
+ 
+ 	sreq->needs_inv = false;
+-	ctx->direction = dir;
++	sreq->direction = dir;
+ 	ctx->mode = mode;
+ 
+ 	if (ctx->base.ctxr) {
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90009-crypto-inside-secure-remove-unused-parameter-in-inva.patch b/target/linux/mvebu/patches-4.14/90009-crypto-inside-secure-remove-unused-parameter-in-inva.patch
new file mode 100644
index 0000000..a261183
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90009-crypto-inside-secure-remove-unused-parameter-in-inva.patch
@@ -0,0 +1,74 @@
+From 77e5f1e1abb7deac33a6edd8018e0c97531ae8bf Mon Sep 17 00:00:00 2001
+From: Ofer Heifetz <oferh@marvell.com>
+Date: Thu, 14 Dec 2017 15:26:50 +0100
+Subject: [PATCH 009/126] crypto: inside-secure - remove unused parameter in
+ invalidate_cache
+
+The SafeXcel context isn't used in the cache invalidation function. This
+cosmetic patch removes it (as well as from the function prototype in the
+header file and when the function is called).
+
+Signed-off-by: Ofer Heifetz <oferh@marvell.com>
+[Antoine: commit message]
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c        | 1 -
+ drivers/crypto/inside-secure/safexcel.h        | 1 -
+ drivers/crypto/inside-secure/safexcel_cipher.c | 2 +-
+ drivers/crypto/inside-secure/safexcel_hash.c   | 2 +-
+ 4 files changed, 2 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index 3ee68ecde9ec..daeefef76f11 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -549,7 +549,6 @@ void safexcel_inv_complete(struct crypto_async_request *req, int error)
+ }
+ 
+ int safexcel_invalidate_cache(struct crypto_async_request *async,
+-			      struct safexcel_context *ctx,
+ 			      struct safexcel_crypto_priv *priv,
+ 			      dma_addr_t ctxr_dma, int ring,
+ 			      struct safexcel_request *request)
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 304c5838c11a..d12c2b479a5e 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -539,7 +539,6 @@ void safexcel_free_context(struct safexcel_crypto_priv *priv,
+ 				  struct crypto_async_request *req,
+ 				  int result_sz);
+ int safexcel_invalidate_cache(struct crypto_async_request *async,
+-			      struct safexcel_context *ctx,
+ 			      struct safexcel_crypto_priv *priv,
+ 			      dma_addr_t ctxr_dma, int ring,
+ 			      struct safexcel_request *request);
+diff --git a/drivers/crypto/inside-secure/safexcel_cipher.c b/drivers/crypto/inside-secure/safexcel_cipher.c
+index 5af0c890646d..f5ffae2808a8 100644
+--- a/drivers/crypto/inside-secure/safexcel_cipher.c
++++ b/drivers/crypto/inside-secure/safexcel_cipher.c
+@@ -395,7 +395,7 @@ static int safexcel_cipher_send_inv(struct crypto_async_request *async,
+ 	struct safexcel_crypto_priv *priv = ctx->priv;
+ 	int ret;
+ 
+-	ret = safexcel_invalidate_cache(async, &ctx->base, priv,
++	ret = safexcel_invalidate_cache(async, priv,
+ 					ctx->base.ctxr_dma, ring, request);
+ 	if (unlikely(ret))
+ 		return ret;
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index f32985e56668..328ce02ac050 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -435,7 +435,7 @@ static int safexcel_ahash_send_inv(struct crypto_async_request *async,
+ 	struct safexcel_ahash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(areq));
+ 	int ret;
+ 
+-	ret = safexcel_invalidate_cache(async, &ctx->base, ctx->priv,
++	ret = safexcel_invalidate_cache(async, ctx->priv,
+ 					ctx->base.ctxr_dma, ring, request);
+ 	if (unlikely(ret))
+ 		return ret;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90010-crypto-inside-secure-move-request-dequeueing-into-a-.patch b/target/linux/mvebu/patches-4.14/90010-crypto-inside-secure-move-request-dequeueing-into-a-.patch
new file mode 100644
index 0000000..70ad9ff
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90010-crypto-inside-secure-move-request-dequeueing-into-a-.patch
@@ -0,0 +1,204 @@
+From 5caa241a3f690a1aed65cc66386691dbd7ab6591 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:51 +0100
+Subject: [PATCH 010/126] crypto: inside-secure - move request dequeueing into
+ a workqueue
+
+This patch moves the request dequeueing into a workqueue to improve the
+coalescing of interrupts when sending requests to the engine; as the
+engine is capable of having one single interrupt for n requests sent.
+Using a workqueue allows to send more request at once.
+
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c       | 29 ++++++++++---------
+ drivers/crypto/inside-secure/safexcel.h       |  2 +-
+ .../crypto/inside-secure/safexcel_cipher.c    | 12 ++++----
+ drivers/crypto/inside-secure/safexcel_hash.c  | 12 ++++----
+ 4 files changed, 29 insertions(+), 26 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index daeefef76f11..9043ab8c98cb 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -429,8 +429,6 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 	struct safexcel_request *request;
+ 	int ret, nreq = 0, cdesc = 0, rdesc = 0, commands, results;
+ 
+-	priv->ring[ring].need_dequeue = false;
+-
+ 	do {
+ 		spin_lock_bh(&priv->ring[ring].queue_lock);
+ 		backlog = crypto_get_backlog(&priv->ring[ring].queue);
+@@ -445,8 +443,6 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 			spin_lock_bh(&priv->ring[ring].queue_lock);
+ 			crypto_enqueue_request(&priv->ring[ring].queue, req);
+ 			spin_unlock_bh(&priv->ring[ring].queue_lock);
+-
+-			priv->ring[ring].need_dequeue = true;
+ 			goto finalize;
+ 		}
+ 
+@@ -455,7 +451,6 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 		if (ret) {
+ 			kfree(request);
+ 			req->complete(req, ret);
+-			priv->ring[ring].need_dequeue = true;
+ 			goto finalize;
+ 		}
+ 
+@@ -480,9 +475,7 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 	} while (nreq++ < EIP197_MAX_BATCH_SZ);
+ 
+ finalize:
+-	if (nreq == EIP197_MAX_BATCH_SZ)
+-		priv->ring[ring].need_dequeue = true;
+-	else if (!nreq)
++	if (!nreq)
+ 		return;
+ 
+ 	spin_lock_bh(&priv->ring[ring].lock);
+@@ -637,13 +630,18 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ static void safexcel_handle_result_work(struct work_struct *work)
+ {
+ 	struct safexcel_work_data *data =
+-			container_of(work, struct safexcel_work_data, work);
++			container_of(work, struct safexcel_work_data, result_work);
+ 	struct safexcel_crypto_priv *priv = data->priv;
+ 
+ 	safexcel_handle_result_descriptor(priv, data->ring);
++}
++
++static void safexcel_dequeue_work(struct work_struct *work)
++{
++	struct safexcel_work_data *data =
++			container_of(work, struct safexcel_work_data, work);
+ 
+-	if (priv->ring[data->ring].need_dequeue)
+-		safexcel_dequeue(data->priv, data->ring);
++	safexcel_dequeue(data->priv, data->ring);
+ }
+ 
+ struct safexcel_ring_irq_data {
+@@ -674,7 +672,10 @@ static irqreturn_t safexcel_irq_ring(int irq, void *data)
+ 			 */
+ 			dev_err(priv->dev, "RDR: fatal error.");
+ 		} else if (likely(stat & EIP197_xDR_THRESH)) {
+-			queue_work(priv->ring[ring].workqueue, &priv->ring[ring].work_data.work);
++			queue_work(priv->ring[ring].workqueue,
++				   &priv->ring[ring].work_data.result_work);
++			queue_work(priv->ring[ring].workqueue,
++				   &priv->ring[ring].work_data.work);
+ 		}
+ 
+ 		/* ACK the interrupts */
+@@ -855,7 +856,9 @@ static int safexcel_probe(struct platform_device *pdev)
+ 
+ 		priv->ring[i].work_data.priv = priv;
+ 		priv->ring[i].work_data.ring = i;
+-		INIT_WORK(&priv->ring[i].work_data.work, safexcel_handle_result_work);
++		INIT_WORK(&priv->ring[i].work_data.result_work,
++			  safexcel_handle_result_work);
++		INIT_WORK(&priv->ring[i].work_data.work, safexcel_dequeue_work);
+ 
+ 		snprintf(wq_name, 9, "wq_ring%d", i);
+ 		priv->ring[i].workqueue = create_singlethread_workqueue(wq_name);
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index d12c2b479a5e..8e9c65183439 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -459,6 +459,7 @@ struct safexcel_config {
+ 
+ struct safexcel_work_data {
+ 	struct work_struct work;
++	struct work_struct result_work;
+ 	struct safexcel_crypto_priv *priv;
+ 	int ring;
+ };
+@@ -489,7 +490,6 @@ struct safexcel_crypto_priv {
+ 		/* queue */
+ 		struct crypto_queue queue;
+ 		spinlock_t queue_lock;
+-		bool need_dequeue;
+ 	} ring[EIP197_MAX_RINGS];
+ };
+ 
+diff --git a/drivers/crypto/inside-secure/safexcel_cipher.c b/drivers/crypto/inside-secure/safexcel_cipher.c
+index f5ffae2808a8..7c9a2d87135b 100644
+--- a/drivers/crypto/inside-secure/safexcel_cipher.c
++++ b/drivers/crypto/inside-secure/safexcel_cipher.c
+@@ -358,8 +358,8 @@ static int safexcel_handle_inv_result(struct safexcel_crypto_priv *priv,
+ 	if (enq_ret != -EINPROGRESS)
+ 		*ret = enq_ret;
+ 
+-	if (!priv->ring[ring].need_dequeue)
+-		safexcel_dequeue(priv, ring);
++	queue_work(priv->ring[ring].workqueue,
++		   &priv->ring[ring].work_data.work);
+ 
+ 	*should_complete = false;
+ 
+@@ -448,8 +448,8 @@ static int safexcel_cipher_exit_inv(struct crypto_tfm *tfm)
+ 	crypto_enqueue_request(&priv->ring[ring].queue, &req->base);
+ 	spin_unlock_bh(&priv->ring[ring].queue_lock);
+ 
+-	if (!priv->ring[ring].need_dequeue)
+-		safexcel_dequeue(priv, ring);
++	queue_work(priv->ring[ring].workqueue,
++		   &priv->ring[ring].work_data.work);
+ 
+ 	wait_for_completion(&result.completion);
+ 
+@@ -495,8 +495,8 @@ static int safexcel_aes(struct skcipher_request *req,
+ 	ret = crypto_enqueue_request(&priv->ring[ring].queue, &req->base);
+ 	spin_unlock_bh(&priv->ring[ring].queue_lock);
+ 
+-	if (!priv->ring[ring].need_dequeue)
+-		safexcel_dequeue(priv, ring);
++	queue_work(priv->ring[ring].workqueue,
++		   &priv->ring[ring].work_data.work);
+ 
+ 	return ret;
+ }
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 328ce02ac050..6912c032200b 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -399,8 +399,8 @@ static int safexcel_handle_inv_result(struct safexcel_crypto_priv *priv,
+ 	if (enq_ret != -EINPROGRESS)
+ 		*ret = enq_ret;
+ 
+-	if (!priv->ring[ring].need_dequeue)
+-		safexcel_dequeue(priv, ring);
++	queue_work(priv->ring[ring].workqueue,
++		   &priv->ring[ring].work_data.work);
+ 
+ 	*should_complete = false;
+ 
+@@ -488,8 +488,8 @@ static int safexcel_ahash_exit_inv(struct crypto_tfm *tfm)
+ 	crypto_enqueue_request(&priv->ring[ring].queue, &req->base);
+ 	spin_unlock_bh(&priv->ring[ring].queue_lock);
+ 
+-	if (!priv->ring[ring].need_dequeue)
+-		safexcel_dequeue(priv, ring);
++	queue_work(priv->ring[ring].workqueue,
++		   &priv->ring[ring].work_data.work);
+ 
+ 	wait_for_completion(&result.completion);
+ 
+@@ -564,8 +564,8 @@ static int safexcel_ahash_enqueue(struct ahash_request *areq)
+ 	ret = crypto_enqueue_request(&priv->ring[ring].queue, &areq->base);
+ 	spin_unlock_bh(&priv->ring[ring].queue_lock);
+ 
+-	if (!priv->ring[ring].need_dequeue)
+-		safexcel_dequeue(priv, ring);
++	queue_work(priv->ring[ring].workqueue,
++		   &priv->ring[ring].work_data.work);
+ 
+ 	return ret;
+ }
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90011-crypto-inside-secure-use-threaded-IRQs-for-result-ha.patch b/target/linux/mvebu/patches-4.14/90011-crypto-inside-secure-use-threaded-IRQs-for-result-ha.patch
new file mode 100644
index 0000000..d436acb
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90011-crypto-inside-secure-use-threaded-IRQs-for-result-ha.patch
@@ -0,0 +1,136 @@
+From 4680010064da542a862cdd5fd80ead909756afa9 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:52 +0100
+Subject: [PATCH 011/126] crypto: inside-secure - use threaded IRQs for result
+ handling
+
+This patch moves the result handling from an IRQ handler to a threaded
+IRQ handler, to improve the number of complete requests being handled at
+once.
+
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 41 +++++++++++++------------
+ drivers/crypto/inside-secure/safexcel.h |  1 -
+ 2 files changed, 22 insertions(+), 20 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index 9043ab8c98cb..4931d21f63f7 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -627,15 +627,6 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ 	}
+ }
+ 
+-static void safexcel_handle_result_work(struct work_struct *work)
+-{
+-	struct safexcel_work_data *data =
+-			container_of(work, struct safexcel_work_data, result_work);
+-	struct safexcel_crypto_priv *priv = data->priv;
+-
+-	safexcel_handle_result_descriptor(priv, data->ring);
+-}
+-
+ static void safexcel_dequeue_work(struct work_struct *work)
+ {
+ 	struct safexcel_work_data *data =
+@@ -653,12 +644,12 @@ static irqreturn_t safexcel_irq_ring(int irq, void *data)
+ {
+ 	struct safexcel_ring_irq_data *irq_data = data;
+ 	struct safexcel_crypto_priv *priv = irq_data->priv;
+-	int ring = irq_data->ring;
++	int ring = irq_data->ring, rc = IRQ_NONE;
+ 	u32 status, stat;
+ 
+ 	status = readl(priv->base + EIP197_HIA_AIC_R_ENABLED_STAT(ring));
+ 	if (!status)
+-		return IRQ_NONE;
++		return rc;
+ 
+ 	/* RDR interrupts */
+ 	if (status & EIP197_RDR_IRQ(ring)) {
+@@ -672,10 +663,7 @@ static irqreturn_t safexcel_irq_ring(int irq, void *data)
+ 			 */
+ 			dev_err(priv->dev, "RDR: fatal error.");
+ 		} else if (likely(stat & EIP197_xDR_THRESH)) {
+-			queue_work(priv->ring[ring].workqueue,
+-				   &priv->ring[ring].work_data.result_work);
+-			queue_work(priv->ring[ring].workqueue,
+-				   &priv->ring[ring].work_data.work);
++			rc = IRQ_WAKE_THREAD;
+ 		}
+ 
+ 		/* ACK the interrupts */
+@@ -686,11 +674,26 @@ static irqreturn_t safexcel_irq_ring(int irq, void *data)
+ 	/* ACK the interrupts */
+ 	writel(status, priv->base + EIP197_HIA_AIC_R_ACK(ring));
+ 
++	return rc;
++}
++
++static irqreturn_t safexcel_irq_ring_thread(int irq, void *data)
++{
++	struct safexcel_ring_irq_data *irq_data = data;
++	struct safexcel_crypto_priv *priv = irq_data->priv;
++	int ring = irq_data->ring;
++
++	safexcel_handle_result_descriptor(priv, ring);
++
++	queue_work(priv->ring[ring].workqueue,
++		   &priv->ring[ring].work_data.work);
++
+ 	return IRQ_HANDLED;
+ }
+ 
+ static int safexcel_request_ring_irq(struct platform_device *pdev, const char *name,
+ 				     irq_handler_t handler,
++				     irq_handler_t threaded_handler,
+ 				     struct safexcel_ring_irq_data *ring_irq_priv)
+ {
+ 	int ret, irq = platform_get_irq_byname(pdev, name);
+@@ -700,8 +703,9 @@ static int safexcel_request_ring_irq(struct platform_device *pdev, const char *n
+ 		return irq;
+ 	}
+ 
+-	ret = devm_request_irq(&pdev->dev, irq, handler, 0,
+-			       dev_name(&pdev->dev), ring_irq_priv);
++	ret = devm_request_threaded_irq(&pdev->dev, irq, handler,
++					threaded_handler, IRQF_ONESHOT,
++					dev_name(&pdev->dev), ring_irq_priv);
+ 	if (ret) {
+ 		dev_err(&pdev->dev, "unable to request IRQ %d\n", irq);
+ 		return ret;
+@@ -848,6 +852,7 @@ static int safexcel_probe(struct platform_device *pdev)
+ 
+ 		snprintf(irq_name, 6, "ring%d", i);
+ 		irq = safexcel_request_ring_irq(pdev, irq_name, safexcel_irq_ring,
++						safexcel_irq_ring_thread,
+ 						ring_irq);
+ 		if (irq < 0) {
+ 			ret = irq;
+@@ -856,8 +861,6 @@ static int safexcel_probe(struct platform_device *pdev)
+ 
+ 		priv->ring[i].work_data.priv = priv;
+ 		priv->ring[i].work_data.ring = i;
+-		INIT_WORK(&priv->ring[i].work_data.result_work,
+-			  safexcel_handle_result_work);
+ 		INIT_WORK(&priv->ring[i].work_data.work, safexcel_dequeue_work);
+ 
+ 		snprintf(wq_name, 9, "wq_ring%d", i);
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 8e9c65183439..fffddefb0d9b 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -459,7 +459,6 @@ struct safexcel_config {
+ 
+ struct safexcel_work_data {
+ 	struct work_struct work;
+-	struct work_struct result_work;
+ 	struct safexcel_crypto_priv *priv;
+ 	int ring;
+ };
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90012-crypto-inside-secure-dequeue-all-requests-at-once.patch b/target/linux/mvebu/patches-4.14/90012-crypto-inside-secure-dequeue-all-requests-at-once.patch
new file mode 100644
index 0000000..45b98da
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90012-crypto-inside-secure-dequeue-all-requests-at-once.patch
@@ -0,0 +1,179 @@
+From bbf1ff250ef8969b2d1cec851f3972ec3d4be91e Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:53 +0100
+Subject: [PATCH 012/126] crypto: inside-secure - dequeue all requests at once
+
+This patch updates the dequeueing logic to dequeue all requests at once.
+Since we can have many requests in the queue, the interrupt coalescing
+is kept so that the ring interrupt fires every EIP197_MAX_BATCH_SZ at
+most.
+
+To allow dequeueing all requests at once while still using reasonable
+settings for the interrupt coalescing, the result handling function was
+updated to setup the threshold interrupt when needed (i.e. when more
+requests than EIP197_MAX_BATCH_SZ are in the queue). When using this
+capability the ring is marked as busy so that the dequeue function
+enqueue new requests without setting the threshold interrupt.
+
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 60 ++++++++++++++++++++-----
+ drivers/crypto/inside-secure/safexcel.h |  8 ++++
+ 2 files changed, 56 insertions(+), 12 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index 4931d21f63f7..2b32ca5eafbd 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -422,6 +422,23 @@ static int safexcel_hw_init(struct safexcel_crypto_priv *priv)
+ 	return 0;
+ }
+ 
++/* Called with ring's lock taken */
++int safexcel_try_push_requests(struct safexcel_crypto_priv *priv, int ring,
++			       int reqs)
++{
++	int coal = min_t(int, reqs, EIP197_MAX_BATCH_SZ);
++
++	if (!coal)
++		return 0;
++
++	/* Configure when we want an interrupt */
++	writel(EIP197_HIA_RDR_THRESH_PKT_MODE |
++	       EIP197_HIA_RDR_THRESH_PROC_PKT(coal),
++	       priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_THRESH);
++
++	return coal;
++}
++
+ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ {
+ 	struct crypto_async_request *req, *backlog;
+@@ -429,7 +446,7 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 	struct safexcel_request *request;
+ 	int ret, nreq = 0, cdesc = 0, rdesc = 0, commands, results;
+ 
+-	do {
++	while (true) {
+ 		spin_lock_bh(&priv->ring[ring].queue_lock);
+ 		backlog = crypto_get_backlog(&priv->ring[ring].queue);
+ 		req = crypto_dequeue_request(&priv->ring[ring].queue);
+@@ -472,18 +489,24 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 
+ 		cdesc += commands;
+ 		rdesc += results;
+-	} while (nreq++ < EIP197_MAX_BATCH_SZ);
++		nreq++;
++	}
+ 
+ finalize:
+ 	if (!nreq)
+ 		return;
+ 
+-	spin_lock_bh(&priv->ring[ring].lock);
++	spin_lock_bh(&priv->ring[ring].egress_lock);
+ 
+-	/* Configure when we want an interrupt */
+-	writel(EIP197_HIA_RDR_THRESH_PKT_MODE |
+-	       EIP197_HIA_RDR_THRESH_PROC_PKT(nreq),
+-	       priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_THRESH);
++	if (!priv->ring[ring].busy) {
++		nreq -= safexcel_try_push_requests(priv, ring, nreq);
++		if (nreq)
++			priv->ring[ring].busy = true;
++	}
++
++	priv->ring[ring].requests_left += nreq;
++
++	spin_unlock_bh(&priv->ring[ring].egress_lock);
+ 
+ 	/* let the RDR know we have pending descriptors */
+ 	writel((rdesc * priv->config.rd_offset) << 2,
+@@ -492,8 +515,6 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 	/* let the CDR know we have pending descriptors */
+ 	writel((cdesc * priv->config.cd_offset) << 2,
+ 	       priv->base + EIP197_HIA_CDR(ring) + EIP197_HIA_xDR_PREP_COUNT);
+-
+-	spin_unlock_bh(&priv->ring[ring].lock);
+ }
+ 
+ void safexcel_free_context(struct safexcel_crypto_priv *priv,
+@@ -588,14 +609,14 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ {
+ 	struct safexcel_request *sreq;
+ 	struct safexcel_context *ctx;
+-	int ret, i, nreq, ndesc = 0;
++	int ret, i, nreq, ndesc = 0, done;
+ 	bool should_complete;
+ 
+ 	nreq = readl(priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_PROC_COUNT);
+ 	nreq >>= 24;
+ 	nreq &= GENMASK(6, 0);
+ 	if (!nreq)
+-		return;
++		goto requests_left;
+ 
+ 	for (i = 0; i < nreq; i++) {
+ 		spin_lock_bh(&priv->ring[ring].egress_lock);
+@@ -610,7 +631,7 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ 		if (ndesc < 0) {
+ 			kfree(sreq);
+ 			dev_err(priv->dev, "failed to handle result (%d)", ndesc);
+-			return;
++			goto requests_left;
+ 		}
+ 
+ 		writel(EIP197_xDR_PROC_xD_PKT(1) |
+@@ -625,6 +646,18 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ 
+ 		kfree(sreq);
+ 	}
++
++requests_left:
++	spin_lock_bh(&priv->ring[ring].egress_lock);
++
++	done = safexcel_try_push_requests(priv, ring,
++					  priv->ring[ring].requests_left);
++
++	priv->ring[ring].requests_left -= done;
++	if (!done && !priv->ring[ring].requests_left)
++		priv->ring[ring].busy = false;
++
++	spin_unlock_bh(&priv->ring[ring].egress_lock);
+ }
+ 
+ static void safexcel_dequeue_work(struct work_struct *work)
+@@ -870,6 +903,9 @@ static int safexcel_probe(struct platform_device *pdev)
+ 			goto err_clk;
+ 		}
+ 
++		priv->ring[i].requests_left = 0;
++		priv->ring[i].busy = false;
++
+ 		crypto_init_queue(&priv->ring[i].queue,
+ 				  EIP197_DEFAULT_RING_SIZE);
+ 
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index fffddefb0d9b..531e3e9d8384 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -489,6 +489,14 @@ struct safexcel_crypto_priv {
+ 		/* queue */
+ 		struct crypto_queue queue;
+ 		spinlock_t queue_lock;
++
++		/* Number of requests in the engine that needs the threshold
++		 * interrupt to be set up.
++		 */
++		int requests_left;
++
++		/* The ring is currently handling at least one request */
++		bool busy;
+ 	} ring[EIP197_MAX_RINGS];
+ };
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90013-crypto-inside-secure-increase-the-ring-size.patch b/target/linux/mvebu/patches-4.14/90013-crypto-inside-secure-increase-the-ring-size.patch
new file mode 100644
index 0000000..c2ab1f2
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90013-crypto-inside-secure-increase-the-ring-size.patch
@@ -0,0 +1,37 @@
+From 11cdfe43fdb19cfa29f48529a9f005b678651fe5 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:54 +0100
+Subject: [PATCH 013/126] crypto: inside-secure - increase the ring size
+
+Increase the ring size to handle more requests in parallel, while
+keeping the batch size (for interrupt coalescing) to its previous value.
+The ring size and batch size are now unlinked.
+
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.h | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 531e3e9d8384..2a0ab6ce716a 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -19,11 +19,11 @@
+ #define EIP197_HIA_VERSION_BE			0x35ca
+ 
+ /* Static configuration */
+-#define EIP197_DEFAULT_RING_SIZE		64
++#define EIP197_DEFAULT_RING_SIZE		400
+ #define EIP197_MAX_TOKENS			5
+ #define EIP197_MAX_RINGS			4
+ #define EIP197_FETCH_COUNT			1
+-#define EIP197_MAX_BATCH_SZ			EIP197_DEFAULT_RING_SIZE
++#define EIP197_MAX_BATCH_SZ			64
+ 
+ #define EIP197_GFP_FLAGS(base)	((base).flags & CRYPTO_TFM_REQ_MAY_SLEEP ? \
+ 				 GFP_KERNEL : GFP_ATOMIC)
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90014-crypto-inside-secure-acknowledge-the-result-requests.patch b/target/linux/mvebu/patches-4.14/90014-crypto-inside-secure-acknowledge-the-result-requests.patch
new file mode 100644
index 0000000..90ebdfb
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90014-crypto-inside-secure-acknowledge-the-result-requests.patch
@@ -0,0 +1,62 @@
+From 4b5dc615542a9bf66d8b66421afac873f4d1f82e Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:55 +0100
+Subject: [PATCH 014/126] crypto: inside-secure - acknowledge the result
+ requests all at once
+
+This patches moves the result request acknowledgment from a per request
+process to acknowledging all the result requests handled at once.
+
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 16 ++++++++++------
+ 1 file changed, 10 insertions(+), 6 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index 2b32ca5eafbd..af79bc751ad1 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -609,7 +609,7 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ {
+ 	struct safexcel_request *sreq;
+ 	struct safexcel_context *ctx;
+-	int ret, i, nreq, ndesc = 0, done;
++	int ret, i, nreq, ndesc = 0, tot_descs = 0, done;
+ 	bool should_complete;
+ 
+ 	nreq = readl(priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_PROC_COUNT);
+@@ -631,13 +631,9 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ 		if (ndesc < 0) {
+ 			kfree(sreq);
+ 			dev_err(priv->dev, "failed to handle result (%d)", ndesc);
+-			goto requests_left;
++			goto acknowledge;
+ 		}
+ 
+-		writel(EIP197_xDR_PROC_xD_PKT(1) |
+-		       EIP197_xDR_PROC_xD_COUNT(ndesc * priv->config.rd_offset),
+-		       priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_PROC_COUNT);
+-
+ 		if (should_complete) {
+ 			local_bh_disable();
+ 			sreq->req->complete(sreq->req, ret);
+@@ -645,6 +641,14 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ 		}
+ 
+ 		kfree(sreq);
++		tot_descs += ndesc;
++	}
++
++acknowledge:
++	if (i) {
++		writel(EIP197_xDR_PROC_xD_PKT(i) |
++		       EIP197_xDR_PROC_xD_COUNT(tot_descs * priv->config.rd_offset),
++		       priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_PROC_COUNT);
+ 	}
+ 
+ requests_left:
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90015-crypto-inside-secure-handle-more-result-requests-whe.patch b/target/linux/mvebu/patches-4.14/90015-crypto-inside-secure-handle-more-result-requests-whe.patch
new file mode 100644
index 0000000..c5b2a10
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90015-crypto-inside-secure-handle-more-result-requests-whe.patch
@@ -0,0 +1,70 @@
+From 1ec6f0340ffe77b29925952d8bc79ee3edba02c2 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:56 +0100
+Subject: [PATCH 015/126] crypto: inside-secure - handle more result requests
+ when counter is full
+
+This patch modifies the result handling logic to continue handling
+results when the completed requests counter is full and not showing the
+actual number of requests to handle.
+
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 15 ++++++++++++---
+ drivers/crypto/inside-secure/safexcel.h |  2 ++
+ 2 files changed, 14 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index af79bc751ad1..dec1925cf0ad 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -609,12 +609,15 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ {
+ 	struct safexcel_request *sreq;
+ 	struct safexcel_context *ctx;
+-	int ret, i, nreq, ndesc = 0, tot_descs = 0, done;
++	int ret, i, nreq, ndesc, tot_descs, done;
+ 	bool should_complete;
+ 
++handle_results:
++	tot_descs = 0;
++
+ 	nreq = readl(priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_PROC_COUNT);
+-	nreq >>= 24;
+-	nreq &= GENMASK(6, 0);
++	nreq >>= EIP197_xDR_PROC_xD_PKT_OFFSET;
++	nreq &= EIP197_xDR_PROC_xD_PKT_MASK;
+ 	if (!nreq)
+ 		goto requests_left;
+ 
+@@ -651,6 +654,12 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ 		       priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_PROC_COUNT);
+ 	}
+ 
++	/* If the number of requests overflowed the counter, try to proceed more
++	 * requests.
++	 */
++	if (nreq == EIP197_xDR_PROC_xD_PKT_MASK)
++		goto handle_results;
++
+ requests_left:
+ 	spin_lock_bh(&priv->ring[ring].egress_lock);
+ 
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 2a0ab6ce716a..0c47e792192d 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -117,6 +117,8 @@
+ #define EIP197_xDR_PREP_CLR_COUNT		BIT(31)
+ 
+ /* EIP197_HIA_xDR_PROC_COUNT */
++#define EIP197_xDR_PROC_xD_PKT_OFFSET		24
++#define EIP197_xDR_PROC_xD_PKT_MASK		GENMASK(6, 0)
+ #define EIP197_xDR_PROC_xD_COUNT(n)		((n) << 2)
+ #define EIP197_xDR_PROC_xD_PKT(n)		((n) << 24)
+ #define EIP197_xDR_PROC_CLR_COUNT		BIT(31)
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90016-crypto-inside-secure-retry-to-proceed-the-request-la.patch b/target/linux/mvebu/patches-4.14/90016-crypto-inside-secure-retry-to-proceed-the-request-la.patch
new file mode 100644
index 0000000..de3525c
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90016-crypto-inside-secure-retry-to-proceed-the-request-la.patch
@@ -0,0 +1,103 @@
+From 5177f64dae7f8f22f9501890b885ae5248e626e2 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:57 +0100
+Subject: [PATCH 016/126] crypto: inside-secure - retry to proceed the request
+ later on fail
+
+The dequeueing function was putting back a request in the crypto queue
+on failure (when not enough resources are available) which is not
+perfect as the request will be handled much later. This patch updates
+this logic by keeping a reference on the failed request to try
+proceeding it later when enough resources are available.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 32 ++++++++++++++++++-------
+ drivers/crypto/inside-secure/safexcel.h |  6 +++++
+ 2 files changed, 29 insertions(+), 9 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index dec1925cf0ad..0c0199a65337 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -446,29 +446,36 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 	struct safexcel_request *request;
+ 	int ret, nreq = 0, cdesc = 0, rdesc = 0, commands, results;
+ 
++	/* If a request wasn't properly dequeued because of a lack of resources,
++	 * proceeded it first,
++	 */
++	req = priv->ring[ring].req;
++	backlog = priv->ring[ring].backlog;
++	if (req)
++		goto handle_req;
++
+ 	while (true) {
+ 		spin_lock_bh(&priv->ring[ring].queue_lock);
+ 		backlog = crypto_get_backlog(&priv->ring[ring].queue);
+ 		req = crypto_dequeue_request(&priv->ring[ring].queue);
+ 		spin_unlock_bh(&priv->ring[ring].queue_lock);
+ 
+-		if (!req)
++		if (!req) {
++			priv->ring[ring].req = NULL;
++			priv->ring[ring].backlog = NULL;
+ 			goto finalize;
++		}
+ 
++handle_req:
+ 		request = kzalloc(sizeof(*request), EIP197_GFP_FLAGS(*req));
+-		if (!request) {
+-			spin_lock_bh(&priv->ring[ring].queue_lock);
+-			crypto_enqueue_request(&priv->ring[ring].queue, req);
+-			spin_unlock_bh(&priv->ring[ring].queue_lock);
+-			goto finalize;
+-		}
++		if (!request)
++			goto request_failed;
+ 
+ 		ctx = crypto_tfm_ctx(req->tfm);
+ 		ret = ctx->send(req, ring, request, &commands, &results);
+ 		if (ret) {
+ 			kfree(request);
+-			req->complete(req, ret);
+-			goto finalize;
++			goto request_failed;
+ 		}
+ 
+ 		if (backlog)
+@@ -492,6 +499,13 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 		nreq++;
+ 	}
+ 
++request_failed:
++	/* Not enough resources to handle all the requests. Bail out and save
++	 * the request and the backlog for the next dequeue call (per-ring).
++	 */
++	priv->ring[ring].req = req;
++	priv->ring[ring].backlog = backlog;
++
+ finalize:
+ 	if (!nreq)
+ 		return;
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 0c47e792192d..d4955abf873b 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -499,6 +499,12 @@ struct safexcel_crypto_priv {
+ 
+ 		/* The ring is currently handling at least one request */
+ 		bool busy;
++
++		/* Store for current requests when bailing out of the dequeueing
++		 * function when no enough resources are available.
++		 */
++		struct crypto_async_request *req;
++		struct crypto_async_request *backlog;
+ 	} ring[EIP197_MAX_RINGS];
+ };
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90017-crypto-inside-secure-EIP97-support.patch b/target/linux/mvebu/patches-4.14/90017-crypto-inside-secure-EIP97-support.patch
new file mode 100644
index 0000000..a53d487
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90017-crypto-inside-secure-EIP97-support.patch
@@ -0,0 +1,841 @@
+From a560994a9a76cdacb83bb07cb8e8480ce756db20 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Antoine=20T=C3=A9nart?= <antoine.tenart@free-electrons.com>
+Date: Thu, 14 Dec 2017 15:26:58 +0100
+Subject: [PATCH 017/126] crypto: inside-secure - EIP97 support
+
+The Inside Secure SafeXcel driver was firstly designed to support the
+EIP197 cryptographic engine which is an evolution (with much more
+feature, better performances) of the EIP97 cryptographic engine. This
+patch convert the Inside Secure SafeXcel driver to support both engines
+(EIP97 + EIP197).
+
+The main differences are the register offsets and the context
+invalidation process which is EIP197 specific. This patch adds an
+indirection on the register offsets and adds checks not to send any
+invalidation request when driving the EIP97. A new compatible is added
+as well to bind the driver from device trees.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c       | 212 +++++++++++-------
+ drivers/crypto/inside-secure/safexcel.h       | 151 +++++++++----
+ .../crypto/inside-secure/safexcel_cipher.c    |  20 +-
+ drivers/crypto/inside-secure/safexcel_hash.c  |  19 +-
+ 4 files changed, 264 insertions(+), 138 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index 0c0199a65337..b0787f5f62ad 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -108,10 +108,10 @@ static void eip197_write_firmware(struct safexcel_crypto_priv *priv,
+ 	writel(EIP197_PE_ICE_x_CTRL_SW_RESET |
+ 	       EIP197_PE_ICE_x_CTRL_CLR_ECC_CORR |
+ 	       EIP197_PE_ICE_x_CTRL_CLR_ECC_NON_CORR,
+-	       priv->base + ctrl);
++	       EIP197_PE(priv) + ctrl);
+ 
+ 	/* Enable access to the program memory */
+-	writel(prog_en, priv->base + EIP197_PE_ICE_RAM_CTRL);
++	writel(prog_en, EIP197_PE(priv) + EIP197_PE_ICE_RAM_CTRL);
+ 
+ 	/* Write the firmware */
+ 	for (i = 0; i < fw->size / sizeof(u32); i++)
+@@ -119,12 +119,12 @@ static void eip197_write_firmware(struct safexcel_crypto_priv *priv,
+ 		       priv->base + EIP197_CLASSIFICATION_RAMS + i * sizeof(u32));
+ 
+ 	/* Disable access to the program memory */
+-	writel(0, priv->base + EIP197_PE_ICE_RAM_CTRL);
++	writel(0, EIP197_PE(priv) + EIP197_PE_ICE_RAM_CTRL);
+ 
+ 	/* Release engine from reset */
+-	val = readl(priv->base + ctrl);
++	val = readl(EIP197_PE(priv) + ctrl);
+ 	val &= ~EIP197_PE_ICE_x_CTRL_SW_RESET;
+-	writel(val, priv->base + ctrl);
++	writel(val, EIP197_PE(priv) + ctrl);
+ }
+ 
+ static int eip197_load_firmwares(struct safexcel_crypto_priv *priv)
+@@ -145,14 +145,14 @@ static int eip197_load_firmwares(struct safexcel_crypto_priv *priv)
+ 	 }
+ 
+ 	/* Clear the scratchpad memory */
+-	val = readl(priv->base + EIP197_PE_ICE_SCRATCH_CTRL);
++	val = readl(EIP197_PE(priv) + EIP197_PE_ICE_SCRATCH_CTRL);
+ 	val |= EIP197_PE_ICE_SCRATCH_CTRL_CHANGE_TIMER |
+ 	       EIP197_PE_ICE_SCRATCH_CTRL_TIMER_EN |
+ 	       EIP197_PE_ICE_SCRATCH_CTRL_SCRATCH_ACCESS |
+ 	       EIP197_PE_ICE_SCRATCH_CTRL_CHANGE_ACCESS;
+-	writel(val, priv->base + EIP197_PE_ICE_SCRATCH_CTRL);
++	writel(val, EIP197_PE(priv) + EIP197_PE_ICE_SCRATCH_CTRL);
+ 
+-	memset(priv->base + EIP197_PE_ICE_SCRATCH_RAM, 0,
++	memset(EIP197_PE(priv) + EIP197_PE_ICE_SCRATCH_RAM, 0,
+ 	       EIP197_NUM_OF_SCRATCH_BLOCKS * sizeof(u32));
+ 
+ 	eip197_write_firmware(priv, fw[FW_IFPP], EIP197_PE_ICE_FPP_CTRL,
+@@ -173,7 +173,7 @@ static int safexcel_hw_setup_cdesc_rings(struct safexcel_crypto_priv *priv)
+ 	u32 hdw, cd_size_rnd, val;
+ 	int i;
+ 
+-	hdw = readl(priv->base + EIP197_HIA_OPTIONS);
++	hdw = readl(EIP197_HIA_AIC_G(priv) + EIP197_HIA_OPTIONS);
+ 	hdw &= GENMASK(27, 25);
+ 	hdw >>= 25;
+ 
+@@ -182,26 +182,25 @@ static int safexcel_hw_setup_cdesc_rings(struct safexcel_crypto_priv *priv)
+ 	for (i = 0; i < priv->config.rings; i++) {
+ 		/* ring base address */
+ 		writel(lower_32_bits(priv->ring[i].cdr.base_dma),
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_RING_BASE_ADDR_LO);
++		       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_RING_BASE_ADDR_LO);
+ 		writel(upper_32_bits(priv->ring[i].cdr.base_dma),
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_RING_BASE_ADDR_HI);
++		       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_RING_BASE_ADDR_HI);
+ 
+ 		writel(EIP197_xDR_DESC_MODE_64BIT | (priv->config.cd_offset << 16) |
+ 		       priv->config.cd_size,
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_DESC_SIZE);
++		       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_DESC_SIZE);
+ 		writel(((EIP197_FETCH_COUNT * (cd_size_rnd << hdw)) << 16) |
+ 		       (EIP197_FETCH_COUNT * priv->config.cd_offset),
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_CFG);
++		       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_CFG);
+ 
+ 		/* Configure DMA tx control */
+ 		val = EIP197_HIA_xDR_CFG_WR_CACHE(WR_CACHE_3BITS);
+ 		val |= EIP197_HIA_xDR_CFG_RD_CACHE(RD_CACHE_3BITS);
+-		writel(val,
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_DMA_CFG);
++		writel(val, EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_DMA_CFG);
+ 
+ 		/* clear any pending interrupt */
+ 		writel(GENMASK(5, 0),
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_STAT);
++		       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_STAT);
+ 	}
+ 
+ 	return 0;
+@@ -212,7 +211,7 @@ static int safexcel_hw_setup_rdesc_rings(struct safexcel_crypto_priv *priv)
+ 	u32 hdw, rd_size_rnd, val;
+ 	int i;
+ 
+-	hdw = readl(priv->base + EIP197_HIA_OPTIONS);
++	hdw = readl(EIP197_HIA_AIC_G(priv) + EIP197_HIA_OPTIONS);
+ 	hdw &= GENMASK(27, 25);
+ 	hdw >>= 25;
+ 
+@@ -221,33 +220,33 @@ static int safexcel_hw_setup_rdesc_rings(struct safexcel_crypto_priv *priv)
+ 	for (i = 0; i < priv->config.rings; i++) {
+ 		/* ring base address */
+ 		writel(lower_32_bits(priv->ring[i].rdr.base_dma),
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_RING_BASE_ADDR_LO);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_RING_BASE_ADDR_LO);
+ 		writel(upper_32_bits(priv->ring[i].rdr.base_dma),
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_RING_BASE_ADDR_HI);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_RING_BASE_ADDR_HI);
+ 
+ 		writel(EIP197_xDR_DESC_MODE_64BIT | (priv->config.rd_offset << 16) |
+ 		       priv->config.rd_size,
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_DESC_SIZE);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_DESC_SIZE);
+ 
+ 		writel(((EIP197_FETCH_COUNT * (rd_size_rnd << hdw)) << 16) |
+ 		       (EIP197_FETCH_COUNT * priv->config.rd_offset),
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_CFG);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_CFG);
+ 
+ 		/* Configure DMA tx control */
+ 		val = EIP197_HIA_xDR_CFG_WR_CACHE(WR_CACHE_3BITS);
+ 		val |= EIP197_HIA_xDR_CFG_RD_CACHE(RD_CACHE_3BITS);
+ 		val |= EIP197_HIA_xDR_WR_RES_BUF | EIP197_HIA_xDR_WR_CTRL_BUG;
+ 		writel(val,
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_DMA_CFG);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_DMA_CFG);
+ 
+ 		/* clear any pending interrupt */
+ 		writel(GENMASK(7, 0),
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_STAT);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_STAT);
+ 
+ 		/* enable ring interrupt */
+-		val = readl(priv->base + EIP197_HIA_AIC_R_ENABLE_CTRL(i));
++		val = readl(EIP197_HIA_AIC_R(priv) + EIP197_HIA_AIC_R_ENABLE_CTRL(i));
+ 		val |= EIP197_RDR_IRQ(i);
+-		writel(val, priv->base + EIP197_HIA_AIC_R_ENABLE_CTRL(i));
++		writel(val, EIP197_HIA_AIC_R(priv) + EIP197_HIA_AIC_R_ENABLE_CTRL(i));
+ 	}
+ 
+ 	return 0;
+@@ -259,39 +258,40 @@ static int safexcel_hw_init(struct safexcel_crypto_priv *priv)
+ 	int i, ret;
+ 
+ 	/* Determine endianess and configure byte swap */
+-	version = readl(priv->base + EIP197_HIA_VERSION);
+-	val = readl(priv->base + EIP197_HIA_MST_CTRL);
++	version = readl(EIP197_HIA_AIC(priv) + EIP197_HIA_VERSION);
++	val = readl(EIP197_HIA_AIC(priv) + EIP197_HIA_MST_CTRL);
+ 
+ 	if ((version & 0xffff) == EIP197_HIA_VERSION_BE)
+ 		val |= EIP197_MST_CTRL_BYTE_SWAP;
+ 	else if (((version >> 16) & 0xffff) == EIP197_HIA_VERSION_LE)
+ 		val |= (EIP197_MST_CTRL_NO_BYTE_SWAP >> 24);
+ 
+-	writel(val, priv->base + EIP197_HIA_MST_CTRL);
+-
++	writel(val, EIP197_HIA_AIC(priv) + EIP197_HIA_MST_CTRL);
+ 
+ 	/* Configure wr/rd cache values */
+ 	writel(EIP197_MST_CTRL_RD_CACHE(RD_CACHE_4BITS) |
+ 	       EIP197_MST_CTRL_WD_CACHE(WR_CACHE_4BITS),
+-	       priv->base + EIP197_MST_CTRL);
++	       EIP197_HIA_GEN_CFG(priv) + EIP197_MST_CTRL);
+ 
+ 	/* Interrupts reset */
+ 
+ 	/* Disable all global interrupts */
+-	writel(0, priv->base + EIP197_HIA_AIC_G_ENABLE_CTRL);
++	writel(0, EIP197_HIA_AIC_G(priv) + EIP197_HIA_AIC_G_ENABLE_CTRL);
+ 
+ 	/* Clear any pending interrupt */
+-	writel(GENMASK(31, 0), priv->base + EIP197_HIA_AIC_G_ACK);
++	writel(GENMASK(31, 0), EIP197_HIA_AIC_G(priv) + EIP197_HIA_AIC_G_ACK);
+ 
+ 	/* Data Fetch Engine configuration */
+ 
+ 	/* Reset all DFE threads */
+ 	writel(EIP197_DxE_THR_CTRL_RESET_PE,
+-	       priv->base + EIP197_HIA_DFE_THR_CTRL);
++	       EIP197_HIA_DFE_THR(priv) + EIP197_HIA_DFE_THR_CTRL);
+ 
+-	/* Reset HIA input interface arbiter */
+-	writel(EIP197_HIA_RA_PE_CTRL_RESET,
+-	       priv->base + EIP197_HIA_RA_PE_CTRL);
++	if (priv->version == EIP197) {
++		/* Reset HIA input interface arbiter */
++		writel(EIP197_HIA_RA_PE_CTRL_RESET,
++		       EIP197_HIA_AIC(priv) + EIP197_HIA_RA_PE_CTRL);
++	}
+ 
+ 	/* DMA transfer size to use */
+ 	val = EIP197_HIA_DFE_CFG_DIS_DEBUG;
+@@ -299,29 +299,32 @@ static int safexcel_hw_init(struct safexcel_crypto_priv *priv)
+ 	val |= EIP197_HIA_DxE_CFG_MIN_CTRL_SIZE(5) | EIP197_HIA_DxE_CFG_MAX_CTRL_SIZE(7);
+ 	val |= EIP197_HIA_DxE_CFG_DATA_CACHE_CTRL(RD_CACHE_3BITS);
+ 	val |= EIP197_HIA_DxE_CFG_CTRL_CACHE_CTRL(RD_CACHE_3BITS);
+-	writel(val, priv->base + EIP197_HIA_DFE_CFG);
++	writel(val, EIP197_HIA_DFE(priv) + EIP197_HIA_DFE_CFG);
+ 
+ 	/* Leave the DFE threads reset state */
+-	writel(0, priv->base + EIP197_HIA_DFE_THR_CTRL);
++	writel(0, EIP197_HIA_DFE_THR(priv) + EIP197_HIA_DFE_THR_CTRL);
+ 
+ 	/* Configure the procesing engine thresholds */
+ 	writel(EIP197_PE_IN_xBUF_THRES_MIN(5) | EIP197_PE_IN_xBUF_THRES_MAX(9),
+-	      priv->base + EIP197_PE_IN_DBUF_THRES);
++	       EIP197_PE(priv) + EIP197_PE_IN_DBUF_THRES);
+ 	writel(EIP197_PE_IN_xBUF_THRES_MIN(5) | EIP197_PE_IN_xBUF_THRES_MAX(7),
+-	      priv->base + EIP197_PE_IN_TBUF_THRES);
++	       EIP197_PE(priv) + EIP197_PE_IN_TBUF_THRES);
+ 
+-	/* enable HIA input interface arbiter and rings */
+-	writel(EIP197_HIA_RA_PE_CTRL_EN | GENMASK(priv->config.rings - 1, 0),
+-	       priv->base + EIP197_HIA_RA_PE_CTRL);
++	if (priv->version == EIP197) {
++		/* enable HIA input interface arbiter and rings */
++		writel(EIP197_HIA_RA_PE_CTRL_EN |
++		       GENMASK(priv->config.rings - 1, 0),
++		       EIP197_HIA_AIC(priv) + EIP197_HIA_RA_PE_CTRL);
++	}
+ 
+ 	/* Data Store Engine configuration */
+ 
+ 	/* Reset all DSE threads */
+ 	writel(EIP197_DxE_THR_CTRL_RESET_PE,
+-	       priv->base + EIP197_HIA_DSE_THR_CTRL);
++	       EIP197_HIA_DSE_THR(priv) + EIP197_HIA_DSE_THR_CTRL);
+ 
+ 	/* Wait for all DSE threads to complete */
+-	while ((readl(priv->base + EIP197_HIA_DSE_THR_STAT) &
++	while ((readl(EIP197_HIA_DSE_THR(priv) + EIP197_HIA_DSE_THR_STAT) &
+ 		GENMASK(15, 12)) != GENMASK(15, 12))
+ 		;
+ 
+@@ -330,15 +333,19 @@ static int safexcel_hw_init(struct safexcel_crypto_priv *priv)
+ 	val |= EIP197_HIA_DxE_CFG_MIN_DATA_SIZE(7) | EIP197_HIA_DxE_CFG_MAX_DATA_SIZE(8);
+ 	val |= EIP197_HIA_DxE_CFG_DATA_CACHE_CTRL(WR_CACHE_3BITS);
+ 	val |= EIP197_HIA_DSE_CFG_ALLWAYS_BUFFERABLE;
+-	val |= EIP197_HIA_DSE_CFG_EN_SINGLE_WR;
+-	writel(val, priv->base + EIP197_HIA_DSE_CFG);
++	/* FIXME: instability issues can occur for EIP97 but disabling it impact
++	 * performances.
++	 */
++	if (priv->version == EIP197)
++		val |= EIP197_HIA_DSE_CFG_EN_SINGLE_WR;
++	writel(val, EIP197_HIA_DSE(priv) + EIP197_HIA_DSE_CFG);
+ 
+ 	/* Leave the DSE threads reset state */
+-	writel(0, priv->base + EIP197_HIA_DSE_THR_CTRL);
++	writel(0, EIP197_HIA_DSE_THR(priv) + EIP197_HIA_DSE_THR_CTRL);
+ 
+ 	/* Configure the procesing engine thresholds */
+ 	writel(EIP197_PE_OUT_DBUF_THRES_MIN(7) | EIP197_PE_OUT_DBUF_THRES_MAX(8),
+-	       priv->base + EIP197_PE_OUT_DBUF_THRES);
++	       EIP197_PE(priv) + EIP197_PE_OUT_DBUF_THRES);
+ 
+ 	/* Processing Engine configuration */
+ 
+@@ -348,73 +355,75 @@ static int safexcel_hw_init(struct safexcel_crypto_priv *priv)
+ 	val |= EIP197_ALG_AES_ECB | EIP197_ALG_AES_CBC;
+ 	val |= EIP197_ALG_SHA1 | EIP197_ALG_HMAC_SHA1;
+ 	val |= EIP197_ALG_SHA2;
+-	writel(val, priv->base + EIP197_PE_EIP96_FUNCTION_EN);
++	writel(val, EIP197_PE(priv) + EIP197_PE_EIP96_FUNCTION_EN);
+ 
+ 	/* Command Descriptor Rings prepare */
+ 	for (i = 0; i < priv->config.rings; i++) {
+ 		/* Clear interrupts for this ring */
+ 		writel(GENMASK(31, 0),
+-		       priv->base + EIP197_HIA_AIC_R_ENABLE_CLR(i));
++		       EIP197_HIA_AIC_R(priv) + EIP197_HIA_AIC_R_ENABLE_CLR(i));
+ 
+ 		/* Disable external triggering */
+-		writel(0, priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_CFG);
++		writel(0, EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_CFG);
+ 
+ 		/* Clear the pending prepared counter */
+ 		writel(EIP197_xDR_PREP_CLR_COUNT,
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_PREP_COUNT);
++		       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_PREP_COUNT);
+ 
+ 		/* Clear the pending processed counter */
+ 		writel(EIP197_xDR_PROC_CLR_COUNT,
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_PROC_COUNT);
++		       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_PROC_COUNT);
+ 
+ 		writel(0,
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_PREP_PNTR);
++		       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_PREP_PNTR);
+ 		writel(0,
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_PROC_PNTR);
++		       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_PROC_PNTR);
+ 
+ 		writel((EIP197_DEFAULT_RING_SIZE * priv->config.cd_offset) << 2,
+-		       priv->base + EIP197_HIA_CDR(i) + EIP197_HIA_xDR_RING_SIZE);
++		       EIP197_HIA_CDR(priv, i) + EIP197_HIA_xDR_RING_SIZE);
+ 	}
+ 
+ 	/* Result Descriptor Ring prepare */
+ 	for (i = 0; i < priv->config.rings; i++) {
+ 		/* Disable external triggering*/
+-		writel(0, priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_CFG);
++		writel(0, EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_CFG);
+ 
+ 		/* Clear the pending prepared counter */
+ 		writel(EIP197_xDR_PREP_CLR_COUNT,
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_PREP_COUNT);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_PREP_COUNT);
+ 
+ 		/* Clear the pending processed counter */
+ 		writel(EIP197_xDR_PROC_CLR_COUNT,
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_PROC_COUNT);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_PROC_COUNT);
+ 
+ 		writel(0,
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_PREP_PNTR);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_PREP_PNTR);
+ 		writel(0,
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_PROC_PNTR);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_PROC_PNTR);
+ 
+ 		/* Ring size */
+ 		writel((EIP197_DEFAULT_RING_SIZE * priv->config.rd_offset) << 2,
+-		       priv->base + EIP197_HIA_RDR(i) + EIP197_HIA_xDR_RING_SIZE);
++		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_RING_SIZE);
+ 	}
+ 
+ 	/* Enable command descriptor rings */
+ 	writel(EIP197_DxE_THR_CTRL_EN | GENMASK(priv->config.rings - 1, 0),
+-	       priv->base + EIP197_HIA_DFE_THR_CTRL);
++	       EIP197_HIA_DFE_THR(priv) + EIP197_HIA_DFE_THR_CTRL);
+ 
+ 	/* Enable result descriptor rings */
+ 	writel(EIP197_DxE_THR_CTRL_EN | GENMASK(priv->config.rings - 1, 0),
+-	       priv->base + EIP197_HIA_DSE_THR_CTRL);
++	       EIP197_HIA_DSE_THR(priv) + EIP197_HIA_DSE_THR_CTRL);
+ 
+ 	/* Clear any HIA interrupt */
+-	writel(GENMASK(30, 20), priv->base + EIP197_HIA_AIC_G_ACK);
++	writel(GENMASK(30, 20), EIP197_HIA_AIC_G(priv) + EIP197_HIA_AIC_G_ACK);
+ 
+-	eip197_trc_cache_init(priv);
++	if (priv->version == EIP197) {
++		eip197_trc_cache_init(priv);
+ 
+-	ret = eip197_load_firmwares(priv);
+-	if (ret)
+-		return ret;
++		ret = eip197_load_firmwares(priv);
++		if (ret)
++			return ret;
++	}
+ 
+ 	safexcel_hw_setup_cdesc_rings(priv);
+ 	safexcel_hw_setup_rdesc_rings(priv);
+@@ -434,7 +443,7 @@ int safexcel_try_push_requests(struct safexcel_crypto_priv *priv, int ring,
+ 	/* Configure when we want an interrupt */
+ 	writel(EIP197_HIA_RDR_THRESH_PKT_MODE |
+ 	       EIP197_HIA_RDR_THRESH_PROC_PKT(coal),
+-	       priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_THRESH);
++	       EIP197_HIA_RDR(priv, ring) + EIP197_HIA_xDR_THRESH);
+ 
+ 	return coal;
+ }
+@@ -524,11 +533,11 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 
+ 	/* let the RDR know we have pending descriptors */
+ 	writel((rdesc * priv->config.rd_offset) << 2,
+-	       priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_PREP_COUNT);
++	       EIP197_HIA_RDR(priv, ring) + EIP197_HIA_xDR_PREP_COUNT);
+ 
+ 	/* let the CDR know we have pending descriptors */
+ 	writel((cdesc * priv->config.cd_offset) << 2,
+-	       priv->base + EIP197_HIA_CDR(ring) + EIP197_HIA_xDR_PREP_COUNT);
++	       EIP197_HIA_CDR(priv, ring) + EIP197_HIA_xDR_PREP_COUNT);
+ }
+ 
+ void safexcel_free_context(struct safexcel_crypto_priv *priv,
+@@ -629,7 +638,7 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ handle_results:
+ 	tot_descs = 0;
+ 
+-	nreq = readl(priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_PROC_COUNT);
++	nreq = readl(EIP197_HIA_RDR(priv, ring) + EIP197_HIA_xDR_PROC_COUNT);
+ 	nreq >>= EIP197_xDR_PROC_xD_PKT_OFFSET;
+ 	nreq &= EIP197_xDR_PROC_xD_PKT_MASK;
+ 	if (!nreq)
+@@ -665,7 +674,7 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ 	if (i) {
+ 		writel(EIP197_xDR_PROC_xD_PKT(i) |
+ 		       EIP197_xDR_PROC_xD_COUNT(tot_descs * priv->config.rd_offset),
+-		       priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_PROC_COUNT);
++		       EIP197_HIA_RDR(priv, ring) + EIP197_HIA_xDR_PROC_COUNT);
+ 	}
+ 
+ 	/* If the number of requests overflowed the counter, try to proceed more
+@@ -707,13 +716,13 @@ static irqreturn_t safexcel_irq_ring(int irq, void *data)
+ 	int ring = irq_data->ring, rc = IRQ_NONE;
+ 	u32 status, stat;
+ 
+-	status = readl(priv->base + EIP197_HIA_AIC_R_ENABLED_STAT(ring));
++	status = readl(EIP197_HIA_AIC_R(priv) + EIP197_HIA_AIC_R_ENABLED_STAT(ring));
+ 	if (!status)
+ 		return rc;
+ 
+ 	/* RDR interrupts */
+ 	if (status & EIP197_RDR_IRQ(ring)) {
+-		stat = readl(priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_STAT);
++		stat = readl(EIP197_HIA_RDR(priv, ring) + EIP197_HIA_xDR_STAT);
+ 
+ 		if (unlikely(stat & EIP197_xDR_ERR)) {
+ 			/*
+@@ -728,11 +737,11 @@ static irqreturn_t safexcel_irq_ring(int irq, void *data)
+ 
+ 		/* ACK the interrupts */
+ 		writel(stat & 0xff,
+-		       priv->base + EIP197_HIA_RDR(ring) + EIP197_HIA_xDR_STAT);
++		       EIP197_HIA_RDR(priv, ring) + EIP197_HIA_xDR_STAT);
+ 	}
+ 
+ 	/* ACK the interrupts */
+-	writel(status, priv->base + EIP197_HIA_AIC_R_ACK(ring));
++	writel(status, EIP197_HIA_AIC_R(priv) + EIP197_HIA_AIC_R_ACK(ring));
+ 
+ 	return rc;
+ }
+@@ -828,11 +837,11 @@ static void safexcel_configure(struct safexcel_crypto_priv *priv)
+ {
+ 	u32 val, mask;
+ 
+-	val = readl(priv->base + EIP197_HIA_OPTIONS);
++	val = readl(EIP197_HIA_AIC_G(priv) + EIP197_HIA_OPTIONS);
+ 	val = (val & GENMASK(27, 25)) >> 25;
+ 	mask = BIT(val) - 1;
+ 
+-	val = readl(priv->base + EIP197_HIA_OPTIONS);
++	val = readl(EIP197_HIA_AIC_G(priv) + EIP197_HIA_OPTIONS);
+ 	priv->config.rings = min_t(u32, val & GENMASK(3, 0), max_rings);
+ 
+ 	priv->config.cd_size = (sizeof(struct safexcel_command_desc) / sizeof(u32));
+@@ -842,6 +851,35 @@ static void safexcel_configure(struct safexcel_crypto_priv *priv)
+ 	priv->config.rd_offset = (priv->config.rd_size + mask) & ~mask;
+ }
+ 
++static void safexcel_init_register_offsets(struct safexcel_crypto_priv *priv)
++{
++	struct safexcel_register_offsets *offsets = &priv->offsets;
++
++	if (priv->version == EIP197) {
++		offsets->hia_aic	= EIP197_HIA_AIC_BASE;
++		offsets->hia_aic_g	= EIP197_HIA_AIC_G_BASE;
++		offsets->hia_aic_r	= EIP197_HIA_AIC_R_BASE;
++		offsets->hia_aic_xdr	= EIP197_HIA_AIC_xDR_BASE;
++		offsets->hia_dfe	= EIP197_HIA_DFE_BASE;
++		offsets->hia_dfe_thr	= EIP197_HIA_DFE_THR_BASE;
++		offsets->hia_dse	= EIP197_HIA_DSE_BASE;
++		offsets->hia_dse_thr	= EIP197_HIA_DSE_THR_BASE;
++		offsets->hia_gen_cfg	= EIP197_HIA_GEN_CFG_BASE;
++		offsets->pe		= EIP197_PE_BASE;
++	} else {
++		offsets->hia_aic	= EIP97_HIA_AIC_BASE;
++		offsets->hia_aic_g	= EIP97_HIA_AIC_G_BASE;
++		offsets->hia_aic_r	= EIP97_HIA_AIC_R_BASE;
++		offsets->hia_aic_xdr	= EIP97_HIA_AIC_xDR_BASE;
++		offsets->hia_dfe	= EIP97_HIA_DFE_BASE;
++		offsets->hia_dfe_thr	= EIP97_HIA_DFE_THR_BASE;
++		offsets->hia_dse	= EIP97_HIA_DSE_BASE;
++		offsets->hia_dse_thr	= EIP97_HIA_DSE_THR_BASE;
++		offsets->hia_gen_cfg	= EIP97_HIA_GEN_CFG_BASE;
++		offsets->pe		= EIP97_PE_BASE;
++	}
++}
++
+ static int safexcel_probe(struct platform_device *pdev)
+ {
+ 	struct device *dev = &pdev->dev;
+@@ -854,6 +892,9 @@ static int safexcel_probe(struct platform_device *pdev)
+ 		return -ENOMEM;
+ 
+ 	priv->dev = dev;
++	priv->version = (enum safexcel_eip_version)of_device_get_match_data(dev);
++
++	safexcel_init_register_offsets(priv);
+ 
+ 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	priv->base = devm_ioremap_resource(dev, res);
+@@ -980,7 +1021,14 @@ static int safexcel_remove(struct platform_device *pdev)
+ }
+ 
+ static const struct of_device_id safexcel_of_match_table[] = {
+-	{ .compatible = "inside-secure,safexcel-eip197" },
++	{
++		.compatible = "inside-secure,safexcel-eip97",
++		.data = (void *)EIP97,
++	},
++	{
++		.compatible = "inside-secure,safexcel-eip197",
++		.data = (void *)EIP197,
++	},
+ 	{},
+ };
+ 
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index d4955abf873b..4e219c21608b 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -28,55 +28,94 @@
+ #define EIP197_GFP_FLAGS(base)	((base).flags & CRYPTO_TFM_REQ_MAY_SLEEP ? \
+ 				 GFP_KERNEL : GFP_ATOMIC)
+ 
++/* Register base offsets */
++#define EIP197_HIA_AIC(priv)		((priv)->base + (priv)->offsets.hia_aic)
++#define EIP197_HIA_AIC_G(priv)		((priv)->base + (priv)->offsets.hia_aic_g)
++#define EIP197_HIA_AIC_R(priv)		((priv)->base + (priv)->offsets.hia_aic_r)
++#define EIP197_HIA_AIC_xDR(priv)	((priv)->base + (priv)->offsets.hia_aic_xdr)
++#define EIP197_HIA_DFE(priv)		((priv)->base + (priv)->offsets.hia_dfe)
++#define EIP197_HIA_DFE_THR(priv)	((priv)->base + (priv)->offsets.hia_dfe_thr)
++#define EIP197_HIA_DSE(priv)		((priv)->base + (priv)->offsets.hia_dse)
++#define EIP197_HIA_DSE_THR(priv)	((priv)->base + (priv)->offsets.hia_dse_thr)
++#define EIP197_HIA_GEN_CFG(priv)	((priv)->base + (priv)->offsets.hia_gen_cfg)
++#define EIP197_PE(priv)			((priv)->base + (priv)->offsets.pe)
++
++/* EIP197 base offsets */
++#define EIP197_HIA_AIC_BASE		0x90000
++#define EIP197_HIA_AIC_G_BASE		0x90000
++#define EIP197_HIA_AIC_R_BASE		0x90800
++#define EIP197_HIA_AIC_xDR_BASE		0x80000
++#define EIP197_HIA_DFE_BASE		0x8c000
++#define EIP197_HIA_DFE_THR_BASE		0x8c040
++#define EIP197_HIA_DSE_BASE		0x8d000
++#define EIP197_HIA_DSE_THR_BASE		0x8d040
++#define EIP197_HIA_GEN_CFG_BASE		0xf0000
++#define EIP197_PE_BASE			0xa0000
++
++/* EIP97 base offsets */
++#define EIP97_HIA_AIC_BASE		0x0
++#define EIP97_HIA_AIC_G_BASE		0x0
++#define EIP97_HIA_AIC_R_BASE		0x0
++#define EIP97_HIA_AIC_xDR_BASE		0x0
++#define EIP97_HIA_DFE_BASE		0xf000
++#define EIP97_HIA_DFE_THR_BASE		0xf200
++#define EIP97_HIA_DSE_BASE		0xf400
++#define EIP97_HIA_DSE_THR_BASE		0xf600
++#define EIP97_HIA_GEN_CFG_BASE		0x10000
++#define EIP97_PE_BASE			0x10000
++
+ /* CDR/RDR register offsets */
+-#define EIP197_HIA_xDR_OFF(r)			(0x80000 + (r) * 0x1000)
+-#define EIP197_HIA_CDR(r)			(EIP197_HIA_xDR_OFF(r))
+-#define EIP197_HIA_RDR(r)			(EIP197_HIA_xDR_OFF(r) + 0x800)
+-#define EIP197_HIA_xDR_RING_BASE_ADDR_LO	0x0
+-#define EIP197_HIA_xDR_RING_BASE_ADDR_HI	0x4
+-#define EIP197_HIA_xDR_RING_SIZE		0x18
+-#define EIP197_HIA_xDR_DESC_SIZE		0x1c
+-#define EIP197_HIA_xDR_CFG			0x20
+-#define EIP197_HIA_xDR_DMA_CFG			0x24
+-#define EIP197_HIA_xDR_THRESH			0x28
+-#define EIP197_HIA_xDR_PREP_COUNT		0x2c
+-#define EIP197_HIA_xDR_PROC_COUNT		0x30
+-#define EIP197_HIA_xDR_PREP_PNTR		0x34
+-#define EIP197_HIA_xDR_PROC_PNTR		0x38
+-#define EIP197_HIA_xDR_STAT			0x3c
++#define EIP197_HIA_xDR_OFF(priv, r)		(EIP197_HIA_AIC_xDR(priv) + (r) * 0x1000)
++#define EIP197_HIA_CDR(priv, r)			(EIP197_HIA_xDR_OFF(priv, r))
++#define EIP197_HIA_RDR(priv, r)			(EIP197_HIA_xDR_OFF(priv, r) + 0x800)
++#define EIP197_HIA_xDR_RING_BASE_ADDR_LO	0x0000
++#define EIP197_HIA_xDR_RING_BASE_ADDR_HI	0x0004
++#define EIP197_HIA_xDR_RING_SIZE		0x0018
++#define EIP197_HIA_xDR_DESC_SIZE		0x001c
++#define EIP197_HIA_xDR_CFG			0x0020
++#define EIP197_HIA_xDR_DMA_CFG			0x0024
++#define EIP197_HIA_xDR_THRESH			0x0028
++#define EIP197_HIA_xDR_PREP_COUNT		0x002c
++#define EIP197_HIA_xDR_PROC_COUNT		0x0030
++#define EIP197_HIA_xDR_PREP_PNTR		0x0034
++#define EIP197_HIA_xDR_PROC_PNTR		0x0038
++#define EIP197_HIA_xDR_STAT			0x003c
+ 
+ /* register offsets */
+-#define EIP197_HIA_DFE_CFG			0x8c000
+-#define EIP197_HIA_DFE_THR_CTRL			0x8c040
+-#define EIP197_HIA_DFE_THR_STAT			0x8c044
+-#define EIP197_HIA_DSE_CFG			0x8d000
+-#define EIP197_HIA_DSE_THR_CTRL			0x8d040
+-#define EIP197_HIA_DSE_THR_STAT			0x8d044
+-#define EIP197_HIA_RA_PE_CTRL			0x90010
+-#define EIP197_HIA_RA_PE_STAT			0x90014
++#define EIP197_HIA_DFE_CFG			0x0000
++#define EIP197_HIA_DFE_THR_CTRL			0x0000
++#define EIP197_HIA_DFE_THR_STAT			0x0004
++#define EIP197_HIA_DSE_CFG			0x0000
++#define EIP197_HIA_DSE_THR_CTRL			0x0000
++#define EIP197_HIA_DSE_THR_STAT			0x0004
++#define EIP197_HIA_RA_PE_CTRL			0x0010
++#define EIP197_HIA_RA_PE_STAT			0x0014
+ #define EIP197_HIA_AIC_R_OFF(r)			((r) * 0x1000)
+-#define EIP197_HIA_AIC_R_ENABLE_CTRL(r)		(0x9e808 - EIP197_HIA_AIC_R_OFF(r))
+-#define EIP197_HIA_AIC_R_ENABLED_STAT(r)	(0x9e810 - EIP197_HIA_AIC_R_OFF(r))
+-#define EIP197_HIA_AIC_R_ACK(r)			(0x9e810 - EIP197_HIA_AIC_R_OFF(r))
+-#define EIP197_HIA_AIC_R_ENABLE_CLR(r)		(0x9e814 - EIP197_HIA_AIC_R_OFF(r))
+-#define EIP197_HIA_AIC_G_ENABLE_CTRL		0x9f808
+-#define EIP197_HIA_AIC_G_ENABLED_STAT		0x9f810
+-#define EIP197_HIA_AIC_G_ACK			0x9f810
+-#define EIP197_HIA_MST_CTRL			0x9fff4
+-#define EIP197_HIA_OPTIONS			0x9fff8
+-#define EIP197_HIA_VERSION			0x9fffc
+-#define EIP197_PE_IN_DBUF_THRES			0xa0000
+-#define EIP197_PE_IN_TBUF_THRES			0xa0100
+-#define EIP197_PE_ICE_SCRATCH_RAM		0xa0800
+-#define EIP197_PE_ICE_PUE_CTRL			0xa0c80
+-#define EIP197_PE_ICE_SCRATCH_CTRL		0xa0d04
+-#define EIP197_PE_ICE_FPP_CTRL			0xa0d80
+-#define EIP197_PE_ICE_RAM_CTRL			0xa0ff0
+-#define EIP197_PE_EIP96_FUNCTION_EN		0xa1004
+-#define EIP197_PE_EIP96_CONTEXT_CTRL		0xa1008
+-#define EIP197_PE_EIP96_CONTEXT_STAT		0xa100c
+-#define EIP197_PE_OUT_DBUF_THRES		0xa1c00
+-#define EIP197_PE_OUT_TBUF_THRES		0xa1d00
++#define EIP197_HIA_AIC_R_ENABLE_CTRL(r)		(0xe008 - EIP197_HIA_AIC_R_OFF(r))
++#define EIP197_HIA_AIC_R_ENABLED_STAT(r)	(0xe010 - EIP197_HIA_AIC_R_OFF(r))
++#define EIP197_HIA_AIC_R_ACK(r)			(0xe010 - EIP197_HIA_AIC_R_OFF(r))
++#define EIP197_HIA_AIC_R_ENABLE_CLR(r)		(0xe014 - EIP197_HIA_AIC_R_OFF(r))
++#define EIP197_HIA_AIC_G_ENABLE_CTRL		0xf808
++#define EIP197_HIA_AIC_G_ENABLED_STAT		0xf810
++#define EIP197_HIA_AIC_G_ACK			0xf810
++#define EIP197_HIA_MST_CTRL			0xfff4
++#define EIP197_HIA_OPTIONS			0xfff8
++#define EIP197_HIA_VERSION			0xfffc
++#define EIP197_PE_IN_DBUF_THRES			0x0000
++#define EIP197_PE_IN_TBUF_THRES			0x0100
++#define EIP197_PE_ICE_SCRATCH_RAM		0x0800
++#define EIP197_PE_ICE_PUE_CTRL			0x0c80
++#define EIP197_PE_ICE_SCRATCH_CTRL		0x0d04
++#define EIP197_PE_ICE_FPP_CTRL			0x0d80
++#define EIP197_PE_ICE_RAM_CTRL			0x0ff0
++#define EIP197_PE_EIP96_FUNCTION_EN		0x1004
++#define EIP197_PE_EIP96_CONTEXT_CTRL		0x1008
++#define EIP197_PE_EIP96_CONTEXT_STAT		0x100c
++#define EIP197_PE_OUT_DBUF_THRES		0x1c00
++#define EIP197_PE_OUT_TBUF_THRES		0x1d00
++#define EIP197_MST_CTRL				0xfff4
++
++/* EIP197-specific registers, no indirection */
+ #define EIP197_CLASSIFICATION_RAMS		0xe0000
+ #define EIP197_TRC_CTRL				0xf0800
+ #define EIP197_TRC_LASTRES			0xf0804
+@@ -90,7 +129,6 @@
+ #define EIP197_TRC_ECCDATASTAT			0xf083c
+ #define EIP197_TRC_ECCDATA			0xf0840
+ #define EIP197_CS_RAM_CTRL			0xf7ff0
+-#define EIP197_MST_CTRL				0xffff4
+ 
+ /* EIP197_HIA_xDR_DESC_SIZE */
+ #define EIP197_xDR_DESC_MODE_64BIT		BIT(31)
+@@ -465,12 +503,33 @@ struct safexcel_work_data {
+ 	int ring;
+ };
+ 
++enum safexcel_eip_version {
++	EIP97,
++	EIP197,
++};
++
++struct safexcel_register_offsets {
++	u32 hia_aic;
++	u32 hia_aic_g;
++	u32 hia_aic_r;
++	u32 hia_aic_xdr;
++	u32 hia_dfe;
++	u32 hia_dfe_thr;
++	u32 hia_dse;
++	u32 hia_dse_thr;
++	u32 hia_gen_cfg;
++	u32 pe;
++};
++
+ struct safexcel_crypto_priv {
+ 	void __iomem *base;
+ 	struct device *dev;
+ 	struct clk *clk;
+ 	struct safexcel_config config;
+ 
++	enum safexcel_eip_version version;
++	struct safexcel_register_offsets offsets;
++
+ 	/* context DMA pool */
+ 	struct dma_pool *context_pool;
+ 
+diff --git a/drivers/crypto/inside-secure/safexcel_cipher.c b/drivers/crypto/inside-secure/safexcel_cipher.c
+index 7c9a2d87135b..17a7725a6f6d 100644
+--- a/drivers/crypto/inside-secure/safexcel_cipher.c
++++ b/drivers/crypto/inside-secure/safexcel_cipher.c
+@@ -69,6 +69,7 @@ static int safexcel_aes_setkey(struct crypto_skcipher *ctfm, const u8 *key,
+ {
+ 	struct crypto_tfm *tfm = crypto_skcipher_tfm(ctfm);
+ 	struct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(tfm);
++	struct safexcel_crypto_priv *priv = ctx->priv;
+ 	struct crypto_aes_ctx aes;
+ 	int ret, i;
+ 
+@@ -78,7 +79,7 @@ static int safexcel_aes_setkey(struct crypto_skcipher *ctfm, const u8 *key,
+ 		return ret;
+ 	}
+ 
+-	if (ctx->base.ctxr_dma) {
++	if (priv->version == EIP197 && ctx->base.ctxr_dma) {
+ 		for (i = 0; i < len / sizeof(u32); i++) {
+ 			if (ctx->key[i] != cpu_to_le32(aes.key_enc[i])) {
+ 				ctx->base.needs_inv = true;
+@@ -411,9 +412,13 @@ static int safexcel_send(struct crypto_async_request *async,
+ 			 int *commands, int *results)
+ {
+ 	struct skcipher_request *req = skcipher_request_cast(async);
++	struct safexcel_cipher_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
+ 	struct safexcel_cipher_req *sreq = skcipher_request_ctx(req);
++	struct safexcel_crypto_priv *priv = ctx->priv;
+ 	int ret;
+ 
++	BUG_ON(priv->version == EIP97 && sreq->needs_inv);
++
+ 	if (sreq->needs_inv)
+ 		ret = safexcel_cipher_send_inv(async, ring, request,
+ 					       commands, results);
+@@ -476,7 +481,7 @@ static int safexcel_aes(struct skcipher_request *req,
+ 	ctx->mode = mode;
+ 
+ 	if (ctx->base.ctxr) {
+-		if (ctx->base.needs_inv) {
++		if (priv->version == EIP197 && ctx->base.needs_inv) {
+ 			sreq->needs_inv = true;
+ 			ctx->base.needs_inv = false;
+ 		}
+@@ -544,9 +549,14 @@ static void safexcel_skcipher_cra_exit(struct crypto_tfm *tfm)
+ 
+ 	memzero_explicit(ctx->base.ctxr->data, 8 * sizeof(u32));
+ 
+-	ret = safexcel_cipher_exit_inv(tfm);
+-	if (ret)
+-		dev_warn(priv->dev, "cipher: invalidation error %d\n", ret);
++	if (priv->version == EIP197) {
++		ret = safexcel_cipher_exit_inv(tfm);
++		if (ret)
++			dev_warn(priv->dev, "cipher: invalidation error %d\n", ret);
++	} else {
++		dma_pool_free(priv->context_pool, ctx->base.ctxr,
++			      ctx->base.ctxr_dma);
++	}
+ }
+ 
+ struct safexcel_alg_template safexcel_alg_ecb_aes = {
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 6912c032200b..b9a2bfd91c20 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -415,6 +415,8 @@ static int safexcel_handle_result(struct safexcel_crypto_priv *priv, int ring,
+ 	struct safexcel_ahash_req *req = ahash_request_ctx(areq);
+ 	int err;
+ 
++	BUG_ON(priv->version == EIP97 && req->needs_inv);
++
+ 	if (req->needs_inv) {
+ 		req->needs_inv = false;
+ 		err = safexcel_handle_inv_result(priv, ring, async,
+@@ -536,7 +538,8 @@ static int safexcel_ahash_enqueue(struct ahash_request *areq)
+ 	req->needs_inv = false;
+ 
+ 	if (ctx->base.ctxr) {
+-		if (!ctx->base.needs_inv && req->processed &&
++		if (priv->version == EIP197 &&
++		    !ctx->base.needs_inv && req->processed &&
+ 		    ctx->digest == CONTEXT_CONTROL_DIGEST_PRECOMPUTED)
+ 			/* We're still setting needs_inv here, even though it is
+ 			 * cleared right away, because the needs_inv flag can be
+@@ -729,9 +732,14 @@ static void safexcel_ahash_cra_exit(struct crypto_tfm *tfm)
+ 	if (!ctx->base.ctxr)
+ 		return;
+ 
+-	ret = safexcel_ahash_exit_inv(tfm);
+-	if (ret)
+-		dev_warn(priv->dev, "hash: invalidation error %d\n", ret);
++	if (priv->version == EIP197) {
++		ret = safexcel_ahash_exit_inv(tfm);
++		if (ret)
++			dev_warn(priv->dev, "hash: invalidation error %d\n", ret);
++	} else {
++		dma_pool_free(priv->context_pool, ctx->base.ctxr,
++			      ctx->base.ctxr_dma);
++	}
+ }
+ 
+ struct safexcel_alg_template safexcel_alg_sha1 = {
+@@ -935,6 +943,7 @@ static int safexcel_hmac_sha1_setkey(struct crypto_ahash *tfm, const u8 *key,
+ 				     unsigned int keylen)
+ {
+ 	struct safexcel_ahash_ctx *ctx = crypto_tfm_ctx(crypto_ahash_tfm(tfm));
++	struct safexcel_crypto_priv *priv = ctx->priv;
+ 	struct safexcel_ahash_export_state istate, ostate;
+ 	int ret, i;
+ 
+@@ -942,7 +951,7 @@ static int safexcel_hmac_sha1_setkey(struct crypto_ahash *tfm, const u8 *key,
+ 	if (ret)
+ 		return ret;
+ 
+-	if (ctx->base.ctxr) {
++	if (priv->version == EIP197 && ctx->base.ctxr) {
+ 		for (i = 0; i < SHA1_DIGEST_SIZE / sizeof(u32); i++) {
+ 			if (ctx->ipad[i] != le32_to_cpu(istate.state[i]) ||
+ 			    ctx->opad[i] != le32_to_cpu(ostate.state[i])) {
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90018-crypto-inside-secure-make-function-safexcel_try_push.patch b/target/linux/mvebu/patches-4.14/90018-crypto-inside-secure-make-function-safexcel_try_push.patch
new file mode 100644
index 0000000..9387646
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90018-crypto-inside-secure-make-function-safexcel_try_push.patch
@@ -0,0 +1,38 @@
+From 938939e81b621c102b10022f9ae070ade0d9df83 Mon Sep 17 00:00:00 2001
+From: Colin Ian King <colin.king@canonical.com>
+Date: Tue, 16 Jan 2018 08:41:58 +0100
+Subject: [PATCH 018/126] crypto: inside-secure - make function
+ safexcel_try_push_requests static
+
+The function safexcel_try_push_requests  is local to the source and does
+not need to be in global scope, so make it static.
+
+Cleans up sparse warning:
+symbol 'safexcel_try_push_requests' was not declared. Should it be static?
+
+Signed-off-by: Colin Ian King <colin.king@canonical.com>
+[Antoine: fixed alignment]
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index b0787f5f62ad..46b691aae475 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -432,8 +432,8 @@ static int safexcel_hw_init(struct safexcel_crypto_priv *priv)
+ }
+ 
+ /* Called with ring's lock taken */
+-int safexcel_try_push_requests(struct safexcel_crypto_priv *priv, int ring,
+-			       int reqs)
++static int safexcel_try_push_requests(struct safexcel_crypto_priv *priv,
++				      int ring, int reqs)
+ {
+ 	int coal = min_t(int, reqs, EIP197_MAX_BATCH_SZ);
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90019-crypto-inside-secure-do-not-overwrite-the-threshold-.patch b/target/linux/mvebu/patches-4.14/90019-crypto-inside-secure-do-not-overwrite-the-threshold-.patch
new file mode 100644
index 0000000..560b43a
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90019-crypto-inside-secure-do-not-overwrite-the-threshold-.patch
@@ -0,0 +1,40 @@
+From 1af1254859cc67b07e64547f6e3635ad41824d03 Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Tue, 13 Feb 2018 09:26:51 +0100
+Subject: [PATCH 019/126] crypto: inside-secure - do not overwrite the
+ threshold value
+
+This patch fixes the Inside Secure SafeXcel driver not to overwrite the
+interrupt threshold value. In certain cases the value of this register,
+which controls when to fire an interrupt, was overwritten. This lead to
+packet not being processed or acked as the driver never was aware of
+their completion.
+
+This patch fixes this behaviour by not setting the threshold when
+requests are being processed by the engine.
+
+Fixes: dc7e28a3286e ("crypto: inside-secure - dequeue all requests at once")
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 3 +--
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index 46b691aae475..f4a76971b4ac 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -523,8 +523,7 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 
+ 	if (!priv->ring[ring].busy) {
+ 		nreq -= safexcel_try_push_requests(priv, ring, nreq);
+-		if (nreq)
+-			priv->ring[ring].busy = true;
++		priv->ring[ring].busy = true;
+ 	}
+ 
+ 	priv->ring[ring].requests_left += nreq;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90020-crypto-inside-secure-keep-the-requests-push-pop-sync.patch b/target/linux/mvebu/patches-4.14/90020-crypto-inside-secure-keep-the-requests-push-pop-sync.patch
new file mode 100644
index 0000000..77a9b79
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90020-crypto-inside-secure-keep-the-requests-push-pop-sync.patch
@@ -0,0 +1,136 @@
+From 730b546b41883ab7b9112d3d6519506c73122c44 Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Tue, 13 Feb 2018 09:26:56 +0100
+Subject: [PATCH 020/126] crypto: inside-secure - keep the requests push/pop
+ synced
+
+This patch updates the Inside Secure SafeXcel driver to avoid being
+out-of-sync between the number of requests sent and the one being
+completed.
+
+The number of requests acknowledged by the driver can be different than
+the threshold that was configured if new requests were being pushed to
+the h/w in the meantime. The driver wasn't taking those into account,
+and the number of remaining requests to handled (to reconfigure the
+interrupt threshold) could be out-of sync.
+
+This patch fixes it by not taking in account the number of requests
+left, but by taking in account the total number of requests being sent
+to the hardware, so that new requests are being taken into account.
+
+Fixes: dc7e28a3286e ("crypto: inside-secure - dequeue all requests at once")
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 28 ++++++++++++-------------
+ drivers/crypto/inside-secure/safexcel.h |  6 ++----
+ 2 files changed, 15 insertions(+), 19 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index f4a76971b4ac..fe1f55c3e501 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -432,20 +432,18 @@ static int safexcel_hw_init(struct safexcel_crypto_priv *priv)
+ }
+ 
+ /* Called with ring's lock taken */
+-static int safexcel_try_push_requests(struct safexcel_crypto_priv *priv,
+-				      int ring, int reqs)
++static void safexcel_try_push_requests(struct safexcel_crypto_priv *priv,
++				       int ring)
+ {
+-	int coal = min_t(int, reqs, EIP197_MAX_BATCH_SZ);
++	int coal = min_t(int, priv->ring[ring].requests, EIP197_MAX_BATCH_SZ);
+ 
+ 	if (!coal)
+-		return 0;
++		return;
+ 
+ 	/* Configure when we want an interrupt */
+ 	writel(EIP197_HIA_RDR_THRESH_PKT_MODE |
+ 	       EIP197_HIA_RDR_THRESH_PROC_PKT(coal),
+ 	       EIP197_HIA_RDR(priv, ring) + EIP197_HIA_xDR_THRESH);
+-
+-	return coal;
+ }
+ 
+ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+@@ -521,13 +519,13 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 
+ 	spin_lock_bh(&priv->ring[ring].egress_lock);
+ 
++	priv->ring[ring].requests += nreq;
++
+ 	if (!priv->ring[ring].busy) {
+-		nreq -= safexcel_try_push_requests(priv, ring, nreq);
++		safexcel_try_push_requests(priv, ring);
+ 		priv->ring[ring].busy = true;
+ 	}
+ 
+-	priv->ring[ring].requests_left += nreq;
+-
+ 	spin_unlock_bh(&priv->ring[ring].egress_lock);
+ 
+ 	/* let the RDR know we have pending descriptors */
+@@ -631,7 +629,7 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ {
+ 	struct safexcel_request *sreq;
+ 	struct safexcel_context *ctx;
+-	int ret, i, nreq, ndesc, tot_descs, done;
++	int ret, i, nreq, ndesc, tot_descs, handled = 0;
+ 	bool should_complete;
+ 
+ handle_results:
+@@ -667,6 +665,7 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ 
+ 		kfree(sreq);
+ 		tot_descs += ndesc;
++		handled++;
+ 	}
+ 
+ acknowledge:
+@@ -685,11 +684,10 @@ static inline void safexcel_handle_result_descriptor(struct safexcel_crypto_priv
+ requests_left:
+ 	spin_lock_bh(&priv->ring[ring].egress_lock);
+ 
+-	done = safexcel_try_push_requests(priv, ring,
+-					  priv->ring[ring].requests_left);
++	priv->ring[ring].requests -= handled;
++	safexcel_try_push_requests(priv, ring);
+ 
+-	priv->ring[ring].requests_left -= done;
+-	if (!done && !priv->ring[ring].requests_left)
++	if (!priv->ring[ring].requests)
+ 		priv->ring[ring].busy = false;
+ 
+ 	spin_unlock_bh(&priv->ring[ring].egress_lock);
+@@ -970,7 +968,7 @@ static int safexcel_probe(struct platform_device *pdev)
+ 			goto err_clk;
+ 		}
+ 
+-		priv->ring[i].requests_left = 0;
++		priv->ring[i].requests = 0;
+ 		priv->ring[i].busy = false;
+ 
+ 		crypto_init_queue(&priv->ring[i].queue,
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 4e219c21608b..caaf6a81b162 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -551,10 +551,8 @@ struct safexcel_crypto_priv {
+ 		struct crypto_queue queue;
+ 		spinlock_t queue_lock;
+ 
+-		/* Number of requests in the engine that needs the threshold
+-		 * interrupt to be set up.
+-		 */
+-		int requests_left;
++		/* Number of requests in the engine. */
++		int requests;
+ 
+ 		/* The ring is currently handling at least one request */
+ 		bool busy;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90021-crypto-inside-secure-unmap-the-result-in-the-hash-se.patch b/target/linux/mvebu/patches-4.14/90021-crypto-inside-secure-unmap-the-result-in-the-hash-se.patch
new file mode 100644
index 0000000..a8cce74
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90021-crypto-inside-secure-unmap-the-result-in-the-hash-se.patch
@@ -0,0 +1,42 @@
+From 5c41b26c94e8522502e636e9c60fcc791ce33f2e Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Tue, 13 Feb 2018 09:26:57 +0100
+Subject: [PATCH 021/126] crypto: inside-secure - unmap the result in the hash
+ send error path
+
+This patch adds a label to unmap the result buffer in the hash send
+function error path.
+
+Fixes: 1b44c5a60c13 ("crypto: inside-secure - add SafeXcel EIP197 crypto engine driver")
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index b9a2bfd91c20..7b181bd6959f 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -303,7 +303,7 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 				   req->state_sz);
+ 	if (IS_ERR(rdesc)) {
+ 		ret = PTR_ERR(rdesc);
+-		goto cdesc_rollback;
++		goto unmap_result;
+ 	}
+ 
+ 	spin_unlock_bh(&priv->ring[ring].egress_lock);
+@@ -315,6 +315,8 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 	*results = 1;
+ 	return 0;
+ 
++unmap_result:
++	dma_unmap_sg(priv->dev, areq->src, req->nents, DMA_TO_DEVICE);
+ cdesc_rollback:
+ 	for (i = 0; i < n_cdesc; i++)
+ 		safexcel_ring_rollback_wptr(priv, &priv->ring[ring].cdr);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90022-crypto-inside-secure-move-hash-result-dma-mapping-to.patch b/target/linux/mvebu/patches-4.14/90022-crypto-inside-secure-move-hash-result-dma-mapping-to.patch
new file mode 100644
index 0000000..fabc54c
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90022-crypto-inside-secure-move-hash-result-dma-mapping-to.patch
@@ -0,0 +1,115 @@
+From 96966195365e654f6a563c3f79ad565b0696ad1a Mon Sep 17 00:00:00 2001
+From: Ofer Heifetz <oferh@marvell.com>
+Date: Mon, 26 Feb 2018 14:45:10 +0100
+Subject: [PATCH 022/126] crypto: inside-secure - move hash result dma mapping
+ to request
+
+In heavy traffic the DMA mapping is overwritten by multiple requests as
+the DMA address is stored in a global context. This patch moves this
+information to the per-hash request context so that it can't be
+overwritten.
+
+Fixes: 1b44c5a60c13 ("crypto: inside-secure - add SafeXcel EIP197 crypto engine driver")
+Signed-off-by: Ofer Heifetz <oferh@marvell.com>
+[Antoine: rebased the patch, small fixes, commit message.]
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c      |  7 +------
+ drivers/crypto/inside-secure/safexcel.h      |  4 +---
+ drivers/crypto/inside-secure/safexcel_hash.c | 17 ++++++++++++-----
+ 3 files changed, 14 insertions(+), 14 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index fe1f55c3e501..97cd64041189 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -538,15 +538,10 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ }
+ 
+ void safexcel_free_context(struct safexcel_crypto_priv *priv,
+-			   struct crypto_async_request *req,
+-			   int result_sz)
++			   struct crypto_async_request *req)
+ {
+ 	struct safexcel_context *ctx = crypto_tfm_ctx(req->tfm);
+ 
+-	if (ctx->result_dma)
+-		dma_unmap_single(priv->dev, ctx->result_dma, result_sz,
+-				 DMA_FROM_DEVICE);
+-
+ 	if (ctx->cache) {
+ 		dma_unmap_single(priv->dev, ctx->cache_dma, ctx->cache_sz,
+ 				 DMA_TO_DEVICE);
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index caaf6a81b162..4e14c7e730c4 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -580,7 +580,6 @@ struct safexcel_context {
+ 	bool exit_inv;
+ 
+ 	/* Used for ahash requests */
+-	dma_addr_t result_dma;
+ 	void *cache;
+ 	dma_addr_t cache_dma;
+ 	unsigned int cache_sz;
+@@ -608,8 +607,7 @@ struct safexcel_inv_result {
+ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring);
+ void safexcel_complete(struct safexcel_crypto_priv *priv, int ring);
+ void safexcel_free_context(struct safexcel_crypto_priv *priv,
+-				  struct crypto_async_request *req,
+-				  int result_sz);
++				  struct crypto_async_request *req);
+ int safexcel_invalidate_cache(struct crypto_async_request *async,
+ 			      struct safexcel_crypto_priv *priv,
+ 			      dma_addr_t ctxr_dma, int ring,
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 7b181bd6959f..a31837f3b506 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -34,6 +34,7 @@ struct safexcel_ahash_req {
+ 	bool needs_inv;
+ 
+ 	int nents;
++	dma_addr_t result_dma;
+ 
+ 	u8 state_sz;    /* expected sate size, only set once */
+ 	u32 state[SHA256_DIGEST_SIZE / sizeof(u32)] __aligned(sizeof(u32));
+@@ -158,7 +159,13 @@ static int safexcel_handle_req_result(struct safexcel_crypto_priv *priv, int rin
+ 		sreq->nents = 0;
+ 	}
+ 
+-	safexcel_free_context(priv, async, sreq->state_sz);
++	if (sreq->result_dma) {
++		dma_unmap_single(priv->dev, sreq->result_dma, sreq->state_sz,
++				 DMA_FROM_DEVICE);
++		sreq->result_dma = 0;
++	}
++
++	safexcel_free_context(priv, async);
+ 
+ 	cache_len = sreq->len - sreq->processed;
+ 	if (cache_len)
+@@ -291,15 +298,15 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 	/* Add the token */
+ 	safexcel_hash_token(first_cdesc, len, req->state_sz);
+ 
+-	ctx->base.result_dma = dma_map_single(priv->dev, req->state,
+-					      req->state_sz, DMA_FROM_DEVICE);
+-	if (dma_mapping_error(priv->dev, ctx->base.result_dma)) {
++	req->result_dma = dma_map_single(priv->dev, req->state, req->state_sz,
++					 DMA_FROM_DEVICE);
++	if (dma_mapping_error(priv->dev, req->result_dma)) {
+ 		ret = -EINVAL;
+ 		goto cdesc_rollback;
+ 	}
+ 
+ 	/* Add a result descriptor */
+-	rdesc = safexcel_add_rdesc(priv, ring, 1, 1, ctx->base.result_dma,
++	rdesc = safexcel_add_rdesc(priv, ring, 1, 1, req->result_dma,
+ 				   req->state_sz);
+ 	if (IS_ERR(rdesc)) {
+ 		ret = PTR_ERR(rdesc);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90023-crypto-inside-secure-move-cache-result-dma-mapping-t.patch b/target/linux/mvebu/patches-4.14/90023-crypto-inside-secure-move-cache-result-dma-mapping-t.patch
new file mode 100644
index 0000000..1f9c2a8
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90023-crypto-inside-secure-move-cache-result-dma-mapping-t.patch
@@ -0,0 +1,152 @@
+From d5a0796d76e865d8123d773e163194c0bfb2b752 Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Mon, 26 Feb 2018 14:45:11 +0100
+Subject: [PATCH 023/126] crypto: inside-secure - move cache result dma mapping
+ to request
+
+In heavy traffic the DMA mapping is overwritten by multiple requests as
+the DMA address is stored in a global context. This patch moves this
+information to the per-hash request context so that it can't be
+overwritten.
+
+Fixes: 1b44c5a60c13 ("crypto: inside-secure - add SafeXcel EIP197 crypto engine driver")
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c      | 14 -------
+ drivers/crypto/inside-secure/safexcel.h      |  7 ----
+ drivers/crypto/inside-secure/safexcel_hash.c | 42 +++++++++-----------
+ 3 files changed, 18 insertions(+), 45 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index 97cd64041189..09adeaa0da6b 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -537,20 +537,6 @@ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring)
+ 	       EIP197_HIA_CDR(priv, ring) + EIP197_HIA_xDR_PREP_COUNT);
+ }
+ 
+-void safexcel_free_context(struct safexcel_crypto_priv *priv,
+-			   struct crypto_async_request *req)
+-{
+-	struct safexcel_context *ctx = crypto_tfm_ctx(req->tfm);
+-
+-	if (ctx->cache) {
+-		dma_unmap_single(priv->dev, ctx->cache_dma, ctx->cache_sz,
+-				 DMA_TO_DEVICE);
+-		kfree(ctx->cache);
+-		ctx->cache = NULL;
+-		ctx->cache_sz = 0;
+-	}
+-}
+-
+ void safexcel_complete(struct safexcel_crypto_priv *priv, int ring)
+ {
+ 	struct safexcel_command_desc *cdesc;
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 4e14c7e730c4..d8dff65fc311 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -578,11 +578,6 @@ struct safexcel_context {
+ 	int ring;
+ 	bool needs_inv;
+ 	bool exit_inv;
+-
+-	/* Used for ahash requests */
+-	void *cache;
+-	dma_addr_t cache_dma;
+-	unsigned int cache_sz;
+ };
+ 
+ /*
+@@ -606,8 +601,6 @@ struct safexcel_inv_result {
+ 
+ void safexcel_dequeue(struct safexcel_crypto_priv *priv, int ring);
+ void safexcel_complete(struct safexcel_crypto_priv *priv, int ring);
+-void safexcel_free_context(struct safexcel_crypto_priv *priv,
+-				  struct crypto_async_request *req);
+ int safexcel_invalidate_cache(struct crypto_async_request *async,
+ 			      struct safexcel_crypto_priv *priv,
+ 			      dma_addr_t ctxr_dma, int ring,
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index a31837f3b506..9703a4063cfc 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -43,6 +43,9 @@ struct safexcel_ahash_req {
+ 	u64 processed;
+ 
+ 	u8 cache[SHA256_BLOCK_SIZE] __aligned(sizeof(u32));
++	dma_addr_t cache_dma;
++	unsigned int cache_sz;
++
+ 	u8 cache_next[SHA256_BLOCK_SIZE] __aligned(sizeof(u32));
+ };
+ 
+@@ -165,7 +168,11 @@ static int safexcel_handle_req_result(struct safexcel_crypto_priv *priv, int rin
+ 		sreq->result_dma = 0;
+ 	}
+ 
+-	safexcel_free_context(priv, async);
++	if (sreq->cache_dma) {
++		dma_unmap_single(priv->dev, sreq->cache_dma, sreq->cache_sz,
++				 DMA_TO_DEVICE);
++		sreq->cache_dma = 0;
++	}
+ 
+ 	cache_len = sreq->len - sreq->processed;
+ 	if (cache_len)
+@@ -227,24 +234,15 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 
+ 	/* Add a command descriptor for the cached data, if any */
+ 	if (cache_len) {
+-		ctx->base.cache = kzalloc(cache_len, EIP197_GFP_FLAGS(*async));
+-		if (!ctx->base.cache) {
+-			ret = -ENOMEM;
+-			goto unlock;
+-		}
+-		memcpy(ctx->base.cache, req->cache, cache_len);
+-		ctx->base.cache_dma = dma_map_single(priv->dev, ctx->base.cache,
+-						     cache_len, DMA_TO_DEVICE);
+-		if (dma_mapping_error(priv->dev, ctx->base.cache_dma)) {
+-			ret = -EINVAL;
+-			goto free_cache;
+-		}
++		req->cache_dma = dma_map_single(priv->dev, req->cache,
++						cache_len, DMA_TO_DEVICE);
++		if (dma_mapping_error(priv->dev, req->cache_dma))
++			return -EINVAL;
+ 
+-		ctx->base.cache_sz = cache_len;
++		req->cache_sz = cache_len;
+ 		first_cdesc = safexcel_add_cdesc(priv, ring, 1,
+ 						 (cache_len == len),
+-						 ctx->base.cache_dma,
+-						 cache_len, len,
++						 req->cache_dma, cache_len, len,
+ 						 ctx->base.ctxr_dma);
+ 		if (IS_ERR(first_cdesc)) {
+ 			ret = PTR_ERR(first_cdesc);
+@@ -328,16 +326,12 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 	for (i = 0; i < n_cdesc; i++)
+ 		safexcel_ring_rollback_wptr(priv, &priv->ring[ring].cdr);
+ unmap_cache:
+-	if (ctx->base.cache_dma) {
+-		dma_unmap_single(priv->dev, ctx->base.cache_dma,
+-				 ctx->base.cache_sz, DMA_TO_DEVICE);
+-		ctx->base.cache_sz = 0;
++	if (req->cache_dma) {
++		dma_unmap_single(priv->dev, req->cache_dma, req->cache_sz,
++				 DMA_TO_DEVICE);
++		req->cache_sz = 0;
+ 	}
+-free_cache:
+-	kfree(ctx->base.cache);
+-	ctx->base.cache = NULL;
+ 
+-unlock:
+ 	spin_unlock_bh(&priv->ring[ring].egress_lock);
+ 	return ret;
+ }
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90024-crypto-inside-secure-fix-missing-unlock-on-error-in-.patch b/target/linux/mvebu/patches-4.14/90024-crypto-inside-secure-fix-missing-unlock-on-error-in-.patch
new file mode 100644
index 0000000..1e319a7
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90024-crypto-inside-secure-fix-missing-unlock-on-error-in-.patch
@@ -0,0 +1,36 @@
+From 716fab484fcc7258b1f9a5c9b270cdfcbb6bdae2 Mon Sep 17 00:00:00 2001
+From: "weiyongjun \\(A\\)" <weiyongjun1@huawei.com>
+Date: Tue, 13 Mar 2018 14:54:03 +0000
+Subject: [PATCH 024/126] crypto: inside-secure - fix missing unlock on error
+ in safexcel_ahash_send_req()
+
+Add the missing unlock before return from function
+safexcel_ahash_send_req() in the error handling case.
+
+Fixes: cff9a17545a3 ("crypto: inside-secure - move cache result dma mapping to request")
+Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
+Acked-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 9703a4063cfc..a7702da92b02 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -236,8 +236,10 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 	if (cache_len) {
+ 		req->cache_dma = dma_map_single(priv->dev, req->cache,
+ 						cache_len, DMA_TO_DEVICE);
+-		if (dma_mapping_error(priv->dev, req->cache_dma))
++		if (dma_mapping_error(priv->dev, req->cache_dma)) {
++			spin_unlock_bh(&priv->ring[ring].egress_lock);
+ 			return -EINVAL;
++		}
+ 
+ 		req->cache_sz = cache_len;
+ 		first_cdesc = safexcel_add_cdesc(priv, ring, 1,
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90025-crypto-inside-secure-improve-clock-initialization.patch b/target/linux/mvebu/patches-4.14/90025-crypto-inside-secure-improve-clock-initialization.patch
new file mode 100644
index 0000000..d3d1492
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90025-crypto-inside-secure-improve-clock-initialization.patch
@@ -0,0 +1,48 @@
+From 242f5d4c83c93accdcfdc56e61b090a667db3932 Mon Sep 17 00:00:00 2001
+From: Gregory CLEMENT <gregory.clement@bootlin.com>
+Date: Tue, 13 Mar 2018 17:48:41 +0100
+Subject: [PATCH 025/126] crypto: inside-secure - improve clock initialization
+
+The clock is optional, but if it is present we should managed it. If
+there is an error while trying getting it, we should exit and report this
+error.
+
+So instead of returning an error only in the -EPROBE case, turn it in an
+other way and ignore the clock only if it is not present (-ENOENT case).
+
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 11 ++++++-----
+ 1 file changed, 6 insertions(+), 5 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index 09adeaa0da6b..cbcb5d9f17bd 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -882,16 +882,17 @@ static int safexcel_probe(struct platform_device *pdev)
+ 	}
+ 
+ 	priv->clk = devm_clk_get(&pdev->dev, NULL);
+-	if (!IS_ERR(priv->clk)) {
++	ret = PTR_ERR_OR_ZERO(priv->clk);
++	/* The clock isn't mandatory */
++	if  (ret != -ENOENT) {
++		if (ret)
++			return ret;
++
+ 		ret = clk_prepare_enable(priv->clk);
+ 		if (ret) {
+ 			dev_err(dev, "unable to enable clk (%d)\n", ret);
+ 			return ret;
+ 		}
+-	} else {
+-		/* The clock isn't mandatory */
+-		if (PTR_ERR(priv->clk) == -EPROBE_DEFER)
+-			return -EPROBE_DEFER;
+ 	}
+ 
+ 	ret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64));
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90026-crypto-inside-secure-fix-clock-resource-by-adding-a-.patch b/target/linux/mvebu/patches-4.14/90026-crypto-inside-secure-fix-clock-resource-by-adding-a-.patch
new file mode 100644
index 0000000..93c7366
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90026-crypto-inside-secure-fix-clock-resource-by-adding-a-.patch
@@ -0,0 +1,146 @@
+From 1d3fa47145163bae30e6b37312a54e61c72caef4 Mon Sep 17 00:00:00 2001
+From: Gregory CLEMENT <gregory.clement@bootlin.com>
+Date: Tue, 13 Mar 2018 17:48:42 +0100
+Subject: [PATCH 026/126] crypto: inside-secure - fix clock resource by adding
+ a register clock
+
+On Armada 7K/8K we need to explicitly enable the register clock. This
+clock is optional because not all the SoCs using this IP need it but at
+least for Armada 7K/8K it is actually mandatory.
+
+The binding documentation is updated accordingly.
+
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ .../crypto/inside-secure-safexcel.txt         |  6 +++-
+ drivers/crypto/inside-secure/safexcel.c       | 34 ++++++++++++++-----
+ drivers/crypto/inside-secure/safexcel.h       |  1 +
+ 3 files changed, 31 insertions(+), 10 deletions(-)
+
+diff --git a/Documentation/devicetree/bindings/crypto/inside-secure-safexcel.txt b/Documentation/devicetree/bindings/crypto/inside-secure-safexcel.txt
+index fbc07d12322f..5a3d0829ddf2 100644
+--- a/Documentation/devicetree/bindings/crypto/inside-secure-safexcel.txt
++++ b/Documentation/devicetree/bindings/crypto/inside-secure-safexcel.txt
+@@ -7,7 +7,11 @@ Required properties:
+ - interrupt-names: Should be "ring0", "ring1", "ring2", "ring3", "eip", "mem".
+ 
+ Optional properties:
+-- clocks: Reference to the crypto engine clock.
++- clocks: Reference to the crypto engine clocks, the second clock is
++          needed for the Armada 7K/8K SoCs.
++- clock-names: mandatory if there is a second clock, in this case the
++               name must be "core" for the first clock and "reg" for
++               the second one.
+ 
+ Example:
+ 
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index cbcb5d9f17bd..2f68b4ed5500 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -895,16 +895,30 @@ static int safexcel_probe(struct platform_device *pdev)
+ 		}
+ 	}
+ 
++	priv->reg_clk = devm_clk_get(&pdev->dev, "reg");
++	ret = PTR_ERR_OR_ZERO(priv->reg_clk);
++	/* The clock isn't mandatory */
++	if  (ret != -ENOENT) {
++		if (ret)
++			goto err_core_clk;
++
++		ret = clk_prepare_enable(priv->reg_clk);
++		if (ret) {
++			dev_err(dev, "unable to enable reg clk (%d)\n", ret);
++			goto err_core_clk;
++		}
++	}
++
+ 	ret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64));
+ 	if (ret)
+-		goto err_clk;
++		goto err_reg_clk;
+ 
+ 	priv->context_pool = dmam_pool_create("safexcel-context", dev,
+ 					      sizeof(struct safexcel_context_record),
+ 					      1, 0);
+ 	if (!priv->context_pool) {
+ 		ret = -ENOMEM;
+-		goto err_clk;
++		goto err_reg_clk;
+ 	}
+ 
+ 	safexcel_configure(priv);
+@@ -919,12 +933,12 @@ static int safexcel_probe(struct platform_device *pdev)
+ 						     &priv->ring[i].cdr,
+ 						     &priv->ring[i].rdr);
+ 		if (ret)
+-			goto err_clk;
++			goto err_reg_clk;
+ 
+ 		ring_irq = devm_kzalloc(dev, sizeof(*ring_irq), GFP_KERNEL);
+ 		if (!ring_irq) {
+ 			ret = -ENOMEM;
+-			goto err_clk;
++			goto err_reg_clk;
+ 		}
+ 
+ 		ring_irq->priv = priv;
+@@ -936,7 +950,7 @@ static int safexcel_probe(struct platform_device *pdev)
+ 						ring_irq);
+ 		if (irq < 0) {
+ 			ret = irq;
+-			goto err_clk;
++			goto err_reg_clk;
+ 		}
+ 
+ 		priv->ring[i].work_data.priv = priv;
+@@ -947,7 +961,7 @@ static int safexcel_probe(struct platform_device *pdev)
+ 		priv->ring[i].workqueue = create_singlethread_workqueue(wq_name);
+ 		if (!priv->ring[i].workqueue) {
+ 			ret = -ENOMEM;
+-			goto err_clk;
++			goto err_reg_clk;
+ 		}
+ 
+ 		priv->ring[i].requests = 0;
+@@ -968,18 +982,20 @@ static int safexcel_probe(struct platform_device *pdev)
+ 	ret = safexcel_hw_init(priv);
+ 	if (ret) {
+ 		dev_err(dev, "EIP h/w init failed (%d)\n", ret);
+-		goto err_clk;
++		goto err_reg_clk;
+ 	}
+ 
+ 	ret = safexcel_register_algorithms(priv);
+ 	if (ret) {
+ 		dev_err(dev, "Failed to register algorithms (%d)\n", ret);
+-		goto err_clk;
++		goto err_reg_clk;
+ 	}
+ 
+ 	return 0;
+ 
+-err_clk:
++err_reg_clk:
++	clk_disable_unprepare(priv->reg_clk);
++err_core_clk:
+ 	clk_disable_unprepare(priv->clk);
+ 	return ret;
+ }
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index d8dff65fc311..4efeb0251daf 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -525,6 +525,7 @@ struct safexcel_crypto_priv {
+ 	void __iomem *base;
+ 	struct device *dev;
+ 	struct clk *clk;
++	struct clk *reg_clk;
+ 	struct safexcel_config config;
+ 
+ 	enum safexcel_eip_version version;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90027-crypto-inside-secure-move-the-digest-to-the-request-.patch b/target/linux/mvebu/patches-4.14/90027-crypto-inside-secure-move-the-digest-to-the-request-.patch
new file mode 100644
index 0000000..79e9d44
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90027-crypto-inside-secure-move-the-digest-to-the-request-.patch
@@ -0,0 +1,161 @@
+From 1291b116682aa598cadfad67abfe55246c43c97e Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Mon, 19 Mar 2018 09:21:13 +0100
+Subject: [PATCH 027/126] crypto: inside-secure - move the digest to the
+ request context
+
+This patches moves the digest information from the transformation
+context to the request context. This fixes cases where HMAC init
+functions were called and override the digest value for a short period
+of time, as the HMAC init functions call the SHA init one which reset
+the value. This lead to a small percentage of HMAC being incorrectly
+computed under heavy load.
+
+Fixes: 1b44c5a60c13 ("crypto: inside-secure - add SafeXcel EIP197 crypto engine driver")
+Suggested-by: Ofer Heifetz <oferh@marvell.com>
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+[Ofer here did all the work, from seeing the issue to understanding the
+root cause. I only made the patch.]
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 30 ++++++++++++--------
+ 1 file changed, 18 insertions(+), 12 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index a7702da92b02..cfcae5e51b9d 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -21,7 +21,6 @@ struct safexcel_ahash_ctx {
+ 	struct safexcel_crypto_priv *priv;
+ 
+ 	u32 alg;
+-	u32 digest;
+ 
+ 	u32 ipad[SHA1_DIGEST_SIZE / sizeof(u32)];
+ 	u32 opad[SHA1_DIGEST_SIZE / sizeof(u32)];
+@@ -36,6 +35,8 @@ struct safexcel_ahash_req {
+ 	int nents;
+ 	dma_addr_t result_dma;
+ 
++	u32 digest;
++
+ 	u8 state_sz;    /* expected sate size, only set once */
+ 	u32 state[SHA256_DIGEST_SIZE / sizeof(u32)] __aligned(sizeof(u32));
+ 
+@@ -53,6 +54,8 @@ struct safexcel_ahash_export_state {
+ 	u64 len;
+ 	u64 processed;
+ 
++	u32 digest;
++
+ 	u32 state[SHA256_DIGEST_SIZE / sizeof(u32)];
+ 	u8 cache[SHA256_BLOCK_SIZE];
+ };
+@@ -86,9 +89,9 @@ static void safexcel_context_control(struct safexcel_ahash_ctx *ctx,
+ 
+ 	cdesc->control_data.control0 |= CONTEXT_CONTROL_TYPE_HASH_OUT;
+ 	cdesc->control_data.control0 |= ctx->alg;
+-	cdesc->control_data.control0 |= ctx->digest;
++	cdesc->control_data.control0 |= req->digest;
+ 
+-	if (ctx->digest == CONTEXT_CONTROL_DIGEST_PRECOMPUTED) {
++	if (req->digest == CONTEXT_CONTROL_DIGEST_PRECOMPUTED) {
+ 		if (req->processed) {
+ 			if (ctx->alg == CONTEXT_CONTROL_CRYPTO_ALG_SHA1)
+ 				cdesc->control_data.control0 |= CONTEXT_CONTROL_SIZE(6);
+@@ -116,7 +119,7 @@ static void safexcel_context_control(struct safexcel_ahash_ctx *ctx,
+ 			if (req->finish)
+ 				ctx->base.ctxr->data[i] = cpu_to_le32(req->processed / blocksize);
+ 		}
+-	} else if (ctx->digest == CONTEXT_CONTROL_DIGEST_HMAC) {
++	} else if (req->digest == CONTEXT_CONTROL_DIGEST_HMAC) {
+ 		cdesc->control_data.control0 |= CONTEXT_CONTROL_SIZE(10);
+ 
+ 		memcpy(ctx->base.ctxr->data, ctx->ipad, digestsize);
+@@ -545,7 +548,7 @@ static int safexcel_ahash_enqueue(struct ahash_request *areq)
+ 	if (ctx->base.ctxr) {
+ 		if (priv->version == EIP197 &&
+ 		    !ctx->base.needs_inv && req->processed &&
+-		    ctx->digest == CONTEXT_CONTROL_DIGEST_PRECOMPUTED)
++		    req->digest == CONTEXT_CONTROL_DIGEST_PRECOMPUTED)
+ 			/* We're still setting needs_inv here, even though it is
+ 			 * cleared right away, because the needs_inv flag can be
+ 			 * set in other functions and we want to keep the same
+@@ -580,7 +583,6 @@ static int safexcel_ahash_enqueue(struct ahash_request *areq)
+ 
+ static int safexcel_ahash_update(struct ahash_request *areq)
+ {
+-	struct safexcel_ahash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(areq));
+ 	struct safexcel_ahash_req *req = ahash_request_ctx(areq);
+ 	struct crypto_ahash *ahash = crypto_ahash_reqtfm(areq);
+ 
+@@ -596,7 +598,7 @@ static int safexcel_ahash_update(struct ahash_request *areq)
+ 	 * We're not doing partial updates when performing an hmac request.
+ 	 * Everything will be handled by the final() call.
+ 	 */
+-	if (ctx->digest == CONTEXT_CONTROL_DIGEST_HMAC)
++	if (req->digest == CONTEXT_CONTROL_DIGEST_HMAC)
+ 		return 0;
+ 
+ 	if (req->hmac)
+@@ -655,6 +657,8 @@ static int safexcel_ahash_export(struct ahash_request *areq, void *out)
+ 	export->len = req->len;
+ 	export->processed = req->processed;
+ 
++	export->digest = req->digest;
++
+ 	memcpy(export->state, req->state, req->state_sz);
+ 	memcpy(export->cache, req->cache, crypto_ahash_blocksize(ahash));
+ 
+@@ -675,6 +679,8 @@ static int safexcel_ahash_import(struct ahash_request *areq, const void *in)
+ 	req->len = export->len;
+ 	req->processed = export->processed;
+ 
++	req->digest = export->digest;
++
+ 	memcpy(req->cache, export->cache, crypto_ahash_blocksize(ahash));
+ 	memcpy(req->state, export->state, req->state_sz);
+ 
+@@ -711,7 +717,7 @@ static int safexcel_sha1_init(struct ahash_request *areq)
+ 	req->state[4] = SHA1_H4;
+ 
+ 	ctx->alg = CONTEXT_CONTROL_CRYPTO_ALG_SHA1;
+-	ctx->digest = CONTEXT_CONTROL_DIGEST_PRECOMPUTED;
++	req->digest = CONTEXT_CONTROL_DIGEST_PRECOMPUTED;
+ 	req->state_sz = SHA1_DIGEST_SIZE;
+ 
+ 	return 0;
+@@ -778,10 +784,10 @@ struct safexcel_alg_template safexcel_alg_sha1 = {
+ 
+ static int safexcel_hmac_sha1_init(struct ahash_request *areq)
+ {
+-	struct safexcel_ahash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(areq));
++	struct safexcel_ahash_req *req = ahash_request_ctx(areq);
+ 
+ 	safexcel_sha1_init(areq);
+-	ctx->digest = CONTEXT_CONTROL_DIGEST_HMAC;
++	req->digest = CONTEXT_CONTROL_DIGEST_HMAC;
+ 	return 0;
+ }
+ 
+@@ -1019,7 +1025,7 @@ static int safexcel_sha256_init(struct ahash_request *areq)
+ 	req->state[7] = SHA256_H7;
+ 
+ 	ctx->alg = CONTEXT_CONTROL_CRYPTO_ALG_SHA256;
+-	ctx->digest = CONTEXT_CONTROL_DIGEST_PRECOMPUTED;
++	req->digest = CONTEXT_CONTROL_DIGEST_PRECOMPUTED;
+ 	req->state_sz = SHA256_DIGEST_SIZE;
+ 
+ 	return 0;
+@@ -1081,7 +1087,7 @@ static int safexcel_sha224_init(struct ahash_request *areq)
+ 	req->state[7] = SHA224_H7;
+ 
+ 	ctx->alg = CONTEXT_CONTROL_CRYPTO_ALG_SHA224;
+-	ctx->digest = CONTEXT_CONTROL_DIGEST_PRECOMPUTED;
++	req->digest = CONTEXT_CONTROL_DIGEST_PRECOMPUTED;
+ 	req->state_sz = SHA256_DIGEST_SIZE;
+ 
+ 	return 0;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90028-crypto-inside-secure-fix-typo-s-allways-always-in-a-.patch b/target/linux/mvebu/patches-4.14/90028-crypto-inside-secure-fix-typo-s-allways-always-in-a-.patch
new file mode 100644
index 0000000..7dc4d0d
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90028-crypto-inside-secure-fix-typo-s-allways-always-in-a-.patch
@@ -0,0 +1,45 @@
+From 544f9477abccae5b8c252e93ed42eaccd23d8a31 Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Mon, 19 Mar 2018 09:21:14 +0100
+Subject: [PATCH 028/126] crypto: inside-secure - fix typo s/allways/always/ in
+ a define
+
+Small cosmetic patch fixing one typo in the
+EIP197_HIA_DSE_CFG_ALLWAYS_BUFFERABLE macro, it should be _ALWAYS_.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 2 +-
+ drivers/crypto/inside-secure/safexcel.h | 2 +-
+ 2 files changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index 2f68b4ed5500..cc9d2e9126b4 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -332,7 +332,7 @@ static int safexcel_hw_init(struct safexcel_crypto_priv *priv)
+ 	val = EIP197_HIA_DSE_CFG_DIS_DEBUG;
+ 	val |= EIP197_HIA_DxE_CFG_MIN_DATA_SIZE(7) | EIP197_HIA_DxE_CFG_MAX_DATA_SIZE(8);
+ 	val |= EIP197_HIA_DxE_CFG_DATA_CACHE_CTRL(WR_CACHE_3BITS);
+-	val |= EIP197_HIA_DSE_CFG_ALLWAYS_BUFFERABLE;
++	val |= EIP197_HIA_DSE_CFG_ALWAYS_BUFFERABLE;
+ 	/* FIXME: instability issues can occur for EIP97 but disabling it impact
+ 	 * performances.
+ 	 */
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 4efeb0251daf..9ca1654136e0 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -179,7 +179,7 @@
+ #define EIP197_HIA_DxE_CFG_MIN_DATA_SIZE(n)	((n) << 0)
+ #define EIP197_HIA_DxE_CFG_DATA_CACHE_CTRL(n)	(((n) & 0x7) << 4)
+ #define EIP197_HIA_DxE_CFG_MAX_DATA_SIZE(n)	((n) << 8)
+-#define EIP197_HIA_DSE_CFG_ALLWAYS_BUFFERABLE	GENMASK(15, 14)
++#define EIP197_HIA_DSE_CFG_ALWAYS_BUFFERABLE	GENMASK(15, 14)
+ #define EIP197_HIA_DxE_CFG_MIN_CTRL_SIZE(n)	((n) << 16)
+ #define EIP197_HIA_DxE_CFG_CTRL_CACHE_CTRL(n)	(((n) & 0x7) << 20)
+ #define EIP197_HIA_DxE_CFG_MAX_CTRL_SIZE(n)	((n) << 24)
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90029-crypto-inside-secure-fix-a-typo-in-a-register-name.patch b/target/linux/mvebu/patches-4.14/90029-crypto-inside-secure-fix-a-typo-in-a-register-name.patch
new file mode 100644
index 0000000..a47f710
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90029-crypto-inside-secure-fix-a-typo-in-a-register-name.patch
@@ -0,0 +1,45 @@
+From 891ec507fffb08982be12a4aba40eeccb9f883ae Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Mon, 19 Mar 2018 09:21:15 +0100
+Subject: [PATCH 029/126] crypto: inside-secure - fix a typo in a register name
+
+This patch fixes a typo in the EIP197_HIA_xDR_WR_CTRL_BUG register name,
+as it should be EIP197_HIA_xDR_WR_CTRL_BUF. This is a cosmetic only
+change.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c | 2 +-
+ drivers/crypto/inside-secure/safexcel.h | 2 +-
+ 2 files changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index cc9d2e9126b4..f7d7293de699 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -235,7 +235,7 @@ static int safexcel_hw_setup_rdesc_rings(struct safexcel_crypto_priv *priv)
+ 		/* Configure DMA tx control */
+ 		val = EIP197_HIA_xDR_CFG_WR_CACHE(WR_CACHE_3BITS);
+ 		val |= EIP197_HIA_xDR_CFG_RD_CACHE(RD_CACHE_3BITS);
+-		val |= EIP197_HIA_xDR_WR_RES_BUF | EIP197_HIA_xDR_WR_CTRL_BUG;
++		val |= EIP197_HIA_xDR_WR_RES_BUF | EIP197_HIA_xDR_WR_CTRL_BUF;
+ 		writel(val,
+ 		       EIP197_HIA_RDR(priv, i) + EIP197_HIA_xDR_DMA_CFG);
+ 
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 9ca1654136e0..295813920618 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -135,7 +135,7 @@
+ 
+ /* EIP197_HIA_xDR_DMA_CFG */
+ #define EIP197_HIA_xDR_WR_RES_BUF		BIT(22)
+-#define EIP197_HIA_xDR_WR_CTRL_BUG		BIT(23)
++#define EIP197_HIA_xDR_WR_CTRL_BUF		BIT(23)
+ #define EIP197_HIA_xDR_WR_OWN_BUF		BIT(24)
+ #define EIP197_HIA_xDR_CFG_WR_CACHE(n)		(((n) & 0x7) << 25)
+ #define EIP197_HIA_xDR_CFG_RD_CACHE(n)		(((n) & 0x7) << 29)
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90030-crypto-inside-secure-improve-the-send-error-path.patch b/target/linux/mvebu/patches-4.14/90030-crypto-inside-secure-improve-the-send-error-path.patch
new file mode 100644
index 0000000..6c9f7bd
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90030-crypto-inside-secure-improve-the-send-error-path.patch
@@ -0,0 +1,50 @@
+From 494622bc98b372c6bce8aeea1905924957490720 Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Mon, 19 Mar 2018 09:21:16 +0100
+Subject: [PATCH 030/126] crypto: inside-secure - improve the send error path
+
+This patch improves the send error path as it wasn't handling all error
+cases. A new label is added, and some of the goto are updated to point
+to the right labels, so that the code is more robust to errors.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 7 +++++--
+ 1 file changed, 5 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index cfcae5e51b9d..4ff3f7615b3d 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -281,7 +281,7 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 					   sglen, len, ctx->base.ctxr_dma);
+ 		if (IS_ERR(cdesc)) {
+ 			ret = PTR_ERR(cdesc);
+-			goto cdesc_rollback;
++			goto unmap_sg;
+ 		}
+ 		n_cdesc++;
+ 
+@@ -305,7 +305,7 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 					 DMA_FROM_DEVICE);
+ 	if (dma_mapping_error(priv->dev, req->result_dma)) {
+ 		ret = -EINVAL;
+-		goto cdesc_rollback;
++		goto unmap_sg;
+ 	}
+ 
+ 	/* Add a result descriptor */
+@@ -326,6 +326,9 @@ static int safexcel_ahash_send_req(struct crypto_async_request *async, int ring,
+ 	return 0;
+ 
+ unmap_result:
++	dma_unmap_single(priv->dev, req->result_dma, req->state_sz,
++			 DMA_FROM_DEVICE);
++unmap_sg:
+ 	dma_unmap_sg(priv->dev, areq->src, req->nents, DMA_TO_DEVICE);
+ cdesc_rollback:
+ 	for (i = 0; i < n_cdesc; i++)
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90031-crypto-inside-secure-do-not-access-buffers-mapped-to.patch b/target/linux/mvebu/patches-4.14/90031-crypto-inside-secure-do-not-access-buffers-mapped-to.patch
new file mode 100644
index 0000000..84ce86e
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90031-crypto-inside-secure-do-not-access-buffers-mapped-to.patch
@@ -0,0 +1,46 @@
+From 50f4fa52611cc3161e42874caea9d41df79d9718 Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Mon, 19 Mar 2018 09:21:17 +0100
+Subject: [PATCH 031/126] crypto: inside-secure - do not access buffers mapped
+ to the device
+
+This patches update the way the digest is copied from the state buffer
+to the result buffer, so that the copy only happen after the state
+buffer was DMA unmapped, as otherwise the buffer would be owned by the
+device.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 4ff3f7615b3d..573b12e4d9dd 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -156,10 +156,6 @@ static int safexcel_handle_req_result(struct safexcel_crypto_priv *priv, int rin
+ 	safexcel_complete(priv, ring);
+ 	spin_unlock_bh(&priv->ring[ring].egress_lock);
+ 
+-	if (sreq->finish)
+-		memcpy(areq->result, sreq->state,
+-		       crypto_ahash_digestsize(ahash));
+-
+ 	if (sreq->nents) {
+ 		dma_unmap_sg(priv->dev, areq->src, sreq->nents, DMA_TO_DEVICE);
+ 		sreq->nents = 0;
+@@ -177,6 +173,10 @@ static int safexcel_handle_req_result(struct safexcel_crypto_priv *priv, int rin
+ 		sreq->cache_dma = 0;
+ 	}
+ 
++	if (sreq->finish)
++		memcpy(areq->result, sreq->state,
++		       crypto_ahash_digestsize(ahash));
++
+ 	cache_len = sreq->len - sreq->processed;
+ 	if (cache_len)
+ 		memcpy(sreq->cache, sreq->cache_next, cache_len);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90032-crypto-inside-secure-improve-the-skcipher-token.patch b/target/linux/mvebu/patches-4.14/90032-crypto-inside-secure-improve-the-skcipher-token.patch
new file mode 100644
index 0000000..5b2a44c
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90032-crypto-inside-secure-improve-the-skcipher-token.patch
@@ -0,0 +1,36 @@
+From 2739e466552c871441625e4d3c801f2fc0efab2b Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Mon, 19 Mar 2018 09:21:18 +0100
+Subject: [PATCH 032/126] crypto: inside-secure - improve the skcipher token
+
+The token used for encryption and decryption of skcipher algorithms sets
+its stat field to "last packet". As it's a cipher only algorithm, there
+is not hash operation and thus the "last hash" bit should be set to tell
+the internal engine no hash operation should be performed.
+
+This does not fix a bug, but improves the token definition to follow
+exactly what's advised by the datasheet.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_cipher.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_cipher.c b/drivers/crypto/inside-secure/safexcel_cipher.c
+index 17a7725a6f6d..bafb60505fab 100644
+--- a/drivers/crypto/inside-secure/safexcel_cipher.c
++++ b/drivers/crypto/inside-secure/safexcel_cipher.c
+@@ -58,7 +58,8 @@ static void safexcel_cipher_token(struct safexcel_cipher_ctx *ctx,
+ 
+ 	token[0].opcode = EIP197_TOKEN_OPCODE_DIRECTION;
+ 	token[0].packet_length = length;
+-	token[0].stat = EIP197_TOKEN_STAT_LAST_PACKET;
++	token[0].stat = EIP197_TOKEN_STAT_LAST_PACKET |
++			EIP197_TOKEN_STAT_LAST_HASH;
+ 	token[0].instructions = EIP197_TOKEN_INS_LAST |
+ 				EIP197_TOKEN_INS_TYPE_CRYTO |
+ 				EIP197_TOKEN_INS_TYPE_OUTPUT;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90033-crypto-inside-secure-the-context-ipad-opad-should-us.patch b/target/linux/mvebu/patches-4.14/90033-crypto-inside-secure-the-context-ipad-opad-should-us.patch
new file mode 100644
index 0000000..875ed5b
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90033-crypto-inside-secure-the-context-ipad-opad-should-us.patch
@@ -0,0 +1,42 @@
+From ed9801b1f644ae6aa0763247b6a568db19aac31a Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Mon, 19 Mar 2018 09:21:19 +0100
+Subject: [PATCH 033/126] crypto: inside-secure - the context ipad/opad should
+ use the state sz
+
+This patches uses the state size of the algorithms instead of their
+digest size to copy the ipad and opad in the context. This doesn't fix
+anything as the state and digest size are the same for many algorithms,
+and for all the hmac currently supported by this driver. However
+hmac(sha224) use the sha224 hash function which has a different digest
+and state size. This commit prepares the addition of such algorithms.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel_hash.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 573b12e4d9dd..d152f2eb0271 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -120,11 +120,11 @@ static void safexcel_context_control(struct safexcel_ahash_ctx *ctx,
+ 				ctx->base.ctxr->data[i] = cpu_to_le32(req->processed / blocksize);
+ 		}
+ 	} else if (req->digest == CONTEXT_CONTROL_DIGEST_HMAC) {
+-		cdesc->control_data.control0 |= CONTEXT_CONTROL_SIZE(10);
++		cdesc->control_data.control0 |= CONTEXT_CONTROL_SIZE(2 * req->state_sz / sizeof(u32));
+ 
+-		memcpy(ctx->base.ctxr->data, ctx->ipad, digestsize);
+-		memcpy(ctx->base.ctxr->data + digestsize / sizeof(u32),
+-		       ctx->opad, digestsize);
++		memcpy(ctx->base.ctxr->data, ctx->ipad, req->state_sz);
++		memcpy(ctx->base.ctxr->data + req->state_sz / sizeof(u32),
++		       ctx->opad, req->state_sz);
+ 	}
+ }
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90034-crypto-inside-secure-hmac-sha256-support.patch b/target/linux/mvebu/patches-4.14/90034-crypto-inside-secure-hmac-sha256-support.patch
new file mode 100644
index 0000000..3d9db16
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90034-crypto-inside-secure-hmac-sha256-support.patch
@@ -0,0 +1,174 @@
+From 312b9bccbe46d8384a409f063380f4c46f632115 Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Mon, 19 Mar 2018 09:21:20 +0100
+Subject: [PATCH 034/126] crypto: inside-secure - hmac(sha256) support
+
+This patch adds the hmac(sha256) support to the Inside Secure
+cryptographic engine driver.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c      |  3 +-
+ drivers/crypto/inside-secure/safexcel.h      |  1 +
+ drivers/crypto/inside-secure/safexcel_hash.c | 80 ++++++++++++++++++--
+ 3 files changed, 75 insertions(+), 9 deletions(-)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index f7d7293de699..33595f41586f 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -354,7 +354,7 @@ static int safexcel_hw_init(struct safexcel_crypto_priv *priv)
+ 	val |= EIP197_PROTOCOL_ENCRYPT_ONLY | EIP197_PROTOCOL_HASH_ONLY;
+ 	val |= EIP197_ALG_AES_ECB | EIP197_ALG_AES_CBC;
+ 	val |= EIP197_ALG_SHA1 | EIP197_ALG_HMAC_SHA1;
+-	val |= EIP197_ALG_SHA2;
++	val |= EIP197_ALG_SHA2 | EIP197_ALG_HMAC_SHA2;
+ 	writel(val, EIP197_PE(priv) + EIP197_PE_EIP96_FUNCTION_EN);
+ 
+ 	/* Command Descriptor Rings prepare */
+@@ -768,6 +768,7 @@ static struct safexcel_alg_template *safexcel_algs[] = {
+ 	&safexcel_alg_sha224,
+ 	&safexcel_alg_sha256,
+ 	&safexcel_alg_hmac_sha1,
++	&safexcel_alg_hmac_sha256,
+ };
+ 
+ static int safexcel_register_algorithms(struct safexcel_crypto_priv *priv)
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 295813920618..99e0f32452ff 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -633,5 +633,6 @@ extern struct safexcel_alg_template safexcel_alg_sha1;
+ extern struct safexcel_alg_template safexcel_alg_sha224;
+ extern struct safexcel_alg_template safexcel_alg_sha256;
+ extern struct safexcel_alg_template safexcel_alg_hmac_sha1;
++extern struct safexcel_alg_template safexcel_alg_hmac_sha256;
+ 
+ #endif
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index d152f2eb0271..2917a902596d 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -22,8 +22,8 @@ struct safexcel_ahash_ctx {
+ 
+ 	u32 alg;
+ 
+-	u32 ipad[SHA1_DIGEST_SIZE / sizeof(u32)];
+-	u32 opad[SHA1_DIGEST_SIZE / sizeof(u32)];
++	u32 ipad[SHA256_DIGEST_SIZE / sizeof(u32)];
++	u32 opad[SHA256_DIGEST_SIZE / sizeof(u32)];
+ };
+ 
+ struct safexcel_ahash_req {
+@@ -953,20 +953,21 @@ static int safexcel_hmac_setkey(const char *alg, const u8 *key,
+ 	return ret;
+ }
+ 
+-static int safexcel_hmac_sha1_setkey(struct crypto_ahash *tfm, const u8 *key,
+-				     unsigned int keylen)
++static int safexcel_hmac_alg_setkey(struct crypto_ahash *tfm, const u8 *key,
++				    unsigned int keylen, const char *alg,
++				    unsigned int state_sz)
+ {
+ 	struct safexcel_ahash_ctx *ctx = crypto_tfm_ctx(crypto_ahash_tfm(tfm));
+ 	struct safexcel_crypto_priv *priv = ctx->priv;
+ 	struct safexcel_ahash_export_state istate, ostate;
+ 	int ret, i;
+ 
+-	ret = safexcel_hmac_setkey("safexcel-sha1", key, keylen, &istate, &ostate);
++	ret = safexcel_hmac_setkey(alg, key, keylen, &istate, &ostate);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (priv->version == EIP197 && ctx->base.ctxr) {
+-		for (i = 0; i < SHA1_DIGEST_SIZE / sizeof(u32); i++) {
++		for (i = 0; i < state_sz / sizeof(u32); i++) {
+ 			if (ctx->ipad[i] != le32_to_cpu(istate.state[i]) ||
+ 			    ctx->opad[i] != le32_to_cpu(ostate.state[i])) {
+ 				ctx->base.needs_inv = true;
+@@ -975,12 +976,19 @@ static int safexcel_hmac_sha1_setkey(struct crypto_ahash *tfm, const u8 *key,
+ 		}
+ 	}
+ 
+-	memcpy(ctx->ipad, &istate.state, SHA1_DIGEST_SIZE);
+-	memcpy(ctx->opad, &ostate.state, SHA1_DIGEST_SIZE);
++	memcpy(ctx->ipad, &istate.state, state_sz);
++	memcpy(ctx->opad, &ostate.state, state_sz);
+ 
+ 	return 0;
+ }
+ 
++static int safexcel_hmac_sha1_setkey(struct crypto_ahash *tfm, const u8 *key,
++				     unsigned int keylen)
++{
++	return safexcel_hmac_alg_setkey(tfm, key, keylen, "safexcel-sha1",
++					SHA1_DIGEST_SIZE);
++}
++
+ struct safexcel_alg_template safexcel_alg_hmac_sha1 = {
+ 	.type = SAFEXCEL_ALG_TYPE_AHASH,
+ 	.alg.ahash = {
+@@ -1134,3 +1142,59 @@ struct safexcel_alg_template safexcel_alg_sha224 = {
+ 		},
+ 	},
+ };
++
++static int safexcel_hmac_sha256_setkey(struct crypto_ahash *tfm, const u8 *key,
++				     unsigned int keylen)
++{
++	return safexcel_hmac_alg_setkey(tfm, key, keylen, "safexcel-sha256",
++					SHA256_DIGEST_SIZE);
++}
++
++static int safexcel_hmac_sha256_init(struct ahash_request *areq)
++{
++	struct safexcel_ahash_req *req = ahash_request_ctx(areq);
++
++	safexcel_sha256_init(areq);
++	req->digest = CONTEXT_CONTROL_DIGEST_HMAC;
++	return 0;
++}
++
++static int safexcel_hmac_sha256_digest(struct ahash_request *areq)
++{
++	int ret = safexcel_hmac_sha256_init(areq);
++
++	if (ret)
++		return ret;
++
++	return safexcel_ahash_finup(areq);
++}
++
++struct safexcel_alg_template safexcel_alg_hmac_sha256 = {
++	.type = SAFEXCEL_ALG_TYPE_AHASH,
++	.alg.ahash = {
++		.init = safexcel_hmac_sha256_init,
++		.update = safexcel_ahash_update,
++		.final = safexcel_ahash_final,
++		.finup = safexcel_ahash_finup,
++		.digest = safexcel_hmac_sha256_digest,
++		.setkey = safexcel_hmac_sha256_setkey,
++		.export = safexcel_ahash_export,
++		.import = safexcel_ahash_import,
++		.halg = {
++			.digestsize = SHA256_DIGEST_SIZE,
++			.statesize = sizeof(struct safexcel_ahash_export_state),
++			.base = {
++				.cra_name = "hmac(sha256)",
++				.cra_driver_name = "safexcel-hmac-sha256",
++				.cra_priority = 300,
++				.cra_flags = CRYPTO_ALG_ASYNC |
++					     CRYPTO_ALG_KERN_DRIVER_ONLY,
++				.cra_blocksize = SHA256_BLOCK_SIZE,
++				.cra_ctxsize = sizeof(struct safexcel_ahash_ctx),
++				.cra_init = safexcel_ahash_cra_init,
++				.cra_exit = safexcel_ahash_cra_exit,
++				.cra_module = THIS_MODULE,
++			},
++		},
++	},
++};
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90035-crypto-inside-secure-hmac-sha224-support.patch b/target/linux/mvebu/patches-4.14/90035-crypto-inside-secure-hmac-sha224-support.patch
new file mode 100644
index 0000000..d2d7f13
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90035-crypto-inside-secure-hmac-sha224-support.patch
@@ -0,0 +1,110 @@
+From 1a708614467fb5376e67e1540eacd9b156fd776d Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@bootlin.com>
+Date: Mon, 19 Mar 2018 09:21:21 +0100
+Subject: [PATCH 035/126] crypto: inside-secure - hmac(sha224) support
+
+This patch adds the hmac(sha224) support to the Inside Secure
+cryptographic engine driver.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@bootlin.com>
+Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
+---
+ drivers/crypto/inside-secure/safexcel.c      |  1 +
+ drivers/crypto/inside-secure/safexcel.h      |  1 +
+ drivers/crypto/inside-secure/safexcel_hash.c | 56 ++++++++++++++++++++
+ 3 files changed, 58 insertions(+)
+
+diff --git a/drivers/crypto/inside-secure/safexcel.c b/drivers/crypto/inside-secure/safexcel.c
+index 33595f41586f..d4a81be0d7d2 100644
+--- a/drivers/crypto/inside-secure/safexcel.c
++++ b/drivers/crypto/inside-secure/safexcel.c
+@@ -768,6 +768,7 @@ static struct safexcel_alg_template *safexcel_algs[] = {
+ 	&safexcel_alg_sha224,
+ 	&safexcel_alg_sha256,
+ 	&safexcel_alg_hmac_sha1,
++	&safexcel_alg_hmac_sha224,
+ 	&safexcel_alg_hmac_sha256,
+ };
+ 
+diff --git a/drivers/crypto/inside-secure/safexcel.h b/drivers/crypto/inside-secure/safexcel.h
+index 99e0f32452ff..b470a849721f 100644
+--- a/drivers/crypto/inside-secure/safexcel.h
++++ b/drivers/crypto/inside-secure/safexcel.h
+@@ -633,6 +633,7 @@ extern struct safexcel_alg_template safexcel_alg_sha1;
+ extern struct safexcel_alg_template safexcel_alg_sha224;
+ extern struct safexcel_alg_template safexcel_alg_sha256;
+ extern struct safexcel_alg_template safexcel_alg_hmac_sha1;
++extern struct safexcel_alg_template safexcel_alg_hmac_sha224;
+ extern struct safexcel_alg_template safexcel_alg_hmac_sha256;
+ 
+ #endif
+diff --git a/drivers/crypto/inside-secure/safexcel_hash.c b/drivers/crypto/inside-secure/safexcel_hash.c
+index 2917a902596d..d9ddf776c799 100644
+--- a/drivers/crypto/inside-secure/safexcel_hash.c
++++ b/drivers/crypto/inside-secure/safexcel_hash.c
+@@ -1143,6 +1143,62 @@ struct safexcel_alg_template safexcel_alg_sha224 = {
+ 	},
+ };
+ 
++static int safexcel_hmac_sha224_setkey(struct crypto_ahash *tfm, const u8 *key,
++				       unsigned int keylen)
++{
++	return safexcel_hmac_alg_setkey(tfm, key, keylen, "safexcel-sha224",
++					SHA256_DIGEST_SIZE);
++}
++
++static int safexcel_hmac_sha224_init(struct ahash_request *areq)
++{
++	struct safexcel_ahash_req *req = ahash_request_ctx(areq);
++
++	safexcel_sha224_init(areq);
++	req->digest = CONTEXT_CONTROL_DIGEST_HMAC;
++	return 0;
++}
++
++static int safexcel_hmac_sha224_digest(struct ahash_request *areq)
++{
++	int ret = safexcel_hmac_sha224_init(areq);
++
++	if (ret)
++		return ret;
++
++	return safexcel_ahash_finup(areq);
++}
++
++struct safexcel_alg_template safexcel_alg_hmac_sha224 = {
++	.type = SAFEXCEL_ALG_TYPE_AHASH,
++	.alg.ahash = {
++		.init = safexcel_hmac_sha224_init,
++		.update = safexcel_ahash_update,
++		.final = safexcel_ahash_final,
++		.finup = safexcel_ahash_finup,
++		.digest = safexcel_hmac_sha224_digest,
++		.setkey = safexcel_hmac_sha224_setkey,
++		.export = safexcel_ahash_export,
++		.import = safexcel_ahash_import,
++		.halg = {
++			.digestsize = SHA224_DIGEST_SIZE,
++			.statesize = sizeof(struct safexcel_ahash_export_state),
++			.base = {
++				.cra_name = "hmac(sha224)",
++				.cra_driver_name = "safexcel-hmac-sha224",
++				.cra_priority = 300,
++				.cra_flags = CRYPTO_ALG_ASYNC |
++					     CRYPTO_ALG_KERN_DRIVER_ONLY,
++				.cra_blocksize = SHA224_BLOCK_SIZE,
++				.cra_ctxsize = sizeof(struct safexcel_ahash_ctx),
++				.cra_init = safexcel_ahash_cra_init,
++				.cra_exit = safexcel_ahash_cra_exit,
++				.cra_module = THIS_MODULE,
++			},
++		},
++	},
++};
++
+ static int safexcel_hmac_sha256_setkey(struct crypto_ahash *tfm, const u8 *key,
+ 				     unsigned int keylen)
+ {
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90036-arm64-dts-marvell-armada-37xx-add-a-crypto-node.patch b/target/linux/mvebu/patches-4.14/90036-arm64-dts-marvell-armada-37xx-add-a-crypto-node.patch
new file mode 100644
index 0000000..4d36ec8
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90036-arm64-dts-marvell-armada-37xx-add-a-crypto-node.patch
@@ -0,0 +1,42 @@
+From f2422e411550f9809e416ff799af518c5e3149d4 Mon Sep 17 00:00:00 2001
+From: Antoine Tenart <antoine.tenart@free-electrons.com>
+Date: Tue, 26 Dec 2017 17:16:53 +0100
+Subject: [PATCH 036/126] arm64: dts: marvell: armada-37xx: add a crypto node
+
+This patch adds a crypto node describing the EIP97 engine found in
+Armada 37xx SoCs. The cryptographic engine is enabled by default.
+
+Signed-off-by: Antoine Tenart <antoine.tenart@free-electrons.com>
+Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+---
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 14 ++++++++++++++
+ 1 file changed, 14 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+index 8c0cf7efac65..6842cae5b35b 100644
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -293,6 +293,20 @@
+ 				};
+ 			};
+ 
++			crypto: crypto@90000 {
++				compatible = "inside-secure,safexcel-eip97";
++				reg = <0x90000 0x20000>;
++				interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>,
++					     <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>,
++					     <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>,
++					     <GIC_SPI 22 IRQ_TYPE_LEVEL_HIGH>,
++					     <GIC_SPI 23 IRQ_TYPE_LEVEL_HIGH>,
++					     <GIC_SPI 24 IRQ_TYPE_LEVEL_HIGH>;
++				interrupt-names = "mem", "ring0", "ring1",
++						  "ring2", "ring3", "eip";
++				clocks = <&nb_periph_clk 15>;
++			};
++
+ 			sdhci1: sdhci@d0000 {
+ 				compatible = "marvell,armada-3700-sdhci",
+ 					     "marvell,sdhci-xenon";
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/300-mvneta-tx-queue-workaround.patch b/target/linux/mvebu/patches-4.14/90038-net-mvneta-tx-queue-workaround.patch
similarity index 64%
rename from target/linux/mvebu/patches-4.14/300-mvneta-tx-queue-workaround.patch
rename to target/linux/mvebu/patches-4.14/90038-net-mvneta-tx-queue-workaround.patch
index f21f808..e942485 100644
--- a/target/linux/mvebu/patches-4.14/300-mvneta-tx-queue-workaround.patch
+++ b/target/linux/mvebu/patches-4.14/90038-net-mvneta-tx-queue-workaround.patch
@@ -1,3 +1,8 @@
+From 7c48344dd635ce39cc4b00a2362b7e5133e5ea01 Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Wed, 16 Sep 2015 21:27:10 +0100
+Subject: [PATCH 038/126] net: mvneta: tx queue workaround
+
 The hardware queue scheduling is apparently configured with fixed
 priorities, which creates a nasty fairness issue where traffic from one
 CPU can starve traffic from all other CPUs.
@@ -7,9 +12,14 @@ until this issue is fixed properly.
 
 Signed-off-by: Felix Fietkau <nbd@nbd.name>
 ---
+ drivers/net/ethernet/marvell/mvneta.c | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index f76cbefeb3c7..0cf505c10c03 100644
 --- a/drivers/net/ethernet/marvell/mvneta.c
 +++ b/drivers/net/ethernet/marvell/mvneta.c
-@@ -3961,6 +3961,15 @@ static int mvneta_ethtool_set_wol(struct
+@@ -3961,6 +3961,15 @@ static int mvneta_ethtool_set_wol(struct net_device *dev,
  	return ret;
  }
  
@@ -25,7 +35,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  static const struct net_device_ops mvneta_netdev_ops = {
  	.ndo_open            = mvneta_open,
  	.ndo_stop            = mvneta_stop,
-@@ -3971,6 +3980,7 @@ static const struct net_device_ops mvnet
+@@ -3971,6 +3980,7 @@ static const struct net_device_ops mvneta_netdev_ops = {
  	.ndo_fix_features    = mvneta_fix_features,
  	.ndo_get_stats64     = mvneta_get_stats64,
  	.ndo_do_ioctl        = mvneta_ioctl,
@@ -33,3 +43,6 @@ Signed-off-by: Felix Fietkau <nbd@nbd.name>
  };
  
  static const struct ethtool_ops mvneta_eth_tool_ops = {
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/404-net-mvneta-hack-fix-phy_interface.patch b/target/linux/mvebu/patches-4.14/90040-net-mvneta-hack-fix-phy_interface.patch
similarity index 65%
rename from target/linux/mvebu/patches-4.14/404-net-mvneta-hack-fix-phy_interface.patch
rename to target/linux/mvebu/patches-4.14/90040-net-mvneta-hack-fix-phy_interface.patch
index 906c163..6cc9256 100644
--- a/target/linux/mvebu/patches-4.14/404-net-mvneta-hack-fix-phy_interface.patch
+++ b/target/linux/mvebu/patches-4.14/90040-net-mvneta-hack-fix-phy_interface.patch
@@ -1,13 +1,15 @@
-From acdfcc7ef78c46baca1439a1cac5b73008abc672 Mon Sep 17 00:00:00 2001
+From 2fbe986761151476bdb8916c570271c5cee30fb8 Mon Sep 17 00:00:00 2001
 From: Russell King <rmk+kernel@armlinux.org.uk>
 Date: Tue, 16 May 2017 11:55:58 +0100
-Subject: net: mvneta: hack fix phy_interface
+Subject: [PATCH 040/126] net: mvneta: hack fix phy_interface
 
 Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
 ---
  drivers/net/ethernet/marvell/mvneta.c | 2 ++
  1 file changed, 2 insertions(+)
 
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index 5c00869252fa..a2dfb1f93afc 100644
 --- a/drivers/net/ethernet/marvell/mvneta.c
 +++ b/drivers/net/ethernet/marvell/mvneta.c
 @@ -427,6 +427,7 @@ struct mvneta_port {
@@ -18,7 +20,7 @@ Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
  	struct device_node *dn;
  	unsigned int tx_csum_limit;
  	struct phylink *phylink;
-@@ -4315,6 +4316,7 @@ static int mvneta_probe(struct platform_
+@@ -4315,6 +4316,7 @@ static int mvneta_probe(struct platform_device *pdev)
  
  	pp = netdev_priv(dev);
  	spin_lock_init(&pp->lock);
@@ -26,3 +28,6 @@ Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
  	pp->dn = dn;
  
  	pp->rxq_def = rxq_def;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/405-net-mvneta-disable-MVNETA_CAUSE_PSC_SYNC_CHANGE-inte.patch b/target/linux/mvebu/patches-4.14/90041-net-mvneta-disable-MVNETA_CAUSE_PSC_SYNC_CHANGE-inte.patch
similarity index 72%
rename from target/linux/mvebu/patches-4.14/405-net-mvneta-disable-MVNETA_CAUSE_PSC_SYNC_CHANGE-inte.patch
rename to target/linux/mvebu/patches-4.14/90041-net-mvneta-disable-MVNETA_CAUSE_PSC_SYNC_CHANGE-inte.patch
index 7d02b0a..6739589 100644
--- a/target/linux/mvebu/patches-4.14/405-net-mvneta-disable-MVNETA_CAUSE_PSC_SYNC_CHANGE-inte.patch
+++ b/target/linux/mvebu/patches-4.14/90041-net-mvneta-disable-MVNETA_CAUSE_PSC_SYNC_CHANGE-inte.patch
@@ -1,7 +1,8 @@
-From fde9e742a47606110232b7464608b6f9c0510938 Mon Sep 17 00:00:00 2001
+From b3f1e8b338ebba0b3b4dd96e68940c25d3d60bb3 Mon Sep 17 00:00:00 2001
 From: Russell King <rmk+kernel@armlinux.org.uk>
 Date: Sat, 24 Dec 2016 10:27:08 +0000
-Subject: net: mvneta: disable MVNETA_CAUSE_PSC_SYNC_CHANGE interrupt
+Subject: [PATCH 041/126] net: mvneta: disable MVNETA_CAUSE_PSC_SYNC_CHANGE
+ interrupt
 
 The PSC sync change interrupt can fire multiple times while the link is
 down.  As this isn't information we make use of, it's pointless having
@@ -12,9 +13,11 @@ Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
  drivers/net/ethernet/marvell/mvneta.c | 12 ++++--------
  1 file changed, 4 insertions(+), 8 deletions(-)
 
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index a2dfb1f93afc..4cfffadfcac1 100644
 --- a/drivers/net/ethernet/marvell/mvneta.c
 +++ b/drivers/net/ethernet/marvell/mvneta.c
-@@ -2705,8 +2705,7 @@ static int mvneta_poll(struct napi_struc
+@@ -2705,8 +2705,7 @@ static int mvneta_poll(struct napi_struct *napi, int budget)
  		mvreg_write(pp, MVNETA_INTR_MISC_CAUSE, 0);
  
  		if (cause_misc & (MVNETA_CAUSE_PHY_STATUS_CHANGE |
@@ -24,7 +27,7 @@ Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
  			mvneta_link_change(pp);
  	}
  
-@@ -3045,8 +3044,7 @@ static void mvneta_start_dev(struct mvne
+@@ -3045,8 +3044,7 @@ static void mvneta_start_dev(struct mvneta_port *pp)
  
  	mvreg_write(pp, MVNETA_INTR_MISC_MASK,
  		    MVNETA_CAUSE_PHY_STATUS_CHANGE |
@@ -34,7 +37,7 @@ Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
  
  	phylink_start(pp->phylink);
  	netif_tx_start_all_queues(pp->dev);
-@@ -3542,8 +3540,7 @@ static int mvneta_cpu_online(unsigned in
+@@ -3542,8 +3540,7 @@ static int mvneta_cpu_online(unsigned int cpu, struct hlist_node *node)
  	on_each_cpu(mvneta_percpu_unmask_interrupt, pp, true);
  	mvreg_write(pp, MVNETA_INTR_MISC_MASK,
  		    MVNETA_CAUSE_PHY_STATUS_CHANGE |
@@ -44,7 +47,7 @@ Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
  	netif_tx_start_all_queues(pp->dev);
  	spin_unlock(&pp->lock);
  	return 0;
-@@ -3584,8 +3581,7 @@ static int mvneta_cpu_dead(unsigned int
+@@ -3584,8 +3581,7 @@ static int mvneta_cpu_dead(unsigned int cpu, struct hlist_node *node)
  	on_each_cpu(mvneta_percpu_unmask_interrupt, pp, true);
  	mvreg_write(pp, MVNETA_INTR_MISC_MASK,
  		    MVNETA_CAUSE_PHY_STATUS_CHANGE |
@@ -54,3 +57,6 @@ Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
  	netif_tx_start_all_queues(pp->dev);
  	return 0;
  }
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/406-net-mvneta-add-module-EEPROM-reading-support.patch b/target/linux/mvebu/patches-4.14/90042-net-mvneta-add-module-EEPROM-reading-support.patch
similarity index 74%
rename from target/linux/mvebu/patches-4.14/406-net-mvneta-add-module-EEPROM-reading-support.patch
rename to target/linux/mvebu/patches-4.14/90042-net-mvneta-add-module-EEPROM-reading-support.patch
index 39eb33a..98ce4a7 100644
--- a/target/linux/mvebu/patches-4.14/406-net-mvneta-add-module-EEPROM-reading-support.patch
+++ b/target/linux/mvebu/patches-4.14/90042-net-mvneta-add-module-EEPROM-reading-support.patch
@@ -1,16 +1,18 @@
-From 2ff039aa4462c2104c210b7cf39691c612de8214 Mon Sep 17 00:00:00 2001
+From f376d7e4fac76eb64645aef4022657056ccc6879 Mon Sep 17 00:00:00 2001
 From: Russell King <rmk+kernel@arm.linux.org.uk>
 Date: Thu, 1 Oct 2015 23:32:39 +0100
-Subject: net: mvneta: add module EEPROM reading support
+Subject: [PATCH 042/126] net: mvneta: add module EEPROM reading support
 
 Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
 ---
  drivers/net/ethernet/marvell/mvneta.c | 18 ++++++++++++++++++
  1 file changed, 18 insertions(+)
 
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index 4cfffadfcac1..34a8a7c70bdd 100644
 --- a/drivers/net/ethernet/marvell/mvneta.c
 +++ b/drivers/net/ethernet/marvell/mvneta.c
-@@ -4045,6 +4045,22 @@ static int mvneta_ethtool_set_wol(struct
+@@ -4045,6 +4045,22 @@ static int mvneta_ethtool_set_wol(struct net_device *dev,
  	return ret;
  }
  
@@ -33,7 +35,7 @@ Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
  static int mvneta_ethtool_get_eee(struct net_device *dev,
  				  struct ethtool_eee *eee)
  {
-@@ -4129,6 +4145,8 @@ static const struct ethtool_ops mvneta_e
+@@ -4129,6 +4145,8 @@ static const struct ethtool_ops mvneta_eth_tool_ops = {
  	.set_link_ksettings = mvneta_ethtool_set_link_ksettings,
  	.get_wol        = mvneta_ethtool_get_wol,
  	.set_wol        = mvneta_ethtool_set_wol,
@@ -42,3 +44,6 @@ Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
  	.get_eee	= mvneta_ethtool_get_eee,
  	.set_eee	= mvneta_ethtool_set_eee,
  };
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/407-phy-fixed-phy-remove-fixed_phy_update_state.patch b/target/linux/mvebu/patches-4.14/90043-phy-fixed-phy-remove-fixed_phy_update_state.patch
similarity index 78%
rename from target/linux/mvebu/patches-4.14/407-phy-fixed-phy-remove-fixed_phy_update_state.patch
rename to target/linux/mvebu/patches-4.14/90043-phy-fixed-phy-remove-fixed_phy_update_state.patch
index 71c2f45..e04204a 100644
--- a/target/linux/mvebu/patches-4.14/407-phy-fixed-phy-remove-fixed_phy_update_state.patch
+++ b/target/linux/mvebu/patches-4.14/90043-phy-fixed-phy-remove-fixed_phy_update_state.patch
@@ -1,7 +1,7 @@
-From 774ce2eda0a929f79ee398ba6d2d13fd406f31c4 Mon Sep 17 00:00:00 2001
+From 7acb1508ff0fcfe1420874f49ae0a2610a3ad4c2 Mon Sep 17 00:00:00 2001
 From: Russell King <rmk+kernel@arm.linux.org.uk>
 Date: Fri, 2 Oct 2015 22:46:54 +0100
-Subject: phy: fixed-phy: remove fixed_phy_update_state()
+Subject: [PATCH 043/126] phy: fixed-phy: remove fixed_phy_update_state()
 
 mvneta is the only user of fixed_phy_update_state(), which has been
 converted to use phylink instead.  Remove fixed_phy_update_state().
@@ -13,9 +13,11 @@ Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
  include/linux/phy_fixed.h   |  9 ---------
  2 files changed, 40 deletions(-)
 
+diff --git a/drivers/net/phy/fixed_phy.c b/drivers/net/phy/fixed_phy.c
+index eb5167210681..001fe1df7557 100644
 --- a/drivers/net/phy/fixed_phy.c
 +++ b/drivers/net/phy/fixed_phy.c
-@@ -115,37 +115,6 @@ int fixed_phy_set_link_update(struct phy
+@@ -115,37 +115,6 @@ int fixed_phy_set_link_update(struct phy_device *phydev,
  }
  EXPORT_SYMBOL_GPL(fixed_phy_set_link_update);
  
@@ -53,9 +55,11 @@ Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
  int fixed_phy_add(unsigned int irq, int phy_addr,
  		  struct fixed_phy_status *status,
  		  int link_gpio)
+diff --git a/include/linux/phy_fixed.h b/include/linux/phy_fixed.h
+index cf6392de6eb0..ee54453a40a0 100644
 --- a/include/linux/phy_fixed.h
 +++ b/include/linux/phy_fixed.h
-@@ -24,9 +24,6 @@ extern void fixed_phy_unregister(struct
+@@ -24,9 +24,6 @@ extern void fixed_phy_unregister(struct phy_device *phydev);
  extern int fixed_phy_set_link_update(struct phy_device *phydev,
  			int (*link_update)(struct net_device *,
  					   struct fixed_phy_status *));
@@ -65,7 +69,7 @@ Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
  #else
  static inline int fixed_phy_add(unsigned int irq, int phy_id,
  				struct fixed_phy_status *status,
-@@ -50,12 +47,6 @@ static inline int fixed_phy_set_link_upd
+@@ -50,12 +47,6 @@ static inline int fixed_phy_set_link_update(struct phy_device *phydev,
  {
  	return -ENODEV;
  }
@@ -78,3 +82,6 @@ Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
  #endif /* CONFIG_FIXED_PHY */
  
  #endif /* __PHY_FIXED_H */
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/408-sfp-move-module-eeprom-ethtool-access-into-netdev-co.patch b/target/linux/mvebu/patches-4.14/90044-sfp-move-module-eeprom-ethtool-access-into-netdev-co.patch
similarity index 78%
rename from target/linux/mvebu/patches-4.14/408-sfp-move-module-eeprom-ethtool-access-into-netdev-co.patch
rename to target/linux/mvebu/patches-4.14/90044-sfp-move-module-eeprom-ethtool-access-into-netdev-co.patch
index 3fd07d2..79d34e6 100644
--- a/target/linux/mvebu/patches-4.14/408-sfp-move-module-eeprom-ethtool-access-into-netdev-co.patch
+++ b/target/linux/mvebu/patches-4.14/90044-sfp-move-module-eeprom-ethtool-access-into-netdev-co.patch
@@ -1,21 +1,24 @@
-From c47beb7e3f8575dfd7d58240a72c4e4e66ce5449 Mon Sep 17 00:00:00 2001
+From 4ff8848a854fa598f1718383dafb6bd7f6f442f4 Mon Sep 17 00:00:00 2001
 From: Russell King <rmk+kernel@armlinux.org.uk>
 Date: Fri, 14 Apr 2017 15:26:32 +0100
-Subject: sfp: move module eeprom ethtool access into netdev core ethtool
+Subject: [PATCH 044/126] sfp: move module eeprom ethtool access into netdev
+ core ethtool
 
 Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
 ---
- drivers/net/ethernet/marvell/mvneta.c | 18 ------------------
- drivers/net/phy/phylink.c             | 28 ----------------------------
+ drivers/net/ethernet/marvell/mvneta.c | 18 -----------------
+ drivers/net/phy/phylink.c             | 28 ---------------------------
  drivers/net/phy/sfp-bus.c             |  6 ++----
  include/linux/netdevice.h             |  2 ++
  include/linux/phylink.h               |  3 ---
  net/core/ethtool.c                    |  7 +++++++
  6 files changed, 11 insertions(+), 53 deletions(-)
 
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index 34a8a7c70bdd..4cfffadfcac1 100644
 --- a/drivers/net/ethernet/marvell/mvneta.c
 +++ b/drivers/net/ethernet/marvell/mvneta.c
-@@ -4045,22 +4045,6 @@ static int mvneta_ethtool_set_wol(struct
+@@ -4045,22 +4045,6 @@ static int mvneta_ethtool_set_wol(struct net_device *dev,
  	return ret;
  }
  
@@ -38,7 +41,7 @@ Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
  static int mvneta_ethtool_get_eee(struct net_device *dev,
  				  struct ethtool_eee *eee)
  {
-@@ -4145,8 +4129,6 @@ static const struct ethtool_ops mvneta_e
+@@ -4145,8 +4129,6 @@ static const struct ethtool_ops mvneta_eth_tool_ops = {
  	.set_link_ksettings = mvneta_ethtool_set_link_ksettings,
  	.get_wol        = mvneta_ethtool_get_wol,
  	.set_wol        = mvneta_ethtool_set_wol,
@@ -47,9 +50,11 @@ Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
  	.get_eee	= mvneta_ethtool_get_eee,
  	.set_eee	= mvneta_ethtool_set_eee,
  };
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 5bfc961e53c9..fd0944c209c2 100644
 --- a/drivers/net/phy/phylink.c
 +++ b/drivers/net/phy/phylink.c
-@@ -1058,34 +1058,6 @@ int phylink_ethtool_set_pauseparam(struc
+@@ -1058,34 +1058,6 @@ int phylink_ethtool_set_pauseparam(struct phylink *pl,
  }
  EXPORT_SYMBOL_GPL(phylink_ethtool_set_pauseparam);
  
@@ -84,9 +89,11 @@ Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
  int phylink_init_eee(struct phylink *pl, bool clk_stop_enable)
  {
  	int ret = -EPROTONOSUPPORT;
+diff --git a/drivers/net/phy/sfp-bus.c b/drivers/net/phy/sfp-bus.c
+index be6016e21d87..3a0a05bbd45d 100644
 --- a/drivers/net/phy/sfp-bus.c
 +++ b/drivers/net/phy/sfp-bus.c
-@@ -279,6 +279,7 @@ static int sfp_register_bus(struct sfp_b
+@@ -279,6 +279,7 @@ static int sfp_register_bus(struct sfp_bus *bus)
  	bus->socket_ops->attach(bus->sfp);
  	if (bus->started)
  		bus->socket_ops->start(bus->sfp);
@@ -94,7 +101,7 @@ Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
  	bus->registered = true;
  	return 0;
  }
-@@ -294,14 +295,13 @@ static void sfp_unregister_bus(struct sf
+@@ -294,14 +295,13 @@ static void sfp_unregister_bus(struct sfp_bus *bus)
  		if (bus->phydev && ops && ops->disconnect_phy)
  			ops->disconnect_phy(bus->upstream);
  	}
@@ -119,6 +126,8 @@ Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
  	return bus->socket_ops->module_eeprom(bus->sfp, ee, data);
  }
  EXPORT_SYMBOL_GPL(sfp_get_module_eeprom);
+diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
+index 40b830d55fe5..0b1c130145f0 100644
 --- a/include/linux/netdevice.h
 +++ b/include/linux/netdevice.h
 @@ -57,6 +57,7 @@ struct device;
@@ -129,7 +138,7 @@ Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
  /* 802.11 specific */
  struct wireless_dev;
  /* 802.15.4 specific */
-@@ -1935,6 +1936,7 @@ struct net_device {
+@@ -1898,6 +1899,7 @@ struct net_device {
  	struct netprio_map __rcu *priomap;
  #endif
  	struct phy_device	*phydev;
@@ -137,9 +146,11 @@ Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
  	struct lock_class_key	*qdisc_tx_busylock;
  	struct lock_class_key	*qdisc_running_key;
  	bool			proto_down;
+diff --git a/include/linux/phylink.h b/include/linux/phylink.h
+index af67edd4ae38..76f054f39684 100644
 --- a/include/linux/phylink.h
 +++ b/include/linux/phylink.h
-@@ -125,9 +125,6 @@ void phylink_ethtool_get_pauseparam(stru
+@@ -125,9 +125,6 @@ void phylink_ethtool_get_pauseparam(struct phylink *,
  				    struct ethtool_pauseparam *);
  int phylink_ethtool_set_pauseparam(struct phylink *,
  				   struct ethtool_pauseparam *);
@@ -149,6 +160,8 @@ Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
  int phylink_init_eee(struct phylink *, bool);
  int phylink_get_eee_err(struct phylink *);
  int phylink_ethtool_get_eee(struct phylink *, struct ethtool_eee *);
+diff --git a/net/core/ethtool.c b/net/core/ethtool.c
+index 3469f5053c79..b989ab6899f1 100644
 --- a/net/core/ethtool.c
 +++ b/net/core/ethtool.c
 @@ -22,6 +22,7 @@
@@ -179,3 +192,6 @@ Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
  	if (phydev && phydev->drv && phydev->drv->module_eeprom)
  		return phydev->drv->module_eeprom(phydev, ee, data);
  
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/409-sfp-use-netdev-sfp_bus-for-start-stop.patch b/target/linux/mvebu/patches-4.14/90045-sfp-use-netdev-sfp_bus-for-start-stop.patch
similarity index 79%
rename from target/linux/mvebu/patches-4.14/409-sfp-use-netdev-sfp_bus-for-start-stop.patch
rename to target/linux/mvebu/patches-4.14/90045-sfp-use-netdev-sfp_bus-for-start-stop.patch
index 4db3867..81378be 100644
--- a/target/linux/mvebu/patches-4.14/409-sfp-use-netdev-sfp_bus-for-start-stop.patch
+++ b/target/linux/mvebu/patches-4.14/90045-sfp-use-netdev-sfp_bus-for-start-stop.patch
@@ -1,13 +1,15 @@
-From 883dc66755313e133a787eba4dfde313fe33525b Mon Sep 17 00:00:00 2001
+From c0f7b78aa709443779170e4ebbe873e49e99578f Mon Sep 17 00:00:00 2001
 From: Russell King <rmk+kernel@armlinux.org.uk>
 Date: Fri, 14 Apr 2017 16:41:55 +0100
-Subject: sfp: use netdev sfp_bus for start/stop
+Subject: [PATCH 045/126] sfp: use netdev sfp_bus for start/stop
 
 Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
 ---
  drivers/net/phy/phylink.c | 8 ++++----
  1 file changed, 4 insertions(+), 4 deletions(-)
 
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index fd0944c209c2..eb9d9ee24e40 100644
 --- a/drivers/net/phy/phylink.c
 +++ b/drivers/net/phy/phylink.c
 @@ -775,8 +775,8 @@ void phylink_start(struct phylink *pl)
@@ -32,3 +34,6 @@ Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
  
  	phylink_run_resolve_and_disable(pl, PHYLINK_DISABLE_STOPPED);
  }
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/503-clk-mvebu-armada-37xx-periph-cosmetic-changes.patch b/target/linux/mvebu/patches-4.14/90048-clk-mvebu-armada-37xx-periph-cosmetic-changes.patch
similarity index 73%
rename from target/linux/mvebu/patches-4.14/503-clk-mvebu-armada-37xx-periph-cosmetic-changes.patch
rename to target/linux/mvebu/patches-4.14/90048-clk-mvebu-armada-37xx-periph-cosmetic-changes.patch
index 7343e01..ac7c721 100644
--- a/target/linux/mvebu/patches-4.14/503-clk-mvebu-armada-37xx-periph-cosmetic-changes.patch
+++ b/target/linux/mvebu/patches-4.14/90048-clk-mvebu-armada-37xx-periph-cosmetic-changes.patch
@@ -1,7 +1,7 @@
-From adf4e289dd7f801c3fe12e0e6b491e11e548cd3d Mon Sep 17 00:00:00 2001
+From 3b75c05c22732fffe7224f13bb7bdbd49f9698b1 Mon Sep 17 00:00:00 2001
 From: Gregory CLEMENT <gregory.clement@free-electrons.com>
 Date: Thu, 30 Nov 2017 14:40:27 +0100
-Subject: clk: mvebu: armada-37xx-periph: cosmetic changes
+Subject: [PATCH 048/126] clk: mvebu: armada-37xx-periph: cosmetic changes
 
 This patches fixes few cosmetic issues such as alignment, blank lines
 and required space.
@@ -12,9 +12,11 @@ Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
  drivers/clk/mvebu/armada-37xx-periph.c | 17 +++++++++--------
  1 file changed, 9 insertions(+), 8 deletions(-)
 
+diff --git a/drivers/clk/mvebu/armada-37xx-periph.c b/drivers/clk/mvebu/armada-37xx-periph.c
+index cecb0fdfaef6..6dae21ced18a 100644
 --- a/drivers/clk/mvebu/armada-37xx-periph.c
 +++ b/drivers/clk/mvebu/armada-37xx-periph.c
-@@ -79,6 +79,7 @@ static const struct clk_div_table clk_ta
+@@ -79,6 +79,7 @@ static const struct clk_div_table clk_table2[] = {
  	{ .val = 1, .div = 4, },
  	{ .val = 0, .div = 0, }, /* last entry */
  };
@@ -22,7 +24,7 @@ Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
  static const struct clk_ops clk_double_div_ops;
  
  #define PERIPH_GATE(_name, _bit)		\
-@@ -217,7 +218,7 @@ PERIPH_CLK_FULL(counter, 23, 20, DIV_SEL
+@@ -217,7 +218,7 @@ PERIPH_CLK_FULL(counter, 23, 20, DIV_SEL0, 23, clk_table6);
  PERIPH_CLK_FULL_DD(eip97, 24, 24, DIV_SEL2, DIV_SEL2, 22, 19);
  PERIPH_CLK_MUX_DIV(cpu, 22, DIV_SEL0, 28, clk_table6);
  
@@ -31,7 +33,7 @@ Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
  	REF_CLK_FULL_DD(mmc),
  	REF_CLK_FULL_DD(sata_host),
  	REF_CLK_FULL_DD(sec_at),
-@@ -281,7 +282,7 @@ static unsigned int get_div(void __iomem
+@@ -281,7 +282,7 @@ static unsigned int get_div(void __iomem *reg, int shift)
  }
  
  static unsigned long clk_double_div_recalc_rate(struct clk_hw *hw,
@@ -40,7 +42,7 @@ Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
  {
  	struct clk_double_div *double_div = to_clk_double_div(hw);
  	unsigned int div;
-@@ -303,6 +304,7 @@ static const struct of_device_id armada_
+@@ -303,6 +304,7 @@ static const struct of_device_id armada_3700_periph_clock_of_match[] = {
  	.data = data_sb, },
  	{ }
  };
@@ -48,7 +50,7 @@ Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
  static int armada_3700_add_composite_clk(const struct clk_periph_data *data,
  					 void __iomem *reg, spinlock_t *lock,
  					 struct device *dev, struct clk_hw **hw)
-@@ -355,9 +357,9 @@ static int armada_3700_add_composite_clk
+@@ -355,9 +357,9 @@ static int armada_3700_add_composite_clk(const struct clk_periph_data *data,
  	}
  
  	*hw = clk_hw_register_composite(dev, data->name, data->parent_names,
@@ -61,7 +63,7 @@ Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
  
  	if (IS_ERR(*hw))
  		return PTR_ERR(*hw);
-@@ -406,12 +408,11 @@ static int armada_3700_periph_clock_prob
+@@ -406,12 +408,11 @@ static int armada_3700_periph_clock_probe(struct platform_device *pdev)
  		if (armada_3700_add_composite_clk(&data[i], reg,
  						  &driver_data->lock, dev, hw))
  			dev_err(dev, "Can't register periph clock %s\n",
@@ -76,3 +78,6 @@ Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
  	if (ret) {
  		for (i = 0; i < num_periph; i++)
  			clk_hw_unregister(driver_data->hw_data->hws[i]);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/504-clk-mvebu-armada-37xx-periph-prepare-cpu-clk-to-be-u.patch b/target/linux/mvebu/patches-4.14/90049-clk-mvebu-armada-37xx-periph-prepare-cpu-clk-to-be-u.patch
similarity index 85%
rename from target/linux/mvebu/patches-4.14/504-clk-mvebu-armada-37xx-periph-prepare-cpu-clk-to-be-u.patch
rename to target/linux/mvebu/patches-4.14/90049-clk-mvebu-armada-37xx-periph-prepare-cpu-clk-to-be-u.patch
index f9dec9f..fdfcd91 100644
--- a/target/linux/mvebu/patches-4.14/504-clk-mvebu-armada-37xx-periph-prepare-cpu-clk-to-be-u.patch
+++ b/target/linux/mvebu/patches-4.14/90049-clk-mvebu-armada-37xx-periph-prepare-cpu-clk-to-be-u.patch
@@ -1,7 +1,7 @@
-From 9818a7a4fd10f72537cdf2a5ec3402f2c245ea24 Mon Sep 17 00:00:00 2001
+From ac171dc778a090519a43876a3d2758478d1c3518 Mon Sep 17 00:00:00 2001
 From: Gregory CLEMENT <gregory.clement@free-electrons.com>
 Date: Thu, 30 Nov 2017 14:40:28 +0100
-Subject: clk: mvebu: armada-37xx-periph: prepare cpu clk to be
+Subject: [PATCH 049/126] clk: mvebu: armada-37xx-periph: prepare cpu clk to be
  used with DVFS
 
 When DVFS will be enabled then the cpu clk will use a different set of
@@ -14,9 +14,11 @@ without modifying the behavior of the clocks.
 Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
 Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
 ---
- drivers/clk/mvebu/armada-37xx-periph.c | 82 ++++++++++++++++++++++++++++++----
+ drivers/clk/mvebu/armada-37xx-periph.c | 82 +++++++++++++++++++++++---
  1 file changed, 73 insertions(+), 9 deletions(-)
 
+diff --git a/drivers/clk/mvebu/armada-37xx-periph.c b/drivers/clk/mvebu/armada-37xx-periph.c
+index 6dae21ced18a..ef725ec73c93 100644
 --- a/drivers/clk/mvebu/armada-37xx-periph.c
 +++ b/drivers/clk/mvebu/armada-37xx-periph.c
 @@ -46,7 +46,17 @@ struct clk_double_div {
@@ -45,7 +47,7 @@ Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
  	bool is_double_div;
  };
  
-@@ -81,6 +92,7 @@ static const struct clk_div_table clk_ta
+@@ -81,6 +92,7 @@ static const struct clk_div_table clk_table2[] = {
  };
  
  static const struct clk_ops clk_double_div_ops;
@@ -72,7 +74,7 @@ Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
  #define PERIPH_CLK_FULL_DD(_name, _bit, _shift, _reg1, _reg2, _shift1, _shift2)\
  static PERIPH_GATE(_name, _bit);			    \
  static PERIPH_MUX(_name, _shift);			    \
-@@ -136,10 +160,6 @@ static PERIPH_DIV(_name, _reg, _shift1,
+@@ -136,10 +160,6 @@ static PERIPH_DIV(_name, _reg, _shift1, _table);
  static PERIPH_GATE(_name, _bit);			\
  static PERIPH_DIV(_name, _reg, _shift, _table);
  
@@ -83,7 +85,7 @@ Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
  #define PERIPH_CLK_MUX_DD(_name, _shift, _reg1, _reg2, _shift1, _shift2)\
  static PERIPH_MUX(_name, _shift);			    \
  static PERIPH_DOUBLEDIV(_name, _reg1, _reg2, _shift1, _shift2);
-@@ -180,13 +200,12 @@ static PERIPH_DOUBLEDIV(_name, _reg1, _r
+@@ -180,13 +200,12 @@ static PERIPH_DOUBLEDIV(_name, _reg1, _reg2, _shift1, _shift2);
  	  .rate_hw = &rate_##_name.hw,				\
  	}
  
@@ -99,7 +101,7 @@ Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
  	}
  
  #define REF_CLK_MUX_DD(_name)				\
-@@ -216,7 +235,7 @@ PERIPH_CLK_FULL_DD(ddr_fclk, 21, 16, DIV
+@@ -216,7 +235,7 @@ PERIPH_CLK_FULL_DD(ddr_fclk, 21, 16, DIV_SEL0, DIV_SEL0, 15, 12);
  PERIPH_CLK_FULL(trace, 22, 18, DIV_SEL0, 20, clk_table6);
  PERIPH_CLK_FULL(counter, 23, 20, DIV_SEL0, 23, clk_table6);
  PERIPH_CLK_FULL_DD(eip97, 24, 24, DIV_SEL2, DIV_SEL2, 22, 19);
@@ -108,7 +110,7 @@ Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
  
  static struct clk_periph_data data_nb[] = {
  	REF_CLK_FULL_DD(mmc),
-@@ -235,7 +254,7 @@ static struct clk_periph_data data_nb[]
+@@ -235,7 +254,7 @@ static struct clk_periph_data data_nb[] = {
  	REF_CLK_FULL(trace),
  	REF_CLK_FULL(counter),
  	REF_CLK_FULL_DD(eip97),
@@ -117,7 +119,7 @@ Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
  	{ },
  };
  
-@@ -297,6 +316,37 @@ static const struct clk_ops clk_double_d
+@@ -297,6 +316,37 @@ static const struct clk_ops clk_double_div_ops = {
  	.recalc_rate = clk_double_div_recalc_rate,
  };
  
@@ -155,7 +157,7 @@ Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
  static const struct of_device_id armada_3700_periph_clock_of_match[] = {
  	{ .compatible = "marvell,armada-3700-periph-clock-nb",
  	  .data = data_nb, },
-@@ -356,6 +406,20 @@ static int armada_3700_add_composite_clk
+@@ -356,6 +406,20 @@ static int armada_3700_add_composite_clk(const struct clk_periph_data *data,
  		}
  	}
  
@@ -176,3 +178,6 @@ Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
  	*hw = clk_hw_register_composite(dev, data->name, data->parent_names,
  					data->num_parents, mux_hw,
  					mux_ops, rate_hw, rate_ops,
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/505-clk-mvebu-armada-37xx-periph-add-DVFS-support-for-cp.patch b/target/linux/mvebu/patches-4.14/90050-clk-mvebu-armada-37xx-periph-add-DVFS-support-for-cp.patch
similarity index 93%
rename from target/linux/mvebu/patches-4.14/505-clk-mvebu-armada-37xx-periph-add-DVFS-support-for-cp.patch
rename to target/linux/mvebu/patches-4.14/90050-clk-mvebu-armada-37xx-periph-add-DVFS-support-for-cp.patch
index 2065e78..9cd18a3 100644
--- a/target/linux/mvebu/patches-4.14/505-clk-mvebu-armada-37xx-periph-add-DVFS-support-for-cp.patch
+++ b/target/linux/mvebu/patches-4.14/90050-clk-mvebu-armada-37xx-periph-add-DVFS-support-for-cp.patch
@@ -1,7 +1,8 @@
-From 2089dc33ea0e3917465929d4020fbff3d6dbf7f4 Mon Sep 17 00:00:00 2001
+From 57908638ebabd902ef4dd61d60cdde9501011caa Mon Sep 17 00:00:00 2001
 From: Gregory CLEMENT <gregory.clement@free-electrons.com>
 Date: Thu, 30 Nov 2017 14:40:29 +0100
-Subject: clk: mvebu: armada-37xx-periph: add DVFS support for cpu clocks
+Subject: [PATCH 050/126] clk: mvebu: armada-37xx-periph: add DVFS support for
+ cpu clocks
 
 When DVFS is enabled the CPU clock setting is done using an other set of
 registers.
@@ -18,9 +19,11 @@ Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
 to keep lines shorter]
 Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
 ---
- drivers/clk/mvebu/armada-37xx-periph.c | 221 ++++++++++++++++++++++++++++++++-
+ drivers/clk/mvebu/armada-37xx-periph.c | 221 ++++++++++++++++++++++++-
  1 file changed, 217 insertions(+), 4 deletions(-)
 
+diff --git a/drivers/clk/mvebu/armada-37xx-periph.c b/drivers/clk/mvebu/armada-37xx-periph.c
+index ef725ec73c93..ee8637c2b189 100644
 --- a/drivers/clk/mvebu/armada-37xx-periph.c
 +++ b/drivers/clk/mvebu/armada-37xx-periph.c
 @@ -21,9 +21,11 @@
@@ -70,7 +73,7 @@ Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
  };
  
  #define to_clk_double_div(_hw) container_of(_hw, struct clk_double_div, hw)
-@@ -316,14 +339,94 @@ static const struct clk_ops clk_double_d
+@@ -316,14 +339,94 @@ static const struct clk_ops clk_double_div_ops = {
  	.recalc_rate = clk_double_div_recalc_rate,
  };
  
@@ -167,7 +170,7 @@ Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
  
  	if (val >= num_parents)
  		return -EINVAL;
-@@ -331,19 +434,124 @@ static u8 clk_pm_cpu_get_parent(struct c
+@@ -331,19 +434,124 @@ static u8 clk_pm_cpu_get_parent(struct clk_hw *hw)
  	return val;
  }
  
@@ -294,7 +297,7 @@ Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
  	.recalc_rate = clk_pm_cpu_recalc_rate,
  };
  
-@@ -409,6 +617,7 @@ static int armada_3700_add_composite_clk
+@@ -409,6 +617,7 @@ static int armada_3700_add_composite_clk(const struct clk_periph_data *data,
  	if (data->muxrate_hw) {
  		struct clk_pm_cpu *pmcpu_clk;
  		struct clk_hw *muxrate_hw = data->muxrate_hw;
@@ -302,7 +305,7 @@ Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
  
  		pmcpu_clk =  to_clk_pm_cpu(muxrate_hw);
  		pmcpu_clk->reg_mux = reg + (u64)pmcpu_clk->reg_mux;
-@@ -418,6 +627,10 @@ static int armada_3700_add_composite_clk
+@@ -418,6 +627,10 @@ static int armada_3700_add_composite_clk(const struct clk_periph_data *data,
  		rate_hw = muxrate_hw;
  		mux_ops = muxrate_hw->init->ops;
  		rate_ops = muxrate_hw->init->ops;
@@ -313,3 +316,6 @@ Signed-off-by: Stephen Boyd <sboyd@codeaurora.org>
  	}
  
  	*hw = clk_hw_register_composite(dev, data->name, data->parent_names,
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/506-cpufreq-Add-DVFS-support-for-Armada-37xx.patch b/target/linux/mvebu/patches-4.14/90051-cpufreq-Add-DVFS-support-for-Armada-37xx.patch
similarity index 93%
rename from target/linux/mvebu/patches-4.14/506-cpufreq-Add-DVFS-support-for-Armada-37xx.patch
rename to target/linux/mvebu/patches-4.14/90051-cpufreq-Add-DVFS-support-for-Armada-37xx.patch
index 11562c5..5095290 100644
--- a/target/linux/mvebu/patches-4.14/506-cpufreq-Add-DVFS-support-for-Armada-37xx.patch
+++ b/target/linux/mvebu/patches-4.14/90051-cpufreq-Add-DVFS-support-for-Armada-37xx.patch
@@ -1,7 +1,7 @@
-From 92ce45fb875d7c3e021cc454482fe0687ff54f29 Mon Sep 17 00:00:00 2001
+From af509a6da590b3737ccb54b11c131340f6da4d9c Mon Sep 17 00:00:00 2001
 From: Gregory CLEMENT <gregory.clement@free-electrons.com>
 Date: Thu, 14 Dec 2017 16:00:05 +0100
-Subject: cpufreq: Add DVFS support for Armada 37xx
+Subject: [PATCH 051/126] cpufreq: Add DVFS support for Armada 37xx
 
 This patch adds DVFS support for the Armada 37xx SoCs
 
@@ -21,10 +21,12 @@ Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
 ---
  drivers/cpufreq/Kconfig.arm           |   7 +
  drivers/cpufreq/Makefile              |   1 +
- drivers/cpufreq/armada-37xx-cpufreq.c | 241 ++++++++++++++++++++++++++++++++++
+ drivers/cpufreq/armada-37xx-cpufreq.c | 241 ++++++++++++++++++++++++++
  3 files changed, 249 insertions(+)
  create mode 100644 drivers/cpufreq/armada-37xx-cpufreq.c
 
+diff --git a/drivers/cpufreq/Kconfig.arm b/drivers/cpufreq/Kconfig.arm
+index bdce4488ded1..161819ee7eb8 100644
 --- a/drivers/cpufreq/Kconfig.arm
 +++ b/drivers/cpufreq/Kconfig.arm
 @@ -2,6 +2,13 @@
@@ -41,9 +43,11 @@ Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
  # big LITTLE core layer and glue drivers
  config ARM_BIG_LITTLE_CPUFREQ
  	tristate "Generic ARM big LITTLE CPUfreq driver"
+diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
+index 812f9e0d01a3..de92572a1c64 100644
 --- a/drivers/cpufreq/Makefile
 +++ b/drivers/cpufreq/Makefile
-@@ -52,6 +52,7 @@ obj-$(CONFIG_ARM_BIG_LITTLE_CPUFREQ)	+=
+@@ -52,6 +52,7 @@ obj-$(CONFIG_ARM_BIG_LITTLE_CPUFREQ)	+= arm_big_little.o
  # LITTLE drivers, so that it is probed last.
  obj-$(CONFIG_ARM_DT_BL_CPUFREQ)		+= arm_big_little_dt.o
  
@@ -51,6 +55,9 @@ Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
  obj-$(CONFIG_ARM_BRCMSTB_AVS_CPUFREQ)	+= brcmstb-avs-cpufreq.o
  obj-$(CONFIG_ARCH_DAVINCI)		+= davinci-cpufreq.o
  obj-$(CONFIG_ARM_EXYNOS5440_CPUFREQ)	+= exynos5440-cpufreq.o
+diff --git a/drivers/cpufreq/armada-37xx-cpufreq.c b/drivers/cpufreq/armada-37xx-cpufreq.c
+new file mode 100644
+index 000000000000..c6ebc88a7d8d
 --- /dev/null
 +++ b/drivers/cpufreq/armada-37xx-cpufreq.c
 @@ -0,0 +1,241 @@
@@ -295,3 +302,6 @@ Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
 +MODULE_AUTHOR("Gregory CLEMENT <gregory.clement@free-electrons.com>");
 +MODULE_DESCRIPTION("Armada 37xx cpufreq driver");
 +MODULE_LICENSE("GPL");
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/501-spi-a3700-Change-SPI-mode-before-asserting-chip-sele.patch b/target/linux/mvebu/patches-4.14/90052-spi-a3700-Change-SPI-mode-before-asserting-chip-sele.patch
similarity index 74%
rename from target/linux/mvebu/patches-4.14/501-spi-a3700-Change-SPI-mode-before-asserting-chip-sele.patch
rename to target/linux/mvebu/patches-4.14/90052-spi-a3700-Change-SPI-mode-before-asserting-chip-sele.patch
index 3ac7091..a26ec53 100644
--- a/target/linux/mvebu/patches-4.14/501-spi-a3700-Change-SPI-mode-before-asserting-chip-sele.patch
+++ b/target/linux/mvebu/patches-4.14/90052-spi-a3700-Change-SPI-mode-before-asserting-chip-sele.patch
@@ -1,7 +1,8 @@
-From dd7aa8d4b53b3484ba31ba56f3ff1be7deb38530 Mon Sep 17 00:00:00 2001
+From 3ec56a5a242570c248cbe104e5f2a7f4b5e53a18 Mon Sep 17 00:00:00 2001
 From: Maxime Chevallier <maxime.chevallier@smile.fr>
 Date: Tue, 10 Oct 2017 10:43:18 +0200
-Subject: spi: a3700: Change SPI mode before asserting chip-select
+Subject: [PATCH 052/126] spi: a3700: Change SPI mode before asserting
+ chip-select
 
 The spi device mode should be configured in the controller before the
 chip-select is asserted, so that a clock polarity configuration change
@@ -21,9 +22,11 @@ Signed-off-by: Mark Brown <broonie@kernel.org>
  drivers/spi/spi-armada-3700.c | 17 ++++-------------
  1 file changed, 4 insertions(+), 13 deletions(-)
 
+diff --git a/drivers/spi/spi-armada-3700.c b/drivers/spi/spi-armada-3700.c
+index 4903f15177cf..c11ea6c169a4 100644
 --- a/drivers/spi/spi-armada-3700.c
 +++ b/drivers/spi/spi-armada-3700.c
-@@ -214,7 +214,7 @@ static void a3700_spi_mode_set(struct a3
+@@ -214,7 +214,7 @@ static void a3700_spi_mode_set(struct a3700_spi *a3700_spi,
  }
  
  static void a3700_spi_clock_set(struct a3700_spi *a3700_spi,
@@ -32,7 +35,7 @@ Signed-off-by: Mark Brown <broonie@kernel.org>
  {
  	u32 val;
  	u32 prescale;
-@@ -239,17 +239,6 @@ static void a3700_spi_clock_set(struct a
+@@ -239,17 +239,6 @@ static void a3700_spi_clock_set(struct a3700_spi *a3700_spi,
  		val |= A3700_SPI_CLK_CAPT_EDGE;
  		spireg_write(a3700_spi, A3700_SPI_IF_TIME_REG, val);
  	}
@@ -50,7 +53,7 @@ Signed-off-by: Mark Brown <broonie@kernel.org>
  }
  
  static void a3700_spi_bytelen_set(struct a3700_spi *a3700_spi, unsigned int len)
-@@ -431,7 +420,7 @@ static void a3700_spi_transfer_setup(str
+@@ -431,7 +420,7 @@ static void a3700_spi_transfer_setup(struct spi_device *spi,
  
  	a3700_spi = spi_master_get_devdata(spi->master);
  
@@ -59,7 +62,7 @@ Signed-off-by: Mark Brown <broonie@kernel.org>
  
  	byte_len = xfer->bits_per_word >> 3;
  
-@@ -592,6 +581,8 @@ static int a3700_spi_prepare_message(str
+@@ -592,6 +581,8 @@ static int a3700_spi_prepare_message(struct spi_master *master,
  
  	a3700_spi_bytelen_set(a3700_spi, 4);
  
@@ -68,3 +71,6 @@ Signed-off-by: Mark Brown <broonie@kernel.org>
  	return 0;
  }
  
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/500-arm64-dts-marvell-Fix-A37xx-UART0-register-size.patch b/target/linux/mvebu/patches-4.14/90053-arm64-dts-marvell-Fix-A37xx-UART0-register-size.patch
similarity index 73%
rename from target/linux/mvebu/patches-4.14/500-arm64-dts-marvell-Fix-A37xx-UART0-register-size.patch
rename to target/linux/mvebu/patches-4.14/90053-arm64-dts-marvell-Fix-A37xx-UART0-register-size.patch
index 9e2b1c1..bc7795f 100644
--- a/target/linux/mvebu/patches-4.14/500-arm64-dts-marvell-Fix-A37xx-UART0-register-size.patch
+++ b/target/linux/mvebu/patches-4.14/90053-arm64-dts-marvell-Fix-A37xx-UART0-register-size.patch
@@ -1,7 +1,7 @@
-From c737abc193d16e62e23e2fb585b8b7398ab380d8 Mon Sep 17 00:00:00 2001
+From 53e48e6a26036b17a782627499feada841a40709 Mon Sep 17 00:00:00 2001
 From: allen yan <yanwei@marvell.com>
 Date: Thu, 7 Sep 2017 15:04:53 +0200
-Subject: arm64: dts: marvell: Fix A37xx UART0 register size
+Subject: [PATCH 053/126] arm64: dts: marvell: Fix A37xx UART0 register size
 
 Armada-37xx UART0 registers are 0x200 bytes wide. Right next to them are
 the UART1 registers that should not be declared in this node.
@@ -16,6 +16,8 @@ Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
  arch/arm64/boot/dts/marvell/armada-37xx.dtsi            | 2 +-
  2 files changed, 2 insertions(+), 2 deletions(-)
 
+diff --git a/Documentation/devicetree/bindings/serial/mvebu-uart.txt b/Documentation/devicetree/bindings/serial/mvebu-uart.txt
+index 6087defd9f93..d37fabe17bd1 100644
 --- a/Documentation/devicetree/bindings/serial/mvebu-uart.txt
 +++ b/Documentation/devicetree/bindings/serial/mvebu-uart.txt
 @@ -8,6 +8,6 @@ Required properties:
@@ -26,6 +28,8 @@ Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
 +		reg = <0x12000 0x200>;
  		interrupts = <43>;
  	};
+diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+index 6842cae5b35b..a4483ba82ecc 100644
 --- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
 +++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
 @@ -134,7 +134,7 @@
@@ -37,3 +41,6 @@ Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
  				interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>;
  				status = "disabled";
  			};
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/502-arm64-dts-marvell-armada-37xx-add-UART-clock.patch b/target/linux/mvebu/patches-4.14/90054-arm64-dts-marvell-armada-37xx-add-UART-clock.patch
similarity index 74%
rename from target/linux/mvebu/patches-4.14/502-arm64-dts-marvell-armada-37xx-add-UART-clock.patch
rename to target/linux/mvebu/patches-4.14/90054-arm64-dts-marvell-armada-37xx-add-UART-clock.patch
index 47e0751..88137c2 100644
--- a/target/linux/mvebu/patches-4.14/502-arm64-dts-marvell-armada-37xx-add-UART-clock.patch
+++ b/target/linux/mvebu/patches-4.14/90054-arm64-dts-marvell-armada-37xx-add-UART-clock.patch
@@ -1,7 +1,7 @@
-From 2ff0d0b5bb397c3dc5c9b97bd0f20948f0b77740 Mon Sep 17 00:00:00 2001
+From 15ffd974e38f7442a368f6c1100bb7d596b0d242 Mon Sep 17 00:00:00 2001
 From: Miquel Raynal <miquel.raynal@free-electrons.com>
 Date: Fri, 13 Oct 2017 11:01:57 +0200
-Subject: arm64: dts: marvell: armada-37xx: add UART clock
+Subject: [PATCH 054/126] arm64: dts: marvell: armada-37xx: add UART clock
 
 Add the missing clock property to armada-3700 UART node.
 
@@ -15,6 +15,8 @@ Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
  arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 1 +
  1 file changed, 1 insertion(+)
 
+diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+index a4483ba82ecc..3260f27edc0c 100644
 --- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
 +++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
 @@ -135,6 +135,7 @@
@@ -25,3 +27,6 @@ Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
  				interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>;
  				status = "disabled";
  			};
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/507-arm64-dts-marvell-armada-37xx-add-nodes-allowing-cpu.patch b/target/linux/mvebu/patches-4.14/90055-arm64-dts-marvell-armada-37xx-add-nodes-allowing-cpu.patch
similarity index 73%
rename from target/linux/mvebu/patches-4.14/507-arm64-dts-marvell-armada-37xx-add-nodes-allowing-cpu.patch
rename to target/linux/mvebu/patches-4.14/90055-arm64-dts-marvell-armada-37xx-add-nodes-allowing-cpu.patch
index dd3727c..7cbbd93 100644
--- a/target/linux/mvebu/patches-4.14/507-arm64-dts-marvell-armada-37xx-add-nodes-allowing-cpu.patch
+++ b/target/linux/mvebu/patches-4.14/90055-arm64-dts-marvell-armada-37xx-add-nodes-allowing-cpu.patch
@@ -1,8 +1,8 @@
-From e8d66e7927b2a15310df0eb44a67d120ea147a59 Mon Sep 17 00:00:00 2001
+From f0583a43cf03e3a735d6f796a1c95a17fa07be75 Mon Sep 17 00:00:00 2001
 From: Gregory CLEMENT <gregory.clement@free-electrons.com>
 Date: Thu, 14 Dec 2017 16:00:06 +0100
-Subject: arm64: dts: marvell: armada-37xx: add nodes allowing cpufreq
- support
+Subject: [PATCH 055/126] arm64: dts: marvell: armada-37xx: add nodes allowing
+ cpufreq support
 
 In order to be able to use cpu freq, we need to associate a clock to each
 CPU and to expose the power management registers.
@@ -13,6 +13,8 @@ Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
  arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 7 +++++++
  2 files changed, 8 insertions(+)
 
+diff --git a/arch/arm64/boot/dts/marvell/armada-372x.dtsi b/arch/arm64/boot/dts/marvell/armada-372x.dtsi
+index 59d7557d3b1b..2554e0baea6b 100644
 --- a/arch/arm64/boot/dts/marvell/armada-372x.dtsi
 +++ b/arch/arm64/boot/dts/marvell/armada-372x.dtsi
 @@ -56,6 +56,7 @@
@@ -23,6 +25,8 @@ Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
  			enable-method = "psci";
  		};
  	};
+diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+index 3260f27edc0c..544fef59d051 100644
 --- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
 +++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
 @@ -64,6 +64,7 @@
@@ -46,3 +50,6 @@ Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
  			pinctrl_sb: pinctrl@18800 {
  				compatible = "marvell,armada3710-sb-pinctrl",
  					     "syscon", "simple-mfd";
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/520-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch b/target/linux/mvebu/patches-4.14/90056-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch
similarity index 59%
rename from target/linux/mvebu/patches-4.14/520-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch
rename to target/linux/mvebu/patches-4.14/90056-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch
index 206caf2..eedfdcd 100644
--- a/target/linux/mvebu/patches-4.14/520-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch
+++ b/target/linux/mvebu/patches-4.14/90056-arm64-dts-marvell-armada37xx-Add-eth0-alias.patch
@@ -1,13 +1,15 @@
-From be893f672e340b56ca60f2f6c32fdd713a5852f5 Mon Sep 17 00:00:00 2001
+From ac7263f1c09223aaf46c4c3798db71ef046772cb Mon Sep 17 00:00:00 2001
 From: Kevin Mihelich <kevin@archlinuxarm.org>
 Date: Tue, 4 Jul 2017 19:25:28 -0600
-Subject: arm64: dts: marvell: armada37xx: Add eth0 alias
+Subject: [PATCH 056/126] arm64: dts: marvell: armada37xx: Add eth0 alias
 
 Signed-off-by: Kevin Mihelich <kevin@archlinuxarm.org>
 ---
  arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 1 +
  1 file changed, 1 insertion(+)
 
+diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+index 544fef59d051..8cd43ce38571 100644
 --- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
 +++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
 @@ -54,6 +54,7 @@
@@ -18,3 +20,6 @@ Signed-off-by: Kevin Mihelich <kevin@archlinuxarm.org>
  		serial0 = &uart0;
  	};
  
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/524-PCI-aardvark-set-host-and-device-to-the-same-MAX-payload-size.patch b/target/linux/mvebu/patches-4.14/90057-PCI-aardvark-set-host-and-device-to-the-same-MAX-pay.patch
similarity index 72%
rename from target/linux/mvebu/patches-4.14/524-PCI-aardvark-set-host-and-device-to-the-same-MAX-payload-size.patch
rename to target/linux/mvebu/patches-4.14/90057-PCI-aardvark-set-host-and-device-to-the-same-MAX-pay.patch
index 74e78d3..1499e36 100644
--- a/target/linux/mvebu/patches-4.14/524-PCI-aardvark-set-host-and-device-to-the-same-MAX-payload-size.patch
+++ b/target/linux/mvebu/patches-4.14/90057-PCI-aardvark-set-host-and-device-to-the-same-MAX-pay.patch
@@ -1,27 +1,8 @@
-From patchwork Thu Sep 28 12:58:34 2017
-Content-Type: text/plain; charset="utf-8"
-MIME-Version: 1.0
-Content-Transfer-Encoding: 7bit
-Subject: [v2,
- 3/7] PCI: aardvark: set host and device to the same MAX payload size
-X-Patchwork-Submitter: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
-X-Patchwork-Id: 819587
-Message-Id: <20170928125838.11887-4-thomas.petazzoni@free-electrons.com>
-To: Bjorn Helgaas <bhelgaas@google.com>, linux-pci@vger.kernel.org
-Cc: Jason Cooper <jason@lakedaemon.net>, Andrew Lunn <andrew@lunn.ch>,
- Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>, Gregory Clement
- <gregory.clement@free-electrons.com>, 
- Nadav Haklai <nadavh@marvell.com>, Hanna Hawa <hannah@marvell.com>,
- Yehuda Yitschak <yehuday@marvell.com>,
- linux-arm-kernel@lists.infradead.org, Antoine Tenart
- <antoine.tenart@free-electrons.com>, =?utf-8?q?Miqu=C3=A8l_Raynal?=
- <miquel.raynal@free-electrons.com>, Victor Gu <xigu@marvell.com>,
- Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
-Date: Thu, 28 Sep 2017 14:58:34 +0200
-From: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
-List-Id: <linux-pci.vger.kernel.org>
-
+From b706337af2471b1ad8c4b4beb0eeaac3867e01d8 Mon Sep 17 00:00:00 2001
 From: Victor Gu <xigu@marvell.com>
+Date: Thu, 28 Sep 2017 14:58:34 +0200
+Subject: [PATCH 057/126] PCI: aardvark: set host and device to the same MAX
+ payload size
 
 Since the Aardvark does not implement a PCIe root bus, the Linux PCIe
 subsystem will not align the MAX payload size between the host and the
@@ -40,24 +21,25 @@ Reviewed-by: Nadav Haklai <nadavh@marvell.com>
 [Thomas: tweak commit log.]
 Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
 ---
- drivers/pci/host/pci-aardvark.c | 60 ++++++++++++++++++++++++++++++++++++++++-
+ drivers/pci/host/pci-aardvark.c | 60 ++++++++++++++++++++++++++++++++-
  1 file changed, 59 insertions(+), 1 deletion(-)
 
+diff --git a/drivers/pci/host/pci-aardvark.c b/drivers/pci/host/pci-aardvark.c
+index 5f3048e75bec..3b12157a3298 100644
 --- a/drivers/pci/host/pci-aardvark.c
 +++ b/drivers/pci/host/pci-aardvark.c
-@@ -30,9 +30,11 @@
+@@ -30,8 +30,10 @@
  #define PCIE_CORE_DEV_CTRL_STATS_REG				0xc8
  #define     PCIE_CORE_DEV_CTRL_STATS_RELAX_ORDER_DISABLE	(0 << 4)
  #define     PCIE_CORE_DEV_CTRL_STATS_MAX_PAYLOAD_SZ_SHIFT	5
 +#define     PCIE_CORE_DEV_CTRL_STATS_MAX_PAYLOAD_SZ		0x2
  #define     PCIE_CORE_DEV_CTRL_STATS_SNOOP_DISABLE		(0 << 11)
  #define     PCIE_CORE_DEV_CTRL_STATS_MAX_RD_REQ_SIZE_SHIFT	12
- #define     PCIE_CORE_DEV_CTRL_STATS_MAX_RD_REQ_SZ		0x2
 +#define     PCIE_CORE_MPS_UNIT_BYTE				128
+ #define     PCIE_CORE_DEV_CTRL_STATS_MAX_RD_REQ_SZ		0x2
  #define PCIE_CORE_LINK_CTRL_STAT_REG				0xd0
  #define     PCIE_CORE_LINK_L0S_ENTRY				BIT(0)
- #define     PCIE_CORE_LINK_TRAINING				BIT(5)
-@@ -297,7 +299,8 @@ static void advk_pcie_setup_hw(struct ad
+@@ -297,7 +299,8 @@ static void advk_pcie_setup_hw(struct advk_pcie *pcie)
  
  	/* Set PCIe Device Control and Status 1 PF0 register */
  	reg = PCIE_CORE_DEV_CTRL_STATS_RELAX_ORDER_DISABLE |
@@ -67,7 +49,7 @@ Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
  		PCIE_CORE_DEV_CTRL_STATS_SNOOP_DISABLE |
  		(PCIE_CORE_DEV_CTRL_STATS_MAX_RD_REQ_SZ <<
  		 PCIE_CORE_DEV_CTRL_STATS_MAX_RD_REQ_SIZE_SHIFT);
-@@ -886,6 +889,58 @@ out_release_res:
+@@ -886,6 +889,58 @@ static int advk_pcie_parse_request_of_pci_ranges(struct advk_pcie *pcie)
  	return err;
  }
  
@@ -126,7 +108,7 @@ Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
  static int advk_pcie_probe(struct platform_device *pdev)
  {
  	struct device *dev = &pdev->dev;
-@@ -960,6 +1015,9 @@ static int advk_pcie_probe(struct platfo
+@@ -960,6 +1015,9 @@ static int advk_pcie_probe(struct platform_device *pdev)
  	list_for_each_entry(child, &bus->children, node)
  		pcie_bus_configure_settings(child);
  
@@ -136,3 +118,6 @@ Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
  	pci_bus_add_devices(bus);
  	return 0;
  }
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/526-PCI-aardvark-disable-LOS-state-by-default.patch b/target/linux/mvebu/patches-4.14/90058-PCI-aardvark-disable-LOS-state-by-default.patch
similarity index 50%
rename from target/linux/mvebu/patches-4.14/526-PCI-aardvark-disable-LOS-state-by-default.patch
rename to target/linux/mvebu/patches-4.14/90058-PCI-aardvark-disable-LOS-state-by-default.patch
index 0ee4af4..8da1297 100644
--- a/target/linux/mvebu/patches-4.14/526-PCI-aardvark-disable-LOS-state-by-default.patch
+++ b/target/linux/mvebu/patches-4.14/90058-PCI-aardvark-disable-LOS-state-by-default.patch
@@ -1,26 +1,7 @@
-From patchwork Thu Sep 28 12:58:36 2017
-Content-Type: text/plain; charset="utf-8"
-MIME-Version: 1.0
-Content-Transfer-Encoding: 7bit
-Subject: [v2,5/7] PCI: aardvark: disable LOS state by default
-X-Patchwork-Submitter: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
-X-Patchwork-Id: 819590
-Message-Id: <20170928125838.11887-6-thomas.petazzoni@free-electrons.com>
-To: Bjorn Helgaas <bhelgaas@google.com>, linux-pci@vger.kernel.org
-Cc: Jason Cooper <jason@lakedaemon.net>, Andrew Lunn <andrew@lunn.ch>,
- Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>, Gregory Clement
- <gregory.clement@free-electrons.com>, 
- Nadav Haklai <nadavh@marvell.com>, Hanna Hawa <hannah@marvell.com>,
- Yehuda Yitschak <yehuday@marvell.com>,
- linux-arm-kernel@lists.infradead.org, Antoine Tenart
- <antoine.tenart@free-electrons.com>, =?utf-8?q?Miqu=C3=A8l_Raynal?=
- <miquel.raynal@free-electrons.com>, Victor Gu <xigu@marvell.com>,
- Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
-Date: Thu, 28 Sep 2017 14:58:36 +0200
-From: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
-List-Id: <linux-pci.vger.kernel.org>
-
+From 2c2aeb87f73d9bc0fd811b60d38dd120fc810424 Mon Sep 17 00:00:00 2001
 From: Victor Gu <xigu@marvell.com>
+Date: Thu, 28 Sep 2017 14:58:36 +0200
+Subject: [PATCH 058/126] PCI: aardvark: disable LOS state by default
 
 Some PCIe devices do not support LOS, and will cause timeouts if the
 root complex forces the LOS state. This patch disables the LOS state
@@ -41,9 +22,11 @@ Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
  drivers/pci/host/pci-aardvark.c | 3 +--
  1 file changed, 1 insertion(+), 2 deletions(-)
 
+diff --git a/drivers/pci/host/pci-aardvark.c b/drivers/pci/host/pci-aardvark.c
+index 3b12157a3298..50e8addc22f9 100644
 --- a/drivers/pci/host/pci-aardvark.c
 +++ b/drivers/pci/host/pci-aardvark.c
-@@ -368,8 +368,7 @@ static void advk_pcie_setup_hw(struct ad
+@@ -368,8 +368,7 @@ static void advk_pcie_setup_hw(struct advk_pcie *pcie)
  
  	advk_pcie_wait_for_link(pcie);
  
@@ -53,3 +36,6 @@ Signed-off-by: Thomas Petazzoni <thomas.petazzoni@free-electrons.com>
  	advk_writel(pcie, reg, PCIE_CORE_LINK_CTRL_STAT_REG);
  
  	reg = advk_readl(pcie, PCIE_CORE_CMD_STATUS_REG);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90059-net-mvneta-move-port-configuration.patch b/target/linux/mvebu/patches-4.14/90059-net-mvneta-move-port-configuration.patch
new file mode 100644
index 0000000..bd20342
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90059-net-mvneta-move-port-configuration.patch
@@ -0,0 +1,106 @@
+From 76506913e4a2f777b7698136c5c37b16ffee2af5 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Tue, 2 Jan 2018 17:24:49 +0000
+Subject: [PATCH 059/126] net: mvneta: move port configuration
+
+Move the port configuration and release of reset to mvneta_mac_config()
+along side the rest of the port mode configuration.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 51 +++++++++++----------------
+ 1 file changed, 20 insertions(+), 31 deletions(-)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index 4cfffadfcac1..cbd81bdf745e 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -3285,7 +3285,8 @@ static void mvneta_mac_config(struct net_device *ndev, unsigned int mode,
+ 	u32 new_an, gmac_an = mvreg_read(pp, MVNETA_GMAC_AUTONEG_CONFIG);
+ 
+ 	new_ctrl0 = gmac_ctrl0 & ~MVNETA_GMAC0_PORT_1000BASE_X;
+-	new_ctrl2 = gmac_ctrl2 & ~MVNETA_GMAC2_INBAND_AN_ENABLE;
++	new_ctrl2 = gmac_ctrl2 & ~(MVNETA_GMAC2_INBAND_AN_ENABLE |
++				   MVNETA_GMAC2_PORT_RESET);
+ 	new_clk = gmac_clk & ~MVNETA_GMAC_1MS_CLOCK_ENABLE;
+ 	new_an = gmac_an & ~(MVNETA_GMAC_INBAND_AN_ENABLE |
+ 			     MVNETA_GMAC_INBAND_RESTART_AN |
+@@ -3303,6 +3304,15 @@ static void mvneta_mac_config(struct net_device *ndev, unsigned int mode,
+ 	if (state->pause & MLO_PAUSE_TXRX_MASK)
+ 		new_an |= MVNETA_GMAC_CONFIG_FLOW_CTRL;
+ 
++	/* Even though it might look weird, when we're configured in
++	 * SGMII or QSGMII mode, the RGMII bit needs to be set.
++	 */
++	new_ctrl2 |= MVNETA_GMAC2_PORT_RGMII;
++
++	if (state->interface == PHY_INTERFACE_MODE_QSGMII ||
++	    state->interface == PHY_INTERFACE_MODE_SGMII)
++		new_ctrl2 |= MVNETA_GMAC2_PCS_ENABLE;
++
+ 	if (!phylink_autoneg_inband(mode)) {
+ 		/* Phy or fixed speed */
+ 		if (state->duplex)
+@@ -3355,6 +3365,12 @@ static void mvneta_mac_config(struct net_device *ndev, unsigned int mode,
+ 		mvreg_write(pp, MVNETA_GMAC_CLOCK_DIVIDER, new_clk);
+ 	if (new_an != gmac_an)
+ 		mvreg_write(pp, MVNETA_GMAC_AUTONEG_CONFIG, new_an);
++
++	if (gmac_ctrl2 & MVNETA_GMAC2_PORT_RESET) {
++		while ((mvreg_read(pp, MVNETA_GMAC_CTRL_2) &
++			MVNETA_GMAC2_PORT_RESET) != 0)
++			continue;
++	}
+ }
+ 
+ static void mvneta_set_eee(struct mvneta_port *pp, bool enable)
+@@ -4230,42 +4246,15 @@ static void mvneta_conf_mbus_windows(struct mvneta_port *pp,
+ /* Power up the port */
+ static int mvneta_port_power_up(struct mvneta_port *pp, int phy_mode)
+ {
+-	u32 ctrl;
+-
+ 	/* MAC Cause register should be cleared */
+ 	mvreg_write(pp, MVNETA_UNIT_INTR_CAUSE, 0);
+ 
+-	ctrl = mvreg_read(pp, MVNETA_GMAC_CTRL_2);
+-
+-	/* Even though it might look weird, when we're configured in
+-	 * SGMII or QSGMII mode, the RGMII bit needs to be set.
+-	 */
+-	switch(phy_mode) {
+-	case PHY_INTERFACE_MODE_QSGMII:
++	if (phy_mode == PHY_INTERFACE_MODE_QSGMII)
+ 		mvreg_write(pp, MVNETA_SERDES_CFG, MVNETA_QSGMII_SERDES_PROTO);
+-		ctrl |= MVNETA_GMAC2_PCS_ENABLE | MVNETA_GMAC2_PORT_RGMII;
+-		break;
+-	case PHY_INTERFACE_MODE_SGMII:
++	else if (phy_mode == PHY_INTERFACE_MODE_SGMII)
+ 		mvreg_write(pp, MVNETA_SERDES_CFG, MVNETA_SGMII_SERDES_PROTO);
+-		ctrl |= MVNETA_GMAC2_PCS_ENABLE | MVNETA_GMAC2_PORT_RGMII;
+-		break;
+-	case PHY_INTERFACE_MODE_RGMII:
+-	case PHY_INTERFACE_MODE_RGMII_ID:
+-	case PHY_INTERFACE_MODE_RGMII_RXID:
+-	case PHY_INTERFACE_MODE_RGMII_TXID:
+-		ctrl |= MVNETA_GMAC2_PORT_RGMII;
+-		break;
+-	default:
++	else if (!phy_interface_mode_is_rgmii(phy_mode))
+ 		return -EINVAL;
+-	}
+-
+-	/* Cancel Port Reset */
+-	ctrl &= ~MVNETA_GMAC2_PORT_RESET;
+-	mvreg_write(pp, MVNETA_GMAC_CTRL_2, ctrl);
+-
+-	while ((mvreg_read(pp, MVNETA_GMAC_CTRL_2) &
+-		MVNETA_GMAC2_PORT_RESET) != 0)
+-		continue;
+ 
+ 	return 0;
+ }
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90060-net-mvneta-add-1000BaseX-support.patch b/target/linux/mvebu/patches-4.14/90060-net-mvneta-add-1000BaseX-support.patch
new file mode 100644
index 0000000..b0df54b
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90060-net-mvneta-add-1000BaseX-support.patch
@@ -0,0 +1,65 @@
+From 71316864d24bcb8f64201af42bc7b577b9f624df Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@arm.linux.org.uk>
+Date: Tue, 2 Jan 2018 17:24:54 +0000
+Subject: [PATCH 060/126] net: mvneta: add 1000BaseX support
+
+Add support for 1000BaseX link modes.
+
+Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 18 +++++++++++++++---
+ 1 file changed, 15 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index cbd81bdf745e..003fb1fd92f3 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -3212,6 +3212,16 @@ static void mvneta_validate(struct net_device *ndev, unsigned long *supported,
+ {
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+ 
++	/* We only support QSGMII, SGMII, 802.3z and RGMII modes */
++	if (state->interface != PHY_INTERFACE_MODE_NA &&
++	    state->interface != PHY_INTERFACE_MODE_QSGMII &&
++	    state->interface != PHY_INTERFACE_MODE_SGMII &&
++	    !phy_interface_mode_is_8023z(state->interface) &&
++	    !phy_interface_mode_is_rgmii(state->interface)) {
++		bitmap_zero(supported, __ETHTOOL_LINK_MODE_MASK_NBITS);
++		return;
++	}
++
+ 	/* Allow all the expected bits */
+ 	phylink_set(mask, Autoneg);
+ 	phylink_set_port_modes(mask);
+@@ -3222,7 +3232,7 @@ static void mvneta_validate(struct net_device *ndev, unsigned long *supported,
+ 	phylink_set(mask, 1000baseT_Full);
+ 	phylink_set(mask, 1000baseX_Full);
+ 
+-	if (state->interface != PHY_INTERFACE_MODE_1000BASEX) {
++	if (!phy_interface_mode_is_8023z(state->interface)) {
+ 		/* 10M and 100M are only supported in non-802.3z mode */
+ 		phylink_set(mask, 10baseT_Half);
+ 		phylink_set(mask, 10baseT_Full);
+@@ -3310,7 +3320,8 @@ static void mvneta_mac_config(struct net_device *ndev, unsigned int mode,
+ 	new_ctrl2 |= MVNETA_GMAC2_PORT_RGMII;
+ 
+ 	if (state->interface == PHY_INTERFACE_MODE_QSGMII ||
+-	    state->interface == PHY_INTERFACE_MODE_SGMII)
++	    state->interface == PHY_INTERFACE_MODE_SGMII ||
++	    phy_interface_mode_is_8023z(state->interface))
+ 		new_ctrl2 |= MVNETA_GMAC2_PCS_ENABLE;
+ 
+ 	if (!phylink_autoneg_inband(mode)) {
+@@ -4251,7 +4262,8 @@ static int mvneta_port_power_up(struct mvneta_port *pp, int phy_mode)
+ 
+ 	if (phy_mode == PHY_INTERFACE_MODE_QSGMII)
+ 		mvreg_write(pp, MVNETA_SERDES_CFG, MVNETA_QSGMII_SERDES_PROTO);
+-	else if (phy_mode == PHY_INTERFACE_MODE_SGMII)
++	else if (phy_mode == PHY_INTERFACE_MODE_SGMII ||
++		 phy_mode == PHY_INTERFACE_MODE_1000BASEX)
+ 		mvreg_write(pp, MVNETA_SERDES_CFG, MVNETA_SGMII_SERDES_PROTO);
+ 	else if (!phy_interface_mode_is_rgmii(phy_mode))
+ 		return -EINVAL;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90061-pinctrl-armada-37xx-account-for-const-type-of-of_dev.patch b/target/linux/mvebu/patches-4.14/90061-pinctrl-armada-37xx-account-for-const-type-of-of_dev.patch
new file mode 100644
index 0000000..2cd1445
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90061-pinctrl-armada-37xx-account-for-const-type-of-of_dev.patch
@@ -0,0 +1,40 @@
+From 9eb155c9b61e893dd8eece840f52362032529777 Mon Sep 17 00:00:00 2001
+From: Julia Lawall <Julia.Lawall@lip6.fr>
+Date: Tue, 2 Jan 2018 14:28:01 +0100
+Subject: [PATCH 061/126] pinctrl: armada-37xx: account for const type of
+ of_device_id.data
+
+The data field of an of_device_id structure has type const void *, so
+there is no need for a const-discarding cast when putting const values
+into such a structure.
+
+Done using Coccinelle.
+
+Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
+Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
+---
+ drivers/pinctrl/mvebu/pinctrl-armada-37xx.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+index c5fe7d4a9065..69bddeaad322 100644
+--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
++++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+@@ -944,11 +944,11 @@ static int armada_37xx_pinctrl_register(struct platform_device *pdev,
+ static const struct of_device_id armada_37xx_pinctrl_of_match[] = {
+ 	{
+ 		.compatible = "marvell,armada3710-sb-pinctrl",
+-		.data = (void *)&armada_37xx_pin_sb,
++		.data = &armada_37xx_pin_sb,
+ 	},
+ 	{
+ 		.compatible = "marvell,armada3710-nb-pinctrl",
+-		.data = (void *)&armada_37xx_pin_nb,
++		.data = &armada_37xx_pin_nb,
+ 	},
+ 	{ },
+ };
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90062-spi-a3700-Set-frequency-limits-at-startup.patch b/target/linux/mvebu/patches-4.14/90062-spi-a3700-Set-frequency-limits-at-startup.patch
new file mode 100644
index 0000000..d4dea9f
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90062-spi-a3700-Set-frequency-limits-at-startup.patch
@@ -0,0 +1,46 @@
+From ef6b6b8555c181df8e40994ae0cac82bd7ca08f6 Mon Sep 17 00:00:00 2001
+From: Maxime Chevallier <maxime.chevallier@smile.fr>
+Date: Wed, 17 Jan 2018 17:15:26 +0100
+Subject: [PATCH 062/126] spi: a3700: Set frequency limits at startup
+
+Armada 3700 SPI controller has an internal clock divider which can
+divide the parent clock frequency by up to 30.
+
+This patch sets the limits in the spi_controller fields so that we can
+detect when a non-supported frequency is requested by a device for a
+transfer.
+
+Signed-off-by: Maxime Chevallier <maxime.chevallier@smile.fr>
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/spi-armada-3700.c | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+diff --git a/drivers/spi/spi-armada-3700.c b/drivers/spi/spi-armada-3700.c
+index c11ea6c169a4..8048468277f3 100644
+--- a/drivers/spi/spi-armada-3700.c
++++ b/drivers/spi/spi-armada-3700.c
+@@ -27,6 +27,8 @@
+ 
+ #define DRIVER_NAME			"armada_3700_spi"
+ 
++#define A3700_SPI_MAX_SPEED_HZ		100000000
++#define A3700_SPI_MAX_PRESCALE		30
+ #define A3700_SPI_TIMEOUT		10
+ 
+ /* SPI Register Offest */
+@@ -823,6 +825,11 @@ static int a3700_spi_probe(struct platform_device *pdev)
+ 		goto error;
+ 	}
+ 
++	master->max_speed_hz = min_t(unsigned long, A3700_SPI_MAX_SPEED_HZ,
++					clk_get_rate(spi->clk));
++	master->min_speed_hz = DIV_ROUND_UP(clk_get_rate(spi->clk),
++						A3700_SPI_MAX_PRESCALE);
++
+ 	ret = a3700_spi_init(spi);
+ 	if (ret)
+ 		goto error_clk;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90063-spi-a3700-Allow-to-enable-or-disable-FIFO-mode.patch b/target/linux/mvebu/patches-4.14/90063-spi-a3700-Allow-to-enable-or-disable-FIFO-mode.patch
new file mode 100644
index 0000000..0fb2076
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90063-spi-a3700-Allow-to-enable-or-disable-FIFO-mode.patch
@@ -0,0 +1,51 @@
+From 13efe77a5072c17be1a2948f1900c86a8fc7ef37 Mon Sep 17 00:00:00 2001
+From: Maxime Chevallier <maxime.chevallier@smile.fr>
+Date: Wed, 17 Jan 2018 17:15:27 +0100
+Subject: [PATCH 063/126] spi: a3700: Allow to enable or disable FIFO mode
+
+The armada 3700 SPI controller allows to make transfers without using
+the 32 bytes RFIFO and WFIFO.
+
+This commit enable switching between FIFO and non-FIFO mode, which is
+necessary to implement full-duplex transfers.
+
+Signed-off-by: Maxime Chevallier <maxime.chevallier@smile.fr>
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/spi-armada-3700.c | 9 ++++++---
+ 1 file changed, 6 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/spi/spi-armada-3700.c b/drivers/spi/spi-armada-3700.c
+index 8048468277f3..b38730928186 100644
+--- a/drivers/spi/spi-armada-3700.c
++++ b/drivers/spi/spi-armada-3700.c
+@@ -186,12 +186,15 @@ static int a3700_spi_pin_mode_set(struct a3700_spi *a3700_spi,
+ 	return 0;
+ }
+ 
+-static void a3700_spi_fifo_mode_set(struct a3700_spi *a3700_spi)
++static void a3700_spi_fifo_mode_set(struct a3700_spi *a3700_spi, bool enable)
+ {
+ 	u32 val;
+ 
+ 	val = spireg_read(a3700_spi, A3700_SPI_IF_CFG_REG);
+-	val |= A3700_SPI_FIFO_MODE;
++	if (enable)
++		val |= A3700_SPI_FIFO_MODE;
++	else
++		val &= ~A3700_SPI_FIFO_MODE;
+ 	spireg_write(a3700_spi, A3700_SPI_IF_CFG_REG, val);
+ }
+ 
+@@ -299,7 +302,7 @@ static int a3700_spi_init(struct a3700_spi *a3700_spi)
+ 		a3700_spi_deactivate_cs(a3700_spi, i);
+ 
+ 	/* Enable FIFO mode */
+-	a3700_spi_fifo_mode_set(a3700_spi);
++	a3700_spi_fifo_mode_set(a3700_spi, true);
+ 
+ 	/* Set SPI mode */
+ 	a3700_spi_mode_set(a3700_spi, master->mode_bits);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90064-spi-a3700-Add-full-duplex-support.patch b/target/linux/mvebu/patches-4.14/90064-spi-a3700-Add-full-duplex-support.patch
new file mode 100644
index 0000000..c12c3ee
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90064-spi-a3700-Add-full-duplex-support.patch
@@ -0,0 +1,169 @@
+From 56576a05882c9e117316a4c736b4094e0785c7ff Mon Sep 17 00:00:00 2001
+From: Maxime Chevallier <maxime.chevallier@smile.fr>
+Date: Wed, 17 Jan 2018 17:15:28 +0100
+Subject: [PATCH 064/126] spi: a3700: Add full-duplex support
+
+The armada 3700 SPI controller has support for full-duplex transfers,
+but it can only be done without using the hardware FIFOs.
+
+A full duplex transfer is done by shifting 4 bytes at a time, or even
+one byte at a time for transfers less than 4 bytes long.
+
+While this method is perfectly suitable for small transfers, it is still
+slower than using the FIFOs.
+
+This commit implement full-duplex support, making sure that half-duplex
+transfers are still done using the FIFOs with the existing method.
+
+Some setup functions were moved around to make sure the controller is
+properly configured before beginning each transfer.
+
+This was tested on EspressoBin with a logical analyser, and a simple
+setup where MISO is connected on MOSI. Transfers were made from
+userspace using spidev and spi-pipe from the spi-tools project
+
+Signed-off-by: Maxime Chevallier <maxime.chevallier@smile.fr>
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/spi-armada-3700.c | 85 ++++++++++++++++++++++++++++++-----
+ 1 file changed, 73 insertions(+), 12 deletions(-)
+
+diff --git a/drivers/spi/spi-armada-3700.c b/drivers/spi/spi-armada-3700.c
+index b38730928186..a8576c89f713 100644
+--- a/drivers/spi/spi-armada-3700.c
++++ b/drivers/spi/spi-armada-3700.c
+@@ -421,15 +421,20 @@ static void a3700_spi_transfer_setup(struct spi_device *spi,
+ 				     struct spi_transfer *xfer)
+ {
+ 	struct a3700_spi *a3700_spi;
+-	unsigned int byte_len;
+ 
+ 	a3700_spi = spi_master_get_devdata(spi->master);
+ 
+ 	a3700_spi_clock_set(a3700_spi, xfer->speed_hz);
+ 
+-	byte_len = xfer->bits_per_word >> 3;
++	/* Use 4 bytes long transfers. Each transfer method has its way to deal
++	 * with the remaining bytes for non 4-bytes aligned transfers.
++	 */
++	a3700_spi_bytelen_set(a3700_spi, 4);
+ 
+-	a3700_spi_fifo_thres_set(a3700_spi, byte_len);
++	/* Initialize the working buffers */
++	a3700_spi->tx_buf  = xfer->tx_buf;
++	a3700_spi->rx_buf  = xfer->rx_buf;
++	a3700_spi->buf_len = xfer->len;
+ }
+ 
+ static void a3700_spi_set_cs(struct spi_device *spi, bool enable)
+@@ -584,27 +589,26 @@ static int a3700_spi_prepare_message(struct spi_master *master,
+ 	if (ret)
+ 		return ret;
+ 
+-	a3700_spi_bytelen_set(a3700_spi, 4);
+-
+ 	a3700_spi_mode_set(a3700_spi, spi->mode);
+ 
+ 	return 0;
+ }
+ 
+-static int a3700_spi_transfer_one(struct spi_master *master,
++static int a3700_spi_transfer_one_fifo(struct spi_master *master,
+ 				  struct spi_device *spi,
+ 				  struct spi_transfer *xfer)
+ {
+ 	struct a3700_spi *a3700_spi = spi_master_get_devdata(master);
+ 	int ret = 0, timeout = A3700_SPI_TIMEOUT;
+-	unsigned int nbits = 0;
++	unsigned int nbits = 0, byte_len;
+ 	u32 val;
+ 
+-	a3700_spi_transfer_setup(spi, xfer);
++	/* Make sure we use FIFO mode */
++	a3700_spi_fifo_mode_set(a3700_spi, true);
+ 
+-	a3700_spi->tx_buf  = xfer->tx_buf;
+-	a3700_spi->rx_buf  = xfer->rx_buf;
+-	a3700_spi->buf_len = xfer->len;
++	/* Configure FIFO thresholds */
++	byte_len = xfer->bits_per_word >> 3;
++	a3700_spi_fifo_thres_set(a3700_spi, byte_len);
+ 
+ 	if (xfer->tx_buf)
+ 		nbits = xfer->tx_nbits;
+@@ -739,6 +743,64 @@ static int a3700_spi_transfer_one(struct spi_master *master,
+ 	return ret;
+ }
+ 
++static int a3700_spi_transfer_one_full_duplex(struct spi_master *master,
++				  struct spi_device *spi,
++				  struct spi_transfer *xfer)
++{
++	struct a3700_spi *a3700_spi = spi_master_get_devdata(master);
++	u32 val_in, val_out;
++
++	/* Disable FIFO mode */
++	a3700_spi_fifo_mode_set(a3700_spi, false);
++
++	while (a3700_spi->buf_len) {
++
++		/* When we have less than 4 bytes to transfer, switch to 1 byte
++		 * mode. This is reset after each transfer
++		 */
++		if (a3700_spi->buf_len < 4)
++			a3700_spi_bytelen_set(a3700_spi, 1);
++
++		if (a3700_spi->byte_len == 1)
++			val_out = *a3700_spi->tx_buf;
++		else
++			val_out = cpu_to_le32(*(u32 *)a3700_spi->tx_buf);
++
++		spireg_write(a3700_spi, A3700_SPI_DATA_OUT_REG, val_out);
++
++		/* Wait for all the data to be shifted in / out */
++		while (!(spireg_read(a3700_spi, A3700_SPI_IF_CTRL_REG) &
++				A3700_SPI_XFER_DONE))
++			cpu_relax();
++
++		val_in = le32_to_cpu(spireg_read(a3700_spi,
++						 A3700_SPI_DATA_IN_REG));
++
++		memcpy(a3700_spi->rx_buf, &val_in, a3700_spi->byte_len);
++
++		a3700_spi->buf_len -= a3700_spi->byte_len;
++		a3700_spi->tx_buf += a3700_spi->byte_len;
++		a3700_spi->rx_buf += a3700_spi->byte_len;
++
++	}
++
++	spi_finalize_current_transfer(master);
++
++	return 0;
++}
++
++static int a3700_spi_transfer_one(struct spi_master *master,
++				  struct spi_device *spi,
++				  struct spi_transfer *xfer)
++{
++	a3700_spi_transfer_setup(spi, xfer);
++
++	if (xfer->tx_buf && xfer->rx_buf)
++		return a3700_spi_transfer_one_full_duplex(master, spi, xfer);
++
++	return a3700_spi_transfer_one_fifo(master, spi, xfer);
++}
++
+ static int a3700_spi_unprepare_message(struct spi_master *master,
+ 				       struct spi_message *message)
+ {
+@@ -788,7 +850,6 @@ static int a3700_spi_probe(struct platform_device *pdev)
+ 	master->transfer_one = a3700_spi_transfer_one;
+ 	master->unprepare_message = a3700_spi_unprepare_message;
+ 	master->set_cs = a3700_spi_set_cs;
+-	master->flags = SPI_MASTER_HALF_DUPLEX;
+ 	master->mode_bits |= (SPI_RX_DUAL | SPI_TX_DUAL |
+ 			      SPI_RX_QUAD | SPI_TX_QUAD);
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90065-spi-a3700-Remove-endianness-swapping-functions-when-.patch b/target/linux/mvebu/patches-4.14/90065-spi-a3700-Remove-endianness-swapping-functions-when-.patch
new file mode 100644
index 0000000..bd2ec1a
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90065-spi-a3700-Remove-endianness-swapping-functions-when-.patch
@@ -0,0 +1,51 @@
+From 47f4b866c6775c9ef31d19cb780140aebb4f64af Mon Sep 17 00:00:00 2001
+From: Maxime Chevallier <maxime.chevallier@smile.fr>
+Date: Wed, 24 Jan 2018 15:10:47 +0100
+Subject: [PATCH 065/126] spi: a3700: Remove endianness swapping functions when
+ accessing FIFOs
+
+Fixes the following sparse warnings :
+line 504: warning: incorrect type in assignment (different base types)
+line 504:    expected unsigned int [unsigned] [usertype] val
+line 504:    got restricted __le32 [usertype] <noident>
+line 527: warning: cast to restricted __le32
+
+This is solved by removing endian-converson functions, since the
+converted values are going through readl/writel anyway, which take care
+of the conversion.
+
+Fixes: 6fd6fd68c9e2 ("spi: armada-3700: Fix padding when sending not 4-byte aligned data")
+Signed-off-by: Maxime Chevallier <maxime.chevallier@smile.fr>
+Reviewed-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/spi-armada-3700.c | 5 ++---
+ 1 file changed, 2 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/spi/spi-armada-3700.c b/drivers/spi/spi-armada-3700.c
+index a8576c89f713..43ee0b56fe1c 100644
+--- a/drivers/spi/spi-armada-3700.c
++++ b/drivers/spi/spi-armada-3700.c
+@@ -501,7 +501,7 @@ static int a3700_spi_fifo_write(struct a3700_spi *a3700_spi)
+ 	u32 val;
+ 
+ 	while (!a3700_is_wfifo_full(a3700_spi) && a3700_spi->buf_len) {
+-		val = cpu_to_le32(*(u32 *)a3700_spi->tx_buf);
++		val = *(u32 *)a3700_spi->tx_buf;
+ 		spireg_write(a3700_spi, A3700_SPI_DATA_OUT_REG, val);
+ 		a3700_spi->buf_len -= 4;
+ 		a3700_spi->tx_buf += 4;
+@@ -524,9 +524,8 @@ static int a3700_spi_fifo_read(struct a3700_spi *a3700_spi)
+ 	while (!a3700_is_rfifo_empty(a3700_spi) && a3700_spi->buf_len) {
+ 		val = spireg_read(a3700_spi, A3700_SPI_DATA_IN_REG);
+ 		if (a3700_spi->buf_len >= 4) {
+-			u32 data = le32_to_cpu(val);
+ 
+-			memcpy(a3700_spi->rx_buf, &data, 4);
++			memcpy(a3700_spi->rx_buf, &val, 4);
+ 
+ 			a3700_spi->buf_len -= 4;
+ 			a3700_spi->rx_buf += 4;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90066-spi-a3700-Remove-endianness-swapping-for-full-duplex.patch b/target/linux/mvebu/patches-4.14/90066-spi-a3700-Remove-endianness-swapping-for-full-duplex.patch
new file mode 100644
index 0000000..12a10da
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90066-spi-a3700-Remove-endianness-swapping-for-full-duplex.patch
@@ -0,0 +1,66 @@
+From adfd337e7ad806e73ef86263ae2d30ff09c939e3 Mon Sep 17 00:00:00 2001
+From: Maxime Chevallier <maxime.chevallier@smile.fr>
+Date: Wed, 24 Jan 2018 15:10:48 +0100
+Subject: [PATCH 066/126] spi: a3700: Remove endianness swapping for
+ full-duplex transfers
+
+Fixes the following sparse warnings :
+line 767: warning: incorrect type in assignment (different base types)
+line 767:    expected unsigned int [unsigned] [assigned] [usertype] val_out
+line 767:    got restricted __le32 [usertype] <noident>
+line 776: warning: cast to restricted __le32
+
+This takes advantage of readl/writel to do the endianness reordering,
+and removes an extra variable in the function.
+
+Fixes: f68a7dcb91b7 ("spi: a3700: Add full-duplex support")
+Signed-off-by: Maxime Chevallier <maxime.chevallier@smile.fr>
+Reviewed-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Signed-off-by: Mark Brown <broonie@kernel.org>
+---
+ drivers/spi/spi-armada-3700.c | 13 ++++++-------
+ 1 file changed, 6 insertions(+), 7 deletions(-)
+
+diff --git a/drivers/spi/spi-armada-3700.c b/drivers/spi/spi-armada-3700.c
+index 43ee0b56fe1c..7dcb14d303eb 100644
+--- a/drivers/spi/spi-armada-3700.c
++++ b/drivers/spi/spi-armada-3700.c
+@@ -747,7 +747,7 @@ static int a3700_spi_transfer_one_full_duplex(struct spi_master *master,
+ 				  struct spi_transfer *xfer)
+ {
+ 	struct a3700_spi *a3700_spi = spi_master_get_devdata(master);
+-	u32 val_in, val_out;
++	u32 val;
+ 
+ 	/* Disable FIFO mode */
+ 	a3700_spi_fifo_mode_set(a3700_spi, false);
+@@ -761,21 +761,20 @@ static int a3700_spi_transfer_one_full_duplex(struct spi_master *master,
+ 			a3700_spi_bytelen_set(a3700_spi, 1);
+ 
+ 		if (a3700_spi->byte_len == 1)
+-			val_out = *a3700_spi->tx_buf;
++			val = *a3700_spi->tx_buf;
+ 		else
+-			val_out = cpu_to_le32(*(u32 *)a3700_spi->tx_buf);
++			val = *(u32 *)a3700_spi->tx_buf;
+ 
+-		spireg_write(a3700_spi, A3700_SPI_DATA_OUT_REG, val_out);
++		spireg_write(a3700_spi, A3700_SPI_DATA_OUT_REG, val);
+ 
+ 		/* Wait for all the data to be shifted in / out */
+ 		while (!(spireg_read(a3700_spi, A3700_SPI_IF_CTRL_REG) &
+ 				A3700_SPI_XFER_DONE))
+ 			cpu_relax();
+ 
+-		val_in = le32_to_cpu(spireg_read(a3700_spi,
+-						 A3700_SPI_DATA_IN_REG));
++		val = spireg_read(a3700_spi, A3700_SPI_DATA_IN_REG);
+ 
+-		memcpy(a3700_spi->rx_buf, &val_in, a3700_spi->byte_len);
++		memcpy(a3700_spi->rx_buf, &val, a3700_spi->byte_len);
+ 
+ 		a3700_spi->buf_len -= a3700_spi->byte_len;
+ 		a3700_spi->tx_buf += a3700_spi->byte_len;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90067-pinctrl-armada-37xx-Add-edge-both-type-gpio-irq-supp.patch b/target/linux/mvebu/patches-4.14/90067-pinctrl-armada-37xx-Add-edge-both-type-gpio-irq-supp.patch
new file mode 100644
index 0000000..b999d66
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90067-pinctrl-armada-37xx-Add-edge-both-type-gpio-irq-supp.patch
@@ -0,0 +1,109 @@
+From 790277cb0c42ade3b262cbbd21b60cc0436f7771 Mon Sep 17 00:00:00 2001
+From: Ken Ma <make@marvell.com>
+Date: Thu, 19 Oct 2017 15:10:03 +0200
+Subject: [PATCH 067/126] pinctrl: armada-37xx: Add edge both type gpio irq
+ support
+
+Current edge both type gpio irqs which need to swap polarity in each
+interrupt are not supported, this patch adds edge both type gpio irq
+support.
+
+Signed-off-by: Ken Ma <make@marvell.com>
+Signed-off-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
+---
+ drivers/pinctrl/mvebu/pinctrl-armada-37xx.c | 64 +++++++++++++++++++++
+ 1 file changed, 64 insertions(+)
+
+diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+index 69bddeaad322..2b4261b3c0f7 100644
+--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
++++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+@@ -585,6 +585,19 @@ static int armada_37xx_irq_set_type(struct irq_data *d, unsigned int type)
+ 	case IRQ_TYPE_EDGE_FALLING:
+ 		val |= (BIT(d->hwirq % GPIO_PER_REG));
+ 		break;
++	case IRQ_TYPE_EDGE_BOTH: {
++		u32 in_val, in_reg = INPUT_VAL;
++
++		armada_37xx_irq_update_reg(&in_reg, d);
++		regmap_read(info->regmap, in_reg, &in_val);
++
++		/* Set initial polarity based on current input level. */
++		if (in_val & d->mask)
++			val |= d->mask;		/* falling */
++		else
++			val &= ~d->mask;	/* rising */
++		break;
++	}
+ 	default:
+ 		spin_unlock_irqrestore(&info->irq_lock, flags);
+ 		return -EINVAL;
+@@ -595,6 +608,40 @@ static int armada_37xx_irq_set_type(struct irq_data *d, unsigned int type)
+ 	return 0;
+ }
+ 
++static int armada_37xx_edge_both_irq_swap_pol(struct armada_37xx_pinctrl *info,
++					     u32 pin_idx)
++{
++	u32 reg_idx = pin_idx / GPIO_PER_REG;
++	u32 bit_num = pin_idx % GPIO_PER_REG;
++	u32 p, l, ret;
++	unsigned long flags;
++
++	regmap_read(info->regmap, INPUT_VAL + 4*reg_idx, &l);
++
++	spin_lock_irqsave(&info->irq_lock, flags);
++	p = readl(info->base + IRQ_POL + 4 * reg_idx);
++	if ((p ^ l) & (1 << bit_num)) {
++		/*
++		 * For the gpios which are used for both-edge irqs, when their
++		 * interrupts happen, their input levels are changed,
++		 * yet their interrupt polarities are kept in old values, we
++		 * should synchronize their interrupt polarities; for example,
++		 * at first a gpio's input level is low and its interrupt
++		 * polarity control is "Detect rising edge", then the gpio has
++		 * a interrupt , its level turns to high, we should change its
++		 * polarity control to "Detect falling edge" correspondingly.
++		 */
++		p ^= 1 << bit_num;
++		writel(p, info->base + IRQ_POL + 4 * reg_idx);
++		ret = 0;
++	} else {
++		/* Spurious irq */
++		ret = -1;
++	}
++
++	spin_unlock_irqrestore(&info->irq_lock, flags);
++	return ret;
++}
+ 
+ static void armada_37xx_irq_handler(struct irq_desc *desc)
+ {
+@@ -618,6 +665,23 @@ static void armada_37xx_irq_handler(struct irq_desc *desc)
+ 			u32 hwirq = ffs(status) - 1;
+ 			u32 virq = irq_find_mapping(d, hwirq +
+ 						     i * GPIO_PER_REG);
++			u32 t = irq_get_trigger_type(virq);
++
++			if ((t & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH) {
++				/* Swap polarity (race with GPIO line) */
++				if (armada_37xx_edge_both_irq_swap_pol(info,
++					hwirq + i * GPIO_PER_REG)) {
++					/*
++					 * For spurious irq, which gpio level
++					 * is not as expected after incoming
++					 * edge, just ack the gpio irq.
++					 */
++					writel(1 << hwirq,
++					       info->base +
++					       IRQ_STATUS + 4 * i);
++					continue;
++				}
++			}
+ 
+ 			generic_handle_irq(virq);
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90068-pinctrl-armada-37xx-Stop-using-struct-gpio_chip.irq_.patch b/target/linux/mvebu/patches-4.14/90068-pinctrl-armada-37xx-Stop-using-struct-gpio_chip.irq_.patch
new file mode 100644
index 0000000..8703813
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90068-pinctrl-armada-37xx-Stop-using-struct-gpio_chip.irq_.patch
@@ -0,0 +1,49 @@
+From 6ac2248c03ba775796d4a4b6f5b5cf91aafc3daa Mon Sep 17 00:00:00 2001
+From: Thierry Reding <treding@nvidia.com>
+Date: Mon, 16 Oct 2017 14:40:23 +0200
+Subject: [PATCH 068/126] pinctrl: armada-37xx: Stop using struct
+ gpio_chip.irq_base
+
+The Armada 37xx driver always initializes the IRQ base to 0, hence the
+subtraction is a no-op. Remove the subtraction and thereby the last user
+of struct gpio_chip's .irq_base field.
+
+Note that this was also actually a bug and only worked because of the
+above assumption. If the IRQ base had been dynamically allocated, the
+subtraction would've caused the wrong mask to be generated since the
+struct irq_data.hwirq field is an index local to the IRQ domain. As a
+result, it should now be safe to also allocate this chip's IRQ base
+dynamically, unless there are consumers left that refer to the IRQs by
+their global number.
+
+Signed-off-by: Thierry Reding <treding@nvidia.com>
+Acked-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
+Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
+---
+ drivers/pinctrl/mvebu/pinctrl-armada-37xx.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+index 2b4261b3c0f7..639c3836259f 100644
+--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
++++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+@@ -700,14 +700,14 @@ static void armada_37xx_irq_handler(struct irq_desc *desc)
+ static unsigned int armada_37xx_irq_startup(struct irq_data *d)
+ {
+ 	struct gpio_chip *chip = irq_data_get_irq_chip_data(d);
+-	int irq = d->hwirq - chip->irq_base;
++
+ 	/*
+ 	 * The mask field is a "precomputed bitmask for accessing the
+ 	 * chip registers" which was introduced for the generic
+ 	 * irqchip framework. As we don't use this framework, we can
+ 	 * reuse this field for our own usage.
+ 	 */
+-	d->mask = BIT(irq % GPIO_PER_REG);
++	d->mask = BIT(d->hwirq % GPIO_PER_REG);
+ 
+ 	armada_37xx_irq_unmask(d);
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90069-pinctrl-armada-37xx-remove-unused-variable.patch b/target/linux/mvebu/patches-4.14/90069-pinctrl-armada-37xx-remove-unused-variable.patch
new file mode 100644
index 0000000..b788b18
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90069-pinctrl-armada-37xx-remove-unused-variable.patch
@@ -0,0 +1,35 @@
+From f6b3e75c2a2d604952c5350b126b818bc4333cde Mon Sep 17 00:00:00 2001
+From: Arnd Bergmann <arnd@arndb.de>
+Date: Thu, 2 Nov 2017 15:29:13 +0100
+Subject: [PATCH 069/126] pinctrl: armada-37xx: remove unused variable
+
+A cleanup left behind a temporary variable that is now unused:
+
+drivers/pinctrl/mvebu/pinctrl-armada-37xx.c: In function 'armada_37xx_irq_startup':
+drivers/pinctrl/mvebu/pinctrl-armada-37xx.c:693:20: error: unused variable 'chip' [-Werror=unused-variable]
+
+This removes the declarations as well.
+
+Fixes: 3ee9e605caea ("pinctrl: armada-37xx: Stop using struct gpio_chip.irq_base")
+Signed-off-by: Arnd Bergmann <arnd@arndb.de>
+Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
+---
+ drivers/pinctrl/mvebu/pinctrl-armada-37xx.c | 2 --
+ 1 file changed, 2 deletions(-)
+
+diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+index 639c3836259f..44897d4b9d88 100644
+--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
++++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+@@ -699,8 +699,6 @@ static void armada_37xx_irq_handler(struct irq_desc *desc)
+ 
+ static unsigned int armada_37xx_irq_startup(struct irq_data *d)
+ {
+-	struct gpio_chip *chip = irq_data_get_irq_chip_data(d);
+-
+ 	/*
+ 	 * The mask field is a "precomputed bitmask for accessing the
+ 	 * chip registers" which was introduced for the generic
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90070-net-dsa-mv88e6xxx-Fix-name-of-switch-88E6141.patch b/target/linux/mvebu/patches-4.14/90070-net-dsa-mv88e6xxx-Fix-name-of-switch-88E6141.patch
new file mode 100644
index 0000000..f54f2d2
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90070-net-dsa-mv88e6xxx-Fix-name-of-switch-88E6141.patch
@@ -0,0 +1,35 @@
+From 5a429594bac6ebffede0251d497a441d20025d8d Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig?= <u.kleine-koenig@pengutronix.de>
+Date: Tue, 20 Mar 2018 10:44:40 +0100
+Subject: [PATCH 070/126] net: dsa: mv88e6xxx: Fix name of switch 88E6141
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+The switch name is emitted in the kernel log, so having the right name
+there is nice.
+
+Fixes: 1558727a1c1b ("net: dsa: mv88e6xxx: Add support for ethernet switch 88E6141")
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 4fbc75b73433..14ae3a68d3c6 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -3333,7 +3333,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 	[MV88E6141] = {
+ 		.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6141,
+ 		.family = MV88E6XXX_FAMILY_6341,
+-		.name = "Marvell 88E6341",
++		.name = "Marvell 88E6141",
+ 		.num_databases = 4096,
+ 		.num_ports = 6,
+ 		.max_vid = 4095,
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90071-phy-add-phy_interface_mode_is_8023z-helper.patch b/target/linux/mvebu/patches-4.14/90071-phy-add-phy_interface_mode_is_8023z-helper.patch
new file mode 100644
index 0000000..c598088
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90071-phy-add-phy_interface_mode_is_8023z-helper.patch
@@ -0,0 +1,59 @@
+From 4e0b5317eb3da73e74b232782c31962f432fa178 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Fri, 1 Dec 2017 10:24:16 +0000
+Subject: [PATCH 071/126] phy: add phy_interface_mode_is_8023z() helper
+
+Add and use phy_interface_mode_is_8023z() helper to identify the
+interface modes that use 802.3z negotiation.  Use it in phylink's
+phylink_mac_an_restart().
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/phylink.c |  3 +--
+ include/linux/phy.h       | 14 ++++++++++++++
+ 2 files changed, 15 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index eb9d9ee24e40..8c125208b919 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -320,8 +320,7 @@ static void phylink_mac_config(struct phylink *pl,
+ static void phylink_mac_an_restart(struct phylink *pl)
+ {
+ 	if (pl->link_config.an_enabled &&
+-	    (pl->link_config.interface == PHY_INTERFACE_MODE_1000BASEX ||
+-	     pl->link_config.interface == PHY_INTERFACE_MODE_2500BASEX))
++	    phy_interface_mode_is_8023z(pl->link_config.interface))
+ 		pl->ops->mac_an_restart(pl->netdev);
+ }
+ 
+diff --git a/include/linux/phy.h b/include/linux/phy.h
+index efc04c2d92c9..7359e2bd14c1 100644
+--- a/include/linux/phy.h
++++ b/include/linux/phy.h
+@@ -760,6 +760,20 @@ static inline bool phy_interface_mode_is_rgmii(phy_interface_t mode)
+ 		mode <= PHY_INTERFACE_MODE_RGMII_TXID;
+ };
+ 
++/**
++ * phy_interface_mode_is_8023z() - does the phy interface mode use 802.3z
++ *   negotiation
++ * @mode: one of &enum phy_interface_t
++ *
++ * Returns true if the phy interface mode uses the 16-bit negotiation
++ * word as defined in 802.3z. (See 802.3-2015 37.2.1 Config_Reg encoding)
++ */
++static inline bool phy_interface_mode_is_8023z(phy_interface_t mode)
++{
++	return mode == PHY_INTERFACE_MODE_1000BASEX ||
++	       mode == PHY_INTERFACE_MODE_2500BASEX;
++}
++
+ /**
+  * phy_interface_is_rgmii - Convenience function for testing if a PHY interface
+  * is RGMII (all variants)
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90072-net-phy-Cosmetic-fixes-to-phylink-sfp-sfp-bus.c.patch b/target/linux/mvebu/patches-4.14/90072-net-phy-Cosmetic-fixes-to-phylink-sfp-sfp-bus.c.patch
new file mode 100644
index 0000000..80fb48d
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90072-net-phy-Cosmetic-fixes-to-phylink-sfp-sfp-bus.c.patch
@@ -0,0 +1,246 @@
+From 1fc64772bfb2179a44b622b03c597ed6303d621a Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Mon, 30 Oct 2017 21:42:57 -0700
+Subject: [PATCH 072/126] net: phy: Cosmetic fixes to phylink/sfp/sfp-bus.c
+
+Perform a number of stylistic changes to phylink.c, sfp.c and sfp-bus.c:
+
+- align with netdev-style comments
+- align function arguments to the opening parenthesis
+- remove blank lines
+- fixup a few lines over 80 columns
+
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/phylink.c | 13 ++++++-------
+ drivers/net/phy/sfp-bus.c | 11 +++--------
+ drivers/net/phy/sfp.c     | 27 +++++++++++++--------------
+ 3 files changed, 22 insertions(+), 29 deletions(-)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 8c125208b919..65dfdd76d7eb 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -360,7 +360,7 @@ static void phylink_get_fixed_state(struct phylink *pl, struct phylink_link_stat
+  *    1     1       0     1     TX
+  */
+ static void phylink_resolve_flow(struct phylink *pl,
+-	struct phylink_link_state *state)
++				 struct phylink_link_state *state)
+ {
+ 	int new_pause = 0;
+ 
+@@ -520,7 +520,8 @@ static int phylink_register_sfp(struct phylink *pl, struct device_node *np)
+ }
+ 
+ struct phylink *phylink_create(struct net_device *ndev, struct device_node *np,
+-	phy_interface_t iface, const struct phylink_mac_ops *ops)
++			       phy_interface_t iface,
++			       const struct phylink_mac_ops *ops)
+ {
+ 	struct phylink *pl;
+ 	int ret;
+@@ -602,7 +603,7 @@ void phylink_phy_change(struct phy_device *phydev, bool up, bool do_carrier)
+ 	phylink_run_resolve(pl);
+ 
+ 	netdev_dbg(pl->netdev, "phy link %s %s/%s/%s\n", up ? "up" : "down",
+-	           phy_modes(phydev->interface),
++		   phy_modes(phydev->interface),
+ 		   phy_speed_to_str(phydev->speed),
+ 		   phy_duplex_to_str(phydev->duplex));
+ }
+@@ -842,7 +843,7 @@ static void phylink_get_ksettings(const struct phylink_link_state *state,
+ }
+ 
+ int phylink_ethtool_ksettings_get(struct phylink *pl,
+-	struct ethtool_link_ksettings *kset)
++				  struct ethtool_link_ksettings *kset)
+ {
+ 	struct phylink_link_state link_state;
+ 
+@@ -889,7 +890,7 @@ int phylink_ethtool_ksettings_get(struct phylink *pl,
+ EXPORT_SYMBOL_GPL(phylink_ethtool_ksettings_get);
+ 
+ int phylink_ethtool_ksettings_set(struct phylink *pl,
+-	const struct ethtool_link_ksettings *kset)
++				  const struct ethtool_link_ksettings *kset)
+ {
+ 	struct ethtool_link_ksettings our_kset;
+ 	struct phylink_link_state config;
+@@ -1329,8 +1330,6 @@ int phylink_mii_ioctl(struct phylink *pl, struct ifreq *ifr, int cmd)
+ }
+ EXPORT_SYMBOL_GPL(phylink_mii_ioctl);
+ 
+-
+-
+ static int phylink_sfp_module_insert(void *upstream,
+ 				     const struct sfp_eeprom_id *id)
+ {
+diff --git a/drivers/net/phy/sfp-bus.c b/drivers/net/phy/sfp-bus.c
+index 3a0a05bbd45d..ffeeeae8e36a 100644
+--- a/drivers/net/phy/sfp-bus.c
++++ b/drivers/net/phy/sfp-bus.c
+@@ -26,7 +26,6 @@ struct sfp_bus {
+ 	bool started;
+ };
+ 
+-
+ int sfp_parse_port(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 		   unsigned long *support)
+ {
+@@ -208,7 +207,6 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ }
+ EXPORT_SYMBOL_GPL(sfp_parse_support);
+ 
+-
+ static LIST_HEAD(sfp_buses);
+ static DEFINE_MUTEX(sfp_mutex);
+ 
+@@ -299,7 +297,6 @@ static void sfp_unregister_bus(struct sfp_bus *bus)
+ 	bus->registered = false;
+ }
+ 
+-
+ int sfp_get_module_info(struct sfp_bus *bus, struct ethtool_modinfo *modinfo)
+ {
+ 	return bus->socket_ops->module_info(bus->sfp, modinfo);
+@@ -307,7 +304,7 @@ int sfp_get_module_info(struct sfp_bus *bus, struct ethtool_modinfo *modinfo)
+ EXPORT_SYMBOL_GPL(sfp_get_module_info);
+ 
+ int sfp_get_module_eeprom(struct sfp_bus *bus, struct ethtool_eeprom *ee,
+-	u8 *data)
++			  u8 *data)
+ {
+ 	return bus->socket_ops->module_eeprom(bus->sfp, ee, data);
+ }
+@@ -330,8 +327,8 @@ void sfp_upstream_stop(struct sfp_bus *bus)
+ EXPORT_SYMBOL_GPL(sfp_upstream_stop);
+ 
+ struct sfp_bus *sfp_register_upstream(struct device_node *np,
+-	struct net_device *ndev, void *upstream,
+-	const struct sfp_upstream_ops *ops)
++				      struct net_device *ndev, void *upstream,
++				      const struct sfp_upstream_ops *ops)
+ {
+ 	struct sfp_bus *bus = sfp_bus_get(np);
+ 	int ret = 0;
+@@ -369,7 +366,6 @@ void sfp_unregister_upstream(struct sfp_bus *bus)
+ }
+ EXPORT_SYMBOL_GPL(sfp_unregister_upstream);
+ 
+-
+ /* Socket driver entry points */
+ int sfp_add_phy(struct sfp_bus *bus, struct phy_device *phydev)
+ {
+@@ -396,7 +392,6 @@ void sfp_remove_phy(struct sfp_bus *bus)
+ }
+ EXPORT_SYMBOL_GPL(sfp_remove_phy);
+ 
+-
+ void sfp_link_up(struct sfp_bus *bus)
+ {
+ 	const struct sfp_upstream_ops *ops = sfp_get_upstream_ops(bus);
+diff --git a/drivers/net/phy/sfp.c b/drivers/net/phy/sfp.c
+index 30f5de87f5b5..ebb4cbd46bd9 100644
+--- a/drivers/net/phy/sfp.c
++++ b/drivers/net/phy/sfp.c
+@@ -88,15 +88,12 @@ static const enum gpiod_flags gpio_flags[] = {
+ #define T_PROBE_INIT	msecs_to_jiffies(300)
+ #define T_PROBE_RETRY	msecs_to_jiffies(100)
+ 
+-/*
+- * SFP modules appear to always have their PHY configured for bus address
++/* SFP modules appear to always have their PHY configured for bus address
+  * 0x56 (which with mdio-i2c, translates to a PHY address of 22).
+  */
+ #define SFP_PHY_ADDR	22
+ 
+-/*
+- * Give this long for the PHY to reset.
+- */
++/* Give this long for the PHY to reset. */
+ #define T_PHY_RESET_MS	50
+ 
+ static DEFINE_MUTEX(sfp_mutex);
+@@ -151,10 +148,10 @@ static void sfp_gpio_set_state(struct sfp *sfp, unsigned int state)
+ 		/* If the module is present, drive the signals */
+ 		if (sfp->gpio[GPIO_TX_DISABLE])
+ 			gpiod_direction_output(sfp->gpio[GPIO_TX_DISABLE],
+-						state & SFP_F_TX_DISABLE);
++					       state & SFP_F_TX_DISABLE);
+ 		if (state & SFP_F_RATE_SELECT)
+ 			gpiod_direction_output(sfp->gpio[GPIO_RATE_SELECT],
+-						state & SFP_F_RATE_SELECT);
++					       state & SFP_F_RATE_SELECT);
+ 	} else {
+ 		/* Otherwise, let them float to the pull-ups */
+ 		if (sfp->gpio[GPIO_TX_DISABLE])
+@@ -165,7 +162,7 @@ static void sfp_gpio_set_state(struct sfp *sfp, unsigned int state)
+ }
+ 
+ static int sfp__i2c_read(struct i2c_adapter *i2c, u8 bus_addr, u8 dev_addr,
+-	void *buf, size_t len)
++			 void *buf, size_t len)
+ {
+ 	struct i2c_msg msgs[2];
+ 	int ret;
+@@ -187,7 +184,7 @@ static int sfp__i2c_read(struct i2c_adapter *i2c, u8 bus_addr, u8 dev_addr,
+ }
+ 
+ static int sfp_i2c_read(struct sfp *sfp, bool a2, u8 addr, void *buf,
+-	size_t len)
++			size_t len)
+ {
+ 	return sfp__i2c_read(sfp->i2c, a2 ? 0x51 : 0x50, addr, buf, len);
+ }
+@@ -221,7 +218,6 @@ static int sfp_i2c_configure(struct sfp *sfp, struct i2c_adapter *i2c)
+ 	return 0;
+ }
+ 
+-
+ /* Interface */
+ static unsigned int sfp_get_state(struct sfp *sfp)
+ {
+@@ -474,7 +470,8 @@ static void sfp_sm_next(struct sfp *sfp, unsigned int state,
+ 	sfp_sm_set_timer(sfp, timeout);
+ }
+ 
+-static void sfp_sm_ins_next(struct sfp *sfp, unsigned int state, unsigned int timeout)
++static void sfp_sm_ins_next(struct sfp *sfp, unsigned int state,
++			    unsigned int timeout)
+ {
+ 	sfp->sm_mod_state = state;
+ 	sfp_sm_set_timer(sfp, timeout);
+@@ -549,7 +546,8 @@ static void sfp_sm_link_check_los(struct sfp *sfp)
+ static void sfp_sm_fault(struct sfp *sfp, bool warn)
+ {
+ 	if (sfp->sm_retries && !--sfp->sm_retries) {
+-		dev_err(sfp->dev, "module persistently indicates fault, disabling\n");
++		dev_err(sfp->dev,
++			"module persistently indicates fault, disabling\n");
+ 		sfp_sm_next(sfp, SFP_S_TX_DISABLE, 0);
+ 	} else {
+ 		if (warn)
+@@ -648,7 +646,8 @@ static int sfp_sm_mod_probe(struct sfp *sfp)
+ 	date[7] = sfp->id.ext.datecode[1];
+ 	date[8] = '\0';
+ 
+-	dev_info(sfp->dev, "module %s %s rev %s sn %s dc %s\n", vendor, part, rev, sn, date);
++	dev_info(sfp->dev, "module %s %s rev %s sn %s dc %s\n",
++		 vendor, part, rev, sn, date);
+ 	dev_info(sfp->dev, "  %s connector, encoding %s, nominal bitrate %u.%uGbps +%u%% -%u%%\n",
+ 		 sfp_connector(sfp->id.base.connector),
+ 		 sfp_encoding(sfp->id.base.encoding),
+@@ -919,7 +918,7 @@ static int sfp_module_info(struct sfp *sfp, struct ethtool_modinfo *modinfo)
+ }
+ 
+ static int sfp_module_eeprom(struct sfp *sfp, struct ethtool_eeprom *ee,
+-	u8 *data)
++			     u8 *data)
+ {
+ 	unsigned int first, last, len;
+ 	int ret;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90073-sfp-fix-sparse-warning.patch b/target/linux/mvebu/patches-4.14/90073-sfp-fix-sparse-warning.patch
new file mode 100644
index 0000000..901951f
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90073-sfp-fix-sparse-warning.patch
@@ -0,0 +1,30 @@
+From 2de4d6fa6b53359ff3305523c86f74e097ff6c2b Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Fri, 1 Dec 2017 10:24:58 +0000
+Subject: [PATCH 073/126] sfp: fix sparse warning
+
+drivers/net/phy/sfp-bus.c:298:13: warning: context imbalance in 'sfp_bus_release' - wrong count at exit
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/sfp-bus.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/net/phy/sfp-bus.c b/drivers/net/phy/sfp-bus.c
+index ffeeeae8e36a..961ef6f5f93d 100644
+--- a/drivers/net/phy/sfp-bus.c
++++ b/drivers/net/phy/sfp-bus.c
+@@ -246,7 +246,7 @@ static struct sfp_bus *sfp_bus_get(struct device_node *np)
+ 	return found;
+ }
+ 
+-static void sfp_bus_release(struct kref *kref) __releases(sfp_mutex)
++static void sfp_bus_release(struct kref *kref)
+ {
+ 	struct sfp_bus *bus = container_of(kref, struct sfp_bus, kref);
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90074-sfp-don-t-guess-support-from-connector-type.patch b/target/linux/mvebu/patches-4.14/90074-sfp-don-t-guess-support-from-connector-type.patch
new file mode 100644
index 0000000..dbd65a8
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90074-sfp-don-t-guess-support-from-connector-type.patch
@@ -0,0 +1,57 @@
+From ec218ef9e62783bb83fb10c8afbb5ecff555c5c4 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Fri, 29 Dec 2017 12:15:17 +0000
+Subject: [PATCH 074/126] sfp: don't guess support from connector type
+
+Don't try to guess the support mask from the connector type - this is
+mostly irrelevant to the speeds that the transceiver supports.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/sfp-bus.c | 29 -----------------------------
+ 1 file changed, 29 deletions(-)
+
+diff --git a/drivers/net/phy/sfp-bus.c b/drivers/net/phy/sfp-bus.c
+index 961ef6f5f93d..b6f198183b89 100644
+--- a/drivers/net/phy/sfp-bus.c
++++ b/drivers/net/phy/sfp-bus.c
+@@ -175,35 +175,6 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 		if (id->base.br_nominal >= 12)
+ 			phylink_set(support, 1000baseX_Full);
+ 	}
+-
+-	switch (id->base.connector) {
+-	case SFP_CONNECTOR_SC:
+-	case SFP_CONNECTOR_FIBERJACK:
+-	case SFP_CONNECTOR_LC:
+-	case SFP_CONNECTOR_MT_RJ:
+-	case SFP_CONNECTOR_MU:
+-	case SFP_CONNECTOR_OPTICAL_PIGTAIL:
+-		break;
+-
+-	case SFP_CONNECTOR_UNSPEC:
+-		if (id->base.e1000_base_t)
+-			break;
+-
+-	case SFP_CONNECTOR_SG: /* guess */
+-	case SFP_CONNECTOR_MPO_1X12:
+-	case SFP_CONNECTOR_MPO_2X16:
+-	case SFP_CONNECTOR_HSSDC_II:
+-	case SFP_CONNECTOR_COPPER_PIGTAIL:
+-	case SFP_CONNECTOR_NOSEPARATE:
+-	case SFP_CONNECTOR_MXC_2X16:
+-	default:
+-		/* a guess at the supported link modes */
+-		dev_warn(bus->sfp_dev,
+-			 "Guessing link modes, please report...\n");
+-		phylink_set(support, 1000baseT_Half);
+-		phylink_set(support, 1000baseT_Full);
+-		break;
+-	}
+ }
+ EXPORT_SYMBOL_GPL(sfp_parse_support);
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90075-sfp-add-support-for-1000Base-PX-and-1000Base-BX10.patch b/target/linux/mvebu/patches-4.14/90075-sfp-add-support-for-1000Base-PX-and-1000Base-BX10.patch
new file mode 100644
index 0000000..385c0fc
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90075-sfp-add-support-for-1000Base-PX-and-1000Base-BX10.patch
@@ -0,0 +1,60 @@
+From 37f774883d4bf543413cd80c42e2d79942415eda Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Fri, 29 Dec 2017 12:15:23 +0000
+Subject: [PATCH 075/126] sfp: add support for 1000Base-PX and 1000Base-BX10
+
+Add support for decoding the transceiver information for 1000Base-PX and
+1000Base-BX10.  These use 1000BASE-X protocol.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/sfp-bus.c | 21 +++++++++++++++++++++
+ 1 file changed, 21 insertions(+)
+
+diff --git a/drivers/net/phy/sfp-bus.c b/drivers/net/phy/sfp-bus.c
+index b6f198183b89..902d64f86f63 100644
+--- a/drivers/net/phy/sfp-bus.c
++++ b/drivers/net/phy/sfp-bus.c
+@@ -120,10 +120,26 @@ EXPORT_SYMBOL_GPL(sfp_parse_interface);
+ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 		       unsigned long *support)
+ {
++	unsigned int br_min, br_nom, br_max;
++
+ 	phylink_set(support, Autoneg);
+ 	phylink_set(support, Pause);
+ 	phylink_set(support, Asym_Pause);
+ 
++	/* Decode the bitrate information to MBd */
++	br_min = br_nom = br_max = 0;
++	if (id->base.br_nominal) {
++		if (id->base.br_nominal != 255) {
++			br_nom = id->base.br_nominal * 100;
++			br_min = br_nom + id->base.br_nominal * id->ext.br_min;
++			br_max = br_nom + id->base.br_nominal * id->ext.br_max;
++		} else if (id->ext.br_max) {
++			br_nom = 250 * id->ext.br_max;
++			br_max = br_nom + br_nom * id->ext.br_min / 100;
++			br_min = br_nom - br_nom * id->ext.br_min / 100;
++		}
++	}
++
+ 	/* Set ethtool support from the compliance fields. */
+ 	if (id->base.e10g_base_sr)
+ 		phylink_set(support, 10000baseSR_Full);
+@@ -142,6 +158,11 @@ void sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,
+ 		phylink_set(support, 1000baseT_Full);
+ 	}
+ 
++	/* 1000Base-PX or 1000Base-BX10 */
++	if ((id->base.e_base_px || id->base.e_base_bx10) &&
++	    br_min <= 1300 && br_max >= 1200)
++		phylink_set(support, 1000baseX_Full);
++
+ 	switch (id->base.extended_cc) {
+ 	case 0x00: /* Unspecified */
+ 		break;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90076-net-dsa-Add-PHYLINK-switch-operations.patch b/target/linux/mvebu/patches-4.14/90076-net-dsa-Add-PHYLINK-switch-operations.patch
new file mode 100644
index 0000000..be82891
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90076-net-dsa-Add-PHYLINK-switch-operations.patch
@@ -0,0 +1,102 @@
+From c4d80b5c828eadf96827ed2b10fb769745898b1a Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Thu, 10 May 2018 13:17:32 -0700
+Subject: [PATCH 076/126] net: dsa: Add PHYLINK switch operations
+
+In preparation for adding support for PHYLINK within DSA, define a number of
+operations that we will need and that switch drivers can start implementing.
+Proper integration with PHYLINK will follow in subsequent patches.
+
+We start selecting PHYLINK (which implies PHYLIB) in net/dsa/Kconfig
+such that drivers can be guaranteed that this dependency is properly
+taken care of and can start referencing PHYLINK helper functions without
+requiring stubs or anything.
+
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ include/net/dsa.h | 24 ++++++++++++++++++++++++
+ net/dsa/Kconfig   |  2 +-
+ net/dsa/slave.c   |  5 +++++
+ 3 files changed, 30 insertions(+), 1 deletion(-)
+
+diff --git a/include/net/dsa.h b/include/net/dsa.h
+index dd44d6ce1097..bc8a2b4872dc 100644
+--- a/include/net/dsa.h
++++ b/include/net/dsa.h
+@@ -19,12 +19,14 @@
+ #include <linux/workqueue.h>
+ #include <linux/of.h>
+ #include <linux/ethtool.h>
++#include <linux/phy.h>
+ #include <net/devlink.h>
+ #include <net/switchdev.h>
+ 
+ struct tc_action;
+ struct phy_device;
+ struct fixed_phy_status;
++struct phylink_link_state;
+ 
+ enum dsa_tag_protocol {
+ 	DSA_TAG_PROTO_NONE = 0,
+@@ -313,6 +315,28 @@ struct dsa_switch_ops {
+ 	void	(*fixed_link_update)(struct dsa_switch *ds, int port,
+ 				struct fixed_phy_status *st);
+ 
++	/*
++	 * PHYLINK integration
++	 */
++	void	(*phylink_validate)(struct dsa_switch *ds, int port,
++				    unsigned long *supported,
++				    struct phylink_link_state *state);
++	int	(*phylink_mac_link_state)(struct dsa_switch *ds, int port,
++					  struct phylink_link_state *state);
++	void	(*phylink_mac_config)(struct dsa_switch *ds, int port,
++				      unsigned int mode,
++				      const struct phylink_link_state *state);
++	void	(*phylink_mac_an_restart)(struct dsa_switch *ds, int port);
++	void	(*phylink_mac_link_down)(struct dsa_switch *ds, int port,
++					 unsigned int mode,
++					 phy_interface_t interface);
++	void	(*phylink_mac_link_up)(struct dsa_switch *ds, int port,
++				       unsigned int mode,
++				       phy_interface_t interface,
++				       struct phy_device *phydev);
++	void	(*phylink_fixed_state)(struct dsa_switch *ds, int port,
++				       struct phylink_link_state *state);
++
+ 	/*
+ 	 * ethtool hardware statistics.
+ 	 */
+diff --git a/net/dsa/Kconfig b/net/dsa/Kconfig
+index cc5f8f971689..250254230ebb 100644
+--- a/net/dsa/Kconfig
++++ b/net/dsa/Kconfig
+@@ -8,7 +8,7 @@ config NET_DSA
+ 	tristate "Distributed Switch Architecture"
+ 	depends on HAVE_NET_DSA && MAY_USE_DEVLINK
+ 	select NET_SWITCHDEV
+-	select PHYLIB
++	select PHYLINK
+ 	---help---
+ 	  Say Y if you want to enable support for the hardware switches supported
+ 	  by the Distributed Switch Architecture.
+diff --git a/net/dsa/slave.c b/net/dsa/slave.c
+index b14d530a32b1..cd4925f83ba4 100644
+--- a/net/dsa/slave.c
++++ b/net/dsa/slave.c
+@@ -1130,6 +1130,11 @@ static int dsa_slave_phy_connect(struct dsa_slave_priv *p,
+ 				  p->phy_interface);
+ }
+ 
++void dsa_port_phylink_mac_change(struct dsa_switch *ds, int port, bool up)
++{
++}
++EXPORT_SYMBOL_GPL(dsa_port_phylink_mac_change);
++
+ static int dsa_slave_phy_setup(struct dsa_slave_priv *p,
+ 				struct net_device *slave_dev)
+ {
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90077-net-dsa-Eliminate-dsa_slave_get_link.patch b/target/linux/mvebu/patches-4.14/90077-net-dsa-Eliminate-dsa_slave_get_link.patch
new file mode 100644
index 0000000..0146ec7
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90077-net-dsa-Eliminate-dsa_slave_get_link.patch
@@ -0,0 +1,50 @@
+From 2bbe15ce77bfe8913750a4ecfda3f68edb14ef40 Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Thu, 10 May 2018 13:17:34 -0700
+Subject: [PATCH 077/126] net: dsa: Eliminate dsa_slave_get_link()
+
+Since we use PHYLIB to manage the per-port link indication, this will
+also be reflected correctly in the network device's carrier state, so we
+can use ethtool_op_get_link() instead.
+
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ net/dsa/slave.c | 14 +-------------
+ 1 file changed, 1 insertion(+), 13 deletions(-)
+
+diff --git a/net/dsa/slave.c b/net/dsa/slave.c
+index cd4925f83ba4..3460cba3d315 100644
+--- a/net/dsa/slave.c
++++ b/net/dsa/slave.c
+@@ -503,18 +503,6 @@ static int dsa_slave_nway_reset(struct net_device *dev)
+ 	return -EOPNOTSUPP;
+ }
+ 
+-static u32 dsa_slave_get_link(struct net_device *dev)
+-{
+-	struct dsa_slave_priv *p = netdev_priv(dev);
+-
+-	if (p->phy != NULL) {
+-		genphy_update_link(p->phy);
+-		return p->phy->link;
+-	}
+-
+-	return -EOPNOTSUPP;
+-}
+-
+ static int dsa_slave_get_eeprom_len(struct net_device *dev)
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+@@ -1016,7 +1004,7 @@ static const struct ethtool_ops dsa_slave_ethtool_ops = {
+ 	.get_regs_len		= dsa_slave_get_regs_len,
+ 	.get_regs		= dsa_slave_get_regs,
+ 	.nway_reset		= dsa_slave_nway_reset,
+-	.get_link		= dsa_slave_get_link,
++	.get_link		= ethtool_op_get_link,
+ 	.get_eeprom_len		= dsa_slave_get_eeprom_len,
+ 	.get_eeprom		= dsa_slave_get_eeprom,
+ 	.set_eeprom		= dsa_slave_set_eeprom,
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90078-net-phy-phylink-Provide-PHY-interface-to-mac_link_-u.patch b/target/linux/mvebu/patches-4.14/90078-net-phy-phylink-Provide-PHY-interface-to-mac_link_-u.patch
new file mode 100644
index 0000000..1db6698
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90078-net-phy-phylink-Provide-PHY-interface-to-mac_link_-u.patch
@@ -0,0 +1,84 @@
+From 6fb63181946b5fae8b757cd2f2c363c2b7a47388 Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Wed, 28 Mar 2018 15:44:15 -0700
+Subject: [PATCH 078/126] net: phy: phylink: Provide PHY interface to
+ mac_link_{up, down}
+
+In preparation for having DSA transition entirely to PHYLINK, we need to pass a
+PHY interface type to the mac_link_{up,down} callbacks because we may have to
+make decisions on that (e.g: turn on/off RGMII interfaces etc.). We do not pass
+an entire phylink_link_state because not all parameters (pause, duplex etc.) are
+defined when the link is down, only link and interface are.
+
+Update mvneta accordingly since it currently implements phylink_mac_ops.
+
+Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 4 +++-
+ drivers/net/phy/phylink.c             | 4 +++-
+ include/linux/phylink.h               | 4 +++-
+ 3 files changed, 9 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index 003fb1fd92f3..a837a053bdad 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -3396,7 +3396,8 @@ static void mvneta_set_eee(struct mvneta_port *pp, bool enable)
+ 	mvreg_write(pp, MVNETA_LPI_CTRL_1, lpi_ctl1);
+ }
+ 
+-static void mvneta_mac_link_down(struct net_device *ndev, unsigned int mode)
++static void mvneta_mac_link_down(struct net_device *ndev, unsigned int mode,
++				 phy_interface_t interface)
+ {
+ 	struct mvneta_port *pp = netdev_priv(ndev);
+ 	u32 val;
+@@ -3415,6 +3416,7 @@ static void mvneta_mac_link_down(struct net_device *ndev, unsigned int mode)
+ }
+ 
+ static void mvneta_mac_link_up(struct net_device *ndev, unsigned int mode,
++			       phy_interface_t interface,
+ 			       struct phy_device *phy)
+ {
+ 	struct mvneta_port *pp = netdev_priv(ndev);
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 65dfdd76d7eb..0a5abf1be642 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -462,10 +462,12 @@ static void phylink_resolve(struct work_struct *w)
+ 	if (link_state.link != netif_carrier_ok(ndev)) {
+ 		if (!link_state.link) {
+ 			netif_carrier_off(ndev);
+-			pl->ops->mac_link_down(ndev, pl->link_an_mode);
++			pl->ops->mac_link_down(ndev, pl->link_an_mode,
++					       pl->phy_state.interface);
+ 			netdev_info(ndev, "Link is Down\n");
+ 		} else {
+ 			pl->ops->mac_link_up(ndev, pl->link_an_mode,
++					     pl->phy_state.interface,
+ 					     pl->phydev);
+ 
+ 			netif_carrier_on(ndev);
+diff --git a/include/linux/phylink.h b/include/linux/phylink.h
+index 76f054f39684..c241a0b6c29c 100644
+--- a/include/linux/phylink.h
++++ b/include/linux/phylink.h
+@@ -95,8 +95,10 @@ struct phylink_mac_ops {
+ 	 */
+ 	void (*mac_an_restart)(struct net_device *ndev);
+ 
+-	void (*mac_link_down)(struct net_device *, unsigned int mode);
++	void (*mac_link_down)(struct net_device *, unsigned int mode,
++			      phy_interface_t interface);
+ 	void (*mac_link_up)(struct net_device *, unsigned int mode,
++			    phy_interface_t interface,
+ 			    struct phy_device *);
+ };
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90079-net-phy-phylink-Allow-specifying-PHY-device-flags.patch b/target/linux/mvebu/patches-4.14/90079-net-phy-phylink-Allow-specifying-PHY-device-flags.patch
new file mode 100644
index 0000000..5916a0e
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90079-net-phy-phylink-Allow-specifying-PHY-device-flags.patch
@@ -0,0 +1,71 @@
+From 3e301ce5884a77dae23207dcbda9a24e85f42de7 Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Tue, 12 Dec 2017 16:00:25 -0800
+Subject: [PATCH 079/126] net: phy: phylink: Allow specifying PHY device flags
+
+In order to let subsystems like DSA fully utilize PHYLINK, we need to be able
+to communicate phy_device::flags from of_phy_{connect,attach} even when using
+PHYLINK APIs.
+
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 2 +-
+ drivers/net/phy/phylink.c             | 6 ++++--
+ include/linux/phylink.h               | 2 +-
+ 3 files changed, 6 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index a837a053bdad..2986f8f1ae4a 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -3449,7 +3449,7 @@ static const struct phylink_mac_ops mvneta_phylink_ops = {
+ static int mvneta_mdio_probe(struct mvneta_port *pp)
+ {
+ 	struct ethtool_wolinfo wol = { .cmd = ETHTOOL_GWOL };
+-	int err = phylink_of_phy_connect(pp->phylink, pp->dn);
++	int err = phylink_of_phy_connect(pp->phylink, pp->dn, 0);
+ 	if (err)
+ 		netdev_err(pp->dev, "could not attach PHY\n");
+ 
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 0a5abf1be642..1480979da9de 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -687,7 +687,8 @@ int phylink_connect_phy(struct phylink *pl, struct phy_device *phy)
+ }
+ EXPORT_SYMBOL_GPL(phylink_connect_phy);
+ 
+-int phylink_of_phy_connect(struct phylink *pl, struct device_node *dn)
++int phylink_of_phy_connect(struct phylink *pl, struct device_node *dn,
++			   u32 flags)
+ {
+ 	struct device_node *phy_node;
+ 	struct phy_device *phy_dev;
+@@ -711,7 +712,8 @@ int phylink_of_phy_connect(struct phylink *pl, struct device_node *dn)
+ 		return 0;
+ 	}
+ 
+-	phy_dev = of_phy_attach(pl->netdev, phy_node, 0, pl->link_interface);
++	phy_dev = of_phy_attach(pl->netdev, phy_node, flags,
++				pl->link_interface);
+ 	/* We're done with the phy_node handle */
+ 	of_node_put(phy_node);
+ 
+diff --git a/include/linux/phylink.h b/include/linux/phylink.h
+index c241a0b6c29c..afb74404e8bf 100644
+--- a/include/linux/phylink.h
++++ b/include/linux/phylink.h
+@@ -107,7 +107,7 @@ struct phylink *phylink_create(struct net_device *, struct device_node *,
+ void phylink_destroy(struct phylink *);
+ 
+ int phylink_connect_phy(struct phylink *, struct phy_device *);
+-int phylink_of_phy_connect(struct phylink *, struct device_node *);
++int phylink_of_phy_connect(struct phylink *, struct device_node *, u32 flags);
+ void phylink_disconnect_phy(struct phylink *);
+ 
+ void phylink_mac_change(struct phylink *, bool up);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90080-net-phy-phylink-Use-PHY-device-interface-if-N-A.patch b/target/linux/mvebu/patches-4.14/90080-net-phy-phylink-Use-PHY-device-interface-if-N-A.patch
new file mode 100644
index 0000000..d5f7b4f
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90080-net-phy-phylink-Use-PHY-device-interface-if-N-A.patch
@@ -0,0 +1,35 @@
+From 174428567d991f4123c536b6dde0e97c21d6b98f Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Tue, 12 Dec 2017 16:00:26 -0800
+Subject: [PATCH 080/126] net: phy: phylink: Use PHY device interface if N/A
+
+We may not always be able to resolve a correct phy_interface_t value before
+actually connecting to the PHY device, when that happens, just have
+phylink_connect_phy() utilize what the PHY device/driver provided.
+
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/phylink.c | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 1480979da9de..ddba452c2534 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -675,6 +675,12 @@ int phylink_connect_phy(struct phylink *pl, struct phy_device *phy)
+ {
+ 	int ret;
+ 
++	/* Use PHY device/driver interface */
++	if (pl->link_interface == PHY_INTERFACE_MODE_NA) {
++		pl->link_interface = phy->interface;
++		pl->link_config.interface = pl->link_interface;
++	}
++
+ 	ret = phy_attach_direct(pl->netdev, phy, 0, pl->link_interface);
+ 	if (ret)
+ 		return ret;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90081-net-phy-phylink-Remove-error-message.patch b/target/linux/mvebu/patches-4.14/90081-net-phy-phylink-Remove-error-message.patch
new file mode 100644
index 0000000..aa06713
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90081-net-phy-phylink-Remove-error-message.patch
@@ -0,0 +1,35 @@
+From ee69787b4f2cbe2fc60e08b5288e0879cc328503 Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Tue, 12 Dec 2017 16:00:27 -0800
+Subject: [PATCH 081/126] net: phy: phylink: Remove error message
+
+Some subsystems like DSA may be trying to connect to a PHY through OF first,
+and then attempt a connect using a local MDIO bus, remove the error message:
+"unable to find PHY node" so we can let MAC drivers whether to print it or not.
+
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/phy/phylink.c | 4 +---
+ 1 file changed, 1 insertion(+), 3 deletions(-)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index ddba452c2534..4b63bf9abb32 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -711,10 +711,8 @@ int phylink_of_phy_connect(struct phylink *pl, struct device_node *dn,
+ 		phy_node = of_parse_phandle(dn, "phy-device", 0);
+ 
+ 	if (!phy_node) {
+-		if (pl->link_an_mode == MLO_AN_PHY) {
+-			netdev_err(pl->netdev, "unable to find PHY node\n");
++		if (pl->link_an_mode == MLO_AN_PHY)
+ 			return -ENODEV;
+-		}
+ 		return 0;
+ 	}
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90082-net-dsa-Plug-in-PHYLINK-support.patch b/target/linux/mvebu/patches-4.14/90082-net-dsa-Plug-in-PHYLINK-support.patch
new file mode 100644
index 0000000..0f33035
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90082-net-dsa-Plug-in-PHYLINK-support.patch
@@ -0,0 +1,577 @@
+From 1895108370e472e0102a8c90b3ab0d973649e0d3 Mon Sep 17 00:00:00 2001
+From: Florian Fainelli <f.fainelli@gmail.com>
+Date: Thu, 10 May 2018 13:17:36 -0700
+Subject: [PATCH 082/126] net: dsa: Plug in PHYLINK support
+
+Add support for PHYLINK within the DSA subsystem in order to support more
+complex devices such as pluggable (SFP) and non-pluggable (SFF) modules, 10G
+PHYs, and traditional PHYs. Using PHYLINK allows us to drop some amount of
+complexity we had while probing fixed and non-fixed PHYs using Device Tree.
+
+Because PHYLINK separates the Ethernet MAC/port configuration into different
+stages, we let switch drivers implement those, and for now, we maintain
+functionality by calling dsa_slave_adjust_link() during
+phylink_mac_link_{up,down} which provides semantically equivalent steps.
+
+Drivers willing to take advantage of PHYLINK should implement the phylink_mac_*
+operations that DSA wraps.
+
+We cannot quite remove the adjust_link() callback just yet, because a number of
+drivers rely on that for configuring their "CPU" and "DSA" ports, this is done
+dsa_port_setup_phy_of() and dsa_port_fixed_link_register_of() still.
+
+Drivers that utilize fixed links for user-facing ports (e.g: bcm_sf2) will need
+to implement phylink_mac_ops from now on to preserve functionality, since PHYLINK
+*does not* create a phy_device instance for fixed links.
+
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ include/net/dsa.h  |   4 +
+ net/dsa/dsa_priv.h |  10 --
+ net/dsa/slave.c    | 293 +++++++++++++++++++++------------------------
+ 3 files changed, 138 insertions(+), 169 deletions(-)
+
+diff --git a/include/net/dsa.h b/include/net/dsa.h
+index bc8a2b4872dc..464397c41088 100644
+--- a/include/net/dsa.h
++++ b/include/net/dsa.h
+@@ -187,6 +187,7 @@ struct dsa_port {
+ 	u8			stp_state;
+ 	struct net_device	*bridge_dev;
+ 	struct devlink_port	devlink_port;
++	struct phylink		*pl;
+ 	/*
+ 	 * Original copy of the master netdev ethtool_ops
+ 	 */
+@@ -499,4 +500,7 @@ static inline int dsa_switch_resume(struct dsa_switch *ds)
+ }
+ #endif /* CONFIG_PM_SLEEP */
+ 
++
++void dsa_port_phylink_mac_change(struct dsa_switch *ds, int port, bool up);
++
+ #endif
+diff --git a/net/dsa/dsa_priv.h b/net/dsa/dsa_priv.h
+index 9c3eeb72462d..ae8eb8ce7d97 100644
+--- a/net/dsa/dsa_priv.h
++++ b/net/dsa/dsa_priv.h
+@@ -75,16 +75,6 @@ struct dsa_slave_priv {
+ 	/* DSA port data, such as switch, port index, etc. */
+ 	struct dsa_port		*dp;
+ 
+-	/*
+-	 * The phylib phy_device pointer for the PHY connected
+-	 * to this port.
+-	 */
+-	struct phy_device	*phy;
+-	phy_interface_t		phy_interface;
+-	int			old_link;
+-	int			old_pause;
+-	int			old_duplex;
+-
+ #ifdef CONFIG_NET_POLL_CONTROLLER
+ 	struct netpoll		*netpoll;
+ #endif
+diff --git a/net/dsa/slave.c b/net/dsa/slave.c
+index 3460cba3d315..0c0e6ddef2e6 100644
+--- a/net/dsa/slave.c
++++ b/net/dsa/slave.c
+@@ -13,6 +13,7 @@
+ #include <linux/netdevice.h>
+ #include <linux/phy.h>
+ #include <linux/phy_fixed.h>
++#include <linux/phylink.h>
+ #include <linux/of_net.h>
+ #include <linux/of_mdio.h>
+ #include <linux/mdio.h>
+@@ -99,15 +100,14 @@ static int dsa_slave_open(struct net_device *dev)
+ 	}
+ 
+ 	if (ds->ops->port_enable) {
+-		err = ds->ops->port_enable(ds, p->dp->index, p->phy);
++		err = ds->ops->port_enable(ds, dp->index, dev->phydev);
+ 		if (err)
+ 			goto clear_promisc;
+ 	}
+ 
+ 	dsa_port_set_state_now(p->dp, stp_state);
+ 
+-	if (p->phy)
+-		phy_start(p->phy);
++	phylink_start(dp->pl);
+ 
+ 	return 0;
+ 
+@@ -130,8 +130,7 @@ static int dsa_slave_close(struct net_device *dev)
+ 	struct net_device *master = dsa_master_netdev(p);
+ 	struct dsa_switch *ds = p->dp->ds;
+ 
+-	if (p->phy)
+-		phy_stop(p->phy);
++	phylink_stop(p->dp->pl);
+ 
+ 	dev_mc_unsync(master, dev);
+ 	dev_uc_unsync(master, dev);
+@@ -144,7 +143,7 @@ static int dsa_slave_close(struct net_device *dev)
+ 		dev_uc_del(master, dev->dev_addr);
+ 
+ 	if (ds->ops->port_disable)
+-		ds->ops->port_disable(ds, p->dp->index, p->phy);
++		ds->ops->port_disable(ds, p->dp->index, dev->phydev);
+ 
+ 	dsa_port_set_state_now(p->dp, BR_STATE_DISABLED);
+ 
+@@ -284,10 +283,7 @@ static int dsa_slave_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 
+-	if (p->phy != NULL)
+-		return phy_mii_ioctl(p->phy, ifr, cmd);
+-
+-	return -EOPNOTSUPP;
++	return phylink_mii_ioctl(p->dp->pl, ifr, cmd);
+ }
+ 
+ static int dsa_slave_port_attr_set(struct net_device *dev,
+@@ -444,12 +440,7 @@ dsa_slave_get_link_ksettings(struct net_device *dev,
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 
+-	if (!p->phy)
+-		return -EOPNOTSUPP;
+-
+-	phy_ethtool_ksettings_get(p->phy, cmd);
+-
+-	return 0;
++	return phylink_ethtool_ksettings_get(p->dp->pl, cmd);
+ }
+ 
+ static int
+@@ -458,10 +449,7 @@ dsa_slave_set_link_ksettings(struct net_device *dev,
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 
+-	if (p->phy != NULL)
+-		return phy_ethtool_ksettings_set(p->phy, cmd);
+-
+-	return -EOPNOTSUPP;
++	return phylink_ethtool_ksettings_set(p->dp->pl, cmd);
+ }
+ 
+ static void dsa_slave_get_drvinfo(struct net_device *dev,
+@@ -497,10 +485,7 @@ static int dsa_slave_nway_reset(struct net_device *dev)
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 
+-	if (p->phy != NULL)
+-		return genphy_restart_aneg(p->phy);
+-
+-	return -EOPNOTSUPP;
++	return phylink_ethtool_nway_reset(p->dp->pl);
+ }
+ 
+ static int dsa_slave_get_eeprom_len(struct net_device *dev)
+@@ -685,6 +670,8 @@ static void dsa_slave_get_wol(struct net_device *dev, struct ethtool_wolinfo *w)
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 	struct dsa_switch *ds = p->dp->ds;
+ 
++	phylink_ethtool_get_wol(p->dp->pl, w);
++
+ 	if (ds->ops->get_wol)
+ 		ds->ops->get_wol(ds, p->dp->index, w);
+ }
+@@ -695,6 +682,8 @@ static int dsa_slave_set_wol(struct net_device *dev, struct ethtool_wolinfo *w)
+ 	struct dsa_switch *ds = p->dp->ds;
+ 	int ret = -EOPNOTSUPP;
+ 
++	phylink_ethtool_set_wol(p->dp->pl, w);
++
+ 	if (ds->ops->set_wol)
+ 		ret = ds->ops->set_wol(ds, p->dp->index, w);
+ 
+@@ -708,7 +697,7 @@ static int dsa_slave_set_eee(struct net_device *dev, struct ethtool_eee *e)
+ 	int ret;
+ 
+ 	/* Port's PHY and MAC both need to be EEE capable */
+-	if (!p->phy)
++	if (!dev->phydev)
+ 		return -ENODEV;
+ 
+ 	if (!ds->ops->set_mac_eee)
+@@ -718,13 +707,7 @@ static int dsa_slave_set_eee(struct net_device *dev, struct ethtool_eee *e)
+ 	if (ret)
+ 		return ret;
+ 
+-	if (e->eee_enabled) {
+-		ret = phy_init_eee(p->phy, 0);
+-		if (ret)
+-			return ret;
+-	}
+-
+-	return phy_ethtool_set_eee(p->phy, e);
++	return phylink_ethtool_set_eee(p->dp->pl, e);
+ }
+ 
+ static int dsa_slave_get_eee(struct net_device *dev, struct ethtool_eee *e)
+@@ -734,7 +717,7 @@ static int dsa_slave_get_eee(struct net_device *dev, struct ethtool_eee *e)
+ 	int ret;
+ 
+ 	/* Port's PHY and MAC both need to be EEE capable */
+-	if (!p->phy)
++	if (!dev->phydev)
+ 		return -ENODEV;
+ 
+ 	if (!ds->ops->get_mac_eee)
+@@ -744,7 +727,7 @@ static int dsa_slave_get_eee(struct net_device *dev, struct ethtool_eee *e)
+ 	if (ret)
+ 		return ret;
+ 
+-	return phy_ethtool_get_eee(p->phy, e);
++	return phylink_ethtool_get_eee(p->dp->pl, e);
+ }
+ 
+ #ifdef CONFIG_NET_POLL_CONTROLLER
+@@ -1054,152 +1037,156 @@ static struct device_type dsa_type = {
+ 	.name	= "dsa",
+ };
+ 
+-static void dsa_slave_adjust_link(struct net_device *dev)
++static void dsa_slave_phylink_validate(struct net_device *dev,
++				       unsigned long *supported,
++				       struct phylink_link_state *state)
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 	struct dsa_switch *ds = p->dp->ds;
+-	unsigned int status_changed = 0;
+ 
+-	if (p->old_link != p->phy->link) {
+-		status_changed = 1;
+-		p->old_link = p->phy->link;
+-	}
++	if (!ds->ops->phylink_validate)
++		return;
+ 
+-	if (p->old_duplex != p->phy->duplex) {
+-		status_changed = 1;
+-		p->old_duplex = p->phy->duplex;
+-	}
++	ds->ops->phylink_validate(ds, p->dp->index, supported, state);
++}
+ 
+-	if (p->old_pause != p->phy->pause) {
+-		status_changed = 1;
+-		p->old_pause = p->phy->pause;
+-	}
++static int dsa_slave_phylink_mac_link_state(struct net_device *dev,
++					    struct phylink_link_state *state)
++{
++	struct dsa_slave_priv *p = netdev_priv(dev);
++	struct dsa_switch *ds = p->dp->ds;
+ 
+-	if (ds->ops->adjust_link && status_changed)
+-		ds->ops->adjust_link(ds, p->dp->index, p->phy);
++	/* Only called for SGMII and 802.3z */
++	if (!ds->ops->phylink_mac_link_state)
++		return -EOPNOTSUPP;
+ 
+-	if (status_changed)
+-		phy_print_status(p->phy);
++	return ds->ops->phylink_mac_link_state(ds, p->dp->index, state);
+ }
+ 
+-static int dsa_slave_fixed_link_update(struct net_device *dev,
+-				       struct fixed_phy_status *status)
++static void dsa_slave_phylink_mac_config(struct net_device *dev,
++					 unsigned int mode,
++					 const struct phylink_link_state *state)
+ {
+-	struct dsa_slave_priv *p;
+-	struct dsa_switch *ds;
++	struct dsa_slave_priv *p = netdev_priv(dev);
++	struct dsa_switch *ds = p->dp->ds;
++
++	if (!ds->ops->phylink_mac_config)
++		return;
++
++	ds->ops->phylink_mac_config(ds, p->dp->index, mode, state);
++}
++
++static void dsa_slave_phylink_mac_an_restart(struct net_device *dev)
++{
++	struct dsa_slave_priv *p = netdev_priv(dev);
++	struct dsa_switch *ds = p->dp->ds;
+ 
+-	if (dev) {
+-		p = netdev_priv(dev);
+-		ds = p->dp->ds;
+-		if (ds->ops->fixed_link_update)
+-			ds->ops->fixed_link_update(ds, p->dp->index, status);
++	if (!ds->ops->phylink_mac_an_restart)
++		return;
++
++	ds->ops->phylink_mac_an_restart(ds, p->dp->index);
++}
++
++static void dsa_slave_phylink_mac_link_down(struct net_device *dev,
++					    unsigned int mode,
++					    phy_interface_t interface)
++{
++	struct dsa_slave_priv *p = netdev_priv(dev);
++	struct dsa_switch *ds = p->dp->ds;
++
++	if (!ds->ops->phylink_mac_link_down) {
++		if (ds->ops->adjust_link && dev->phydev)
++			ds->ops->adjust_link(ds, p->dp->index, dev->phydev);
++		return;
+ 	}
+ 
+-	return 0;
++	ds->ops->phylink_mac_link_down(ds, p->dp->index, mode, interface);
+ }
+ 
+-/* slave device setup *******************************************************/
+-static int dsa_slave_phy_connect(struct dsa_slave_priv *p,
+-				 struct net_device *slave_dev,
+-				 int addr)
++static void dsa_slave_phylink_mac_link_up(struct net_device *dev,
++					  unsigned int mode,
++					  phy_interface_t interface,
++					  struct phy_device *phydev)
+ {
++	struct dsa_slave_priv *p = netdev_priv(dev);
+ 	struct dsa_switch *ds = p->dp->ds;
+ 
+-	p->phy = mdiobus_get_phy(ds->slave_mii_bus, addr);
+-	if (!p->phy) {
+-		netdev_err(slave_dev, "no phy at %d\n", addr);
+-		return -ENODEV;
++	if (!ds->ops->phylink_mac_link_up) {
++		if (ds->ops->adjust_link && dev->phydev)
++			ds->ops->adjust_link(ds, p->dp->index, dev->phydev);
++		return;
+ 	}
+ 
+-	/* Use already configured phy mode */
+-	if (p->phy_interface == PHY_INTERFACE_MODE_NA)
+-		p->phy_interface = p->phy->interface;
+-	return phy_connect_direct(slave_dev, p->phy, dsa_slave_adjust_link,
+-				  p->phy_interface);
++	ds->ops->phylink_mac_link_up(ds, p->dp->index, mode, interface, phydev);
+ }
+ 
++static const struct phylink_mac_ops dsa_slave_phylink_mac_ops = {
++	.validate = dsa_slave_phylink_validate,
++	.mac_link_state = dsa_slave_phylink_mac_link_state,
++	.mac_config = dsa_slave_phylink_mac_config,
++	.mac_an_restart = dsa_slave_phylink_mac_an_restart,
++	.mac_link_down = dsa_slave_phylink_mac_link_down,
++	.mac_link_up = dsa_slave_phylink_mac_link_up,
++};
++
+ void dsa_port_phylink_mac_change(struct dsa_switch *ds, int port, bool up)
+ {
++	phylink_mac_change(ds->ports[port].pl, up);
+ }
+ EXPORT_SYMBOL_GPL(dsa_port_phylink_mac_change);
+ 
+-static int dsa_slave_phy_setup(struct dsa_slave_priv *p,
+-				struct net_device *slave_dev)
++/* slave device setup *******************************************************/
++static int dsa_slave_phy_connect(struct net_device *slave_dev, int addr)
+ {
++	struct dsa_slave_priv *p = netdev_priv(slave_dev);
++	struct dsa_switch *ds = p->dp->ds;
++
++	slave_dev->phydev = mdiobus_get_phy(ds->slave_mii_bus, addr);
++	if (!slave_dev->phydev) {
++		netdev_err(slave_dev, "no phy at %d\n", addr);
++		return -ENODEV;
++	}
++
++	return phylink_connect_phy(p->dp->pl, slave_dev->phydev);
++}
++
++static int dsa_slave_phy_setup(struct net_device *slave_dev)
++{
++	struct dsa_slave_priv *p = netdev_priv(slave_dev);
++	struct device_node *port_dn = p->dp->dn;
+ 	struct dsa_switch *ds = p->dp->ds;
+-	struct device_node *phy_dn, *port_dn;
+-	bool phy_is_fixed = false;
+ 	u32 phy_flags = 0;
+ 	int mode, ret;
+ 
+-	port_dn = p->dp->dn;
+ 	mode = of_get_phy_mode(port_dn);
+ 	if (mode < 0)
+ 		mode = PHY_INTERFACE_MODE_NA;
+-	p->phy_interface = mode;
+-
+-	phy_dn = of_parse_phandle(port_dn, "phy-handle", 0);
+-	if (!phy_dn && of_phy_is_fixed_link(port_dn)) {
+-		/* In the case of a fixed PHY, the DT node associated
+-		 * to the fixed PHY is the Port DT node
+-		 */
+-		ret = of_phy_register_fixed_link(port_dn);
+-		if (ret) {
+-			netdev_err(slave_dev, "failed to register fixed PHY: %d\n", ret);
+-			return ret;
+-		}
+-		phy_is_fixed = true;
+-		phy_dn = of_node_get(port_dn);
++	p->dp->pl = phylink_create(slave_dev, port_dn, mode,
++				   &dsa_slave_phylink_mac_ops);
++	if (IS_ERR(p->dp->pl)) {
++		netdev_err(slave_dev,
++			   "error creating PHYLINK: %ld\n", PTR_ERR(p->dp->pl));
++		return PTR_ERR(p->dp->pl);
+ 	}
+ 
+ 	if (ds->ops->get_phy_flags)
+ 		phy_flags = ds->ops->get_phy_flags(ds, p->dp->index);
+ 
+-	if (phy_dn) {
+-		int phy_id = of_mdio_parse_addr(&slave_dev->dev, phy_dn);
+-
+-		/* If this PHY address is part of phys_mii_mask, which means
+-		 * that we need to divert reads and writes to/from it, then we
+-		 * want to bind this device using the slave MII bus created by
+-		 * DSA to make that happen.
++	ret = phylink_of_phy_connect(p->dp->pl, port_dn, phy_flags);
++	if (ret == -ENODEV) {
++		/* We could not connect to a designated PHY or SFP, so use the
++		 * switch internal MDIO bus instead
+ 		 */
+-		if (!phy_is_fixed && phy_id >= 0 &&
+-		    (ds->phys_mii_mask & (1 << phy_id))) {
+-			ret = dsa_slave_phy_connect(p, slave_dev, phy_id);
+-			if (ret) {
+-				netdev_err(slave_dev, "failed to connect to phy%d: %d\n", phy_id, ret);
+-				of_node_put(phy_dn);
+-				return ret;
+-			}
+-		} else {
+-			p->phy = of_phy_connect(slave_dev, phy_dn,
+-						dsa_slave_adjust_link,
+-						phy_flags,
+-						p->phy_interface);
+-		}
+-
+-		of_node_put(phy_dn);
+-	}
+-
+-	if (p->phy && phy_is_fixed)
+-		fixed_phy_set_link_update(p->phy, dsa_slave_fixed_link_update);
+-
+-	/* We could not connect to a designated PHY, so use the switch internal
+-	 * MDIO bus instead
+-	 */
+-	if (!p->phy) {
+-		ret = dsa_slave_phy_connect(p, slave_dev, p->dp->index);
++		ret = dsa_slave_phy_connect(slave_dev, p->dp->index);
+ 		if (ret) {
+-			netdev_err(slave_dev, "failed to connect to port %d: %d\n",
++			netdev_err(slave_dev,
++				   "failed to connect to port %d: %d\n",
+ 				   p->dp->index, ret);
+-			if (phy_is_fixed)
+-				of_phy_deregister_fixed_link(port_dn);
++			phylink_destroy(p->dp->pl);
+ 			return ret;
+ 		}
+ 	}
+ 
+-	phy_attached_info(p->phy);
+-
+ 	return 0;
+ }
+ 
+@@ -1221,13 +1208,9 @@ int dsa_slave_suspend(struct net_device *slave_dev)
+ 
+ 	netif_device_detach(slave_dev);
+ 
+-	if (p->phy) {
+-		phy_stop(p->phy);
+-		p->old_pause = -1;
+-		p->old_link = -1;
+-		p->old_duplex = -1;
+-		phy_suspend(p->phy);
+-	}
++	rtnl_lock();
++	phylink_stop(p->dp->pl);
++	rtnl_unlock();
+ 
+ 	return 0;
+ }
+@@ -1241,10 +1224,9 @@ int dsa_slave_resume(struct net_device *slave_dev)
+ 
+ 	netif_device_attach(slave_dev);
+ 
+-	if (p->phy) {
+-		phy_resume(p->phy);
+-		phy_start(p->phy);
+-	}
++	rtnl_lock();
++	phylink_start(p->dp->pl);
++	rtnl_unlock();
+ 
+ 	return 0;
+ }
+@@ -1299,15 +1281,11 @@ int dsa_slave_create(struct dsa_port *port, const char *name)
+ 	INIT_LIST_HEAD(&p->mall_tc_list);
+ 	p->xmit = dst->tag_ops->xmit;
+ 
+-	p->old_pause = -1;
+-	p->old_link = -1;
+-	p->old_duplex = -1;
+-
+ 	port->netdev = slave_dev;
+ 
+ 	netif_carrier_off(slave_dev);
+ 
+-	ret = dsa_slave_phy_setup(p, slave_dev);
++	ret = dsa_slave_phy_setup(slave_dev);
+ 	if (ret) {
+ 		netdev_err(master, "error %d setting up slave phy\n", ret);
+ 		goto out_free;
+@@ -1323,9 +1301,10 @@ int dsa_slave_create(struct dsa_port *port, const char *name)
+ 	return 0;
+ 
+ out_phy:
+-	phy_disconnect(p->phy);
+-	if (of_phy_is_fixed_link(p->dp->dn))
+-		of_phy_deregister_fixed_link(p->dp->dn);
++	rtnl_lock();
++	phylink_disconnect_phy(p->dp->pl);
++	rtnl_unlock();
++	phylink_destroy(p->dp->pl);
+ out_free:
+ 	free_percpu(p->stats64);
+ 	free_netdev(slave_dev);
+@@ -1336,18 +1315,14 @@ int dsa_slave_create(struct dsa_port *port, const char *name)
+ void dsa_slave_destroy(struct net_device *slave_dev)
+ {
+ 	struct dsa_slave_priv *p = netdev_priv(slave_dev);
+-	struct device_node *port_dn;
+-
+-	port_dn = p->dp->dn;
+ 
+ 	netif_carrier_off(slave_dev);
+-	if (p->phy) {
+-		phy_disconnect(p->phy);
++	rtnl_lock();
++	phylink_disconnect_phy(p->dp->pl);
++	rtnl_unlock();
+ 
+-		if (of_phy_is_fixed_link(port_dn))
+-			of_phy_deregister_fixed_link(port_dn);
+-	}
+ 	unregister_netdev(slave_dev);
++	phylink_destroy(p->dp->pl);
+ 	free_percpu(p->stats64);
+ 	free_netdev(slave_dev);
+ }
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90083-phylink-add-helper-for-configuring-2500BaseX-modes.patch b/target/linux/mvebu/patches-4.14/90083-phylink-add-helper-for-configuring-2500BaseX-modes.patch
new file mode 100644
index 0000000..d7930b7
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90083-phylink-add-helper-for-configuring-2500BaseX-modes.patch
@@ -0,0 +1,74 @@
+From 67902d64ac8b609286b084ae0d32219b95590464 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Fri, 15 Dec 2017 17:24:45 +0000
+Subject: [PATCH 083/126] phylink: add helper for configuring 2500BaseX modes
+
+Add a helper for MAC drivers to use in their validate callback to deal
+with 2500BaseX vs 1000BaseX modes, where the hardware supports both
+but it is not possible to automatically select between them.
+
+This helper defaults to 1000BaseX, as that is the 802.3 standard, and
+will allow users to select 2500BaseX either by forcing the speed if
+AN is disabled, or by changing the advertising mask if AN is enabled.
+Disabling AN is not recommended as it is only the speed that we're
+interested in controlling, not the duplex or pause mode parameters.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+---
+ drivers/net/phy/phylink.c | 30 ++++++++++++++++++++++++++++++
+ include/linux/phylink.h   |  1 +
+ 2 files changed, 31 insertions(+)
+
+diff --git a/drivers/net/phy/phylink.c b/drivers/net/phy/phylink.c
+index 4b63bf9abb32..ab04fc084cb3 100644
+--- a/drivers/net/phy/phylink.c
++++ b/drivers/net/phy/phylink.c
+@@ -1455,4 +1455,34 @@ static const struct sfp_upstream_ops sfp_phylink_ops = {
+ 	.disconnect_phy = phylink_sfp_disconnect_phy,
+ };
+ 
++/* Helpers for MAC drivers */
++
++/**
++ * phylink_helper_basex_speed() - 1000BaseX/2500BaseX helper
++ * @state: a pointer to a &struct phylink_link_state
++ *
++ * Inspect the interface mode, advertising mask or forced speed and
++ * decide whether to run at 2.5Gbit or 1Gbit appropriately, switching
++ * the interface mode to suit.  @state->interface is appropriately
++ * updated, and the advertising mask has the "other" baseX_Full flag
++ * cleared.
++ */
++void phylink_helper_basex_speed(struct phylink_link_state *state)
++{
++	if (phy_interface_mode_is_8023z(state->interface)) {
++		bool want_2500 = state->an_enabled ?
++			phylink_test(state->advertising, 2500baseX_Full) :
++			state->speed == SPEED_2500;
++
++		if (want_2500) {
++			phylink_clear(state->advertising, 1000baseX_Full);
++			state->interface = PHY_INTERFACE_MODE_2500BASEX;
++		} else {
++			phylink_clear(state->advertising, 2500baseX_Full);
++			state->interface = PHY_INTERFACE_MODE_1000BASEX;
++		}
++	}
++}
++EXPORT_SYMBOL_GPL(phylink_helper_basex_speed);
++
+ MODULE_LICENSE("GPL");
+diff --git a/include/linux/phylink.h b/include/linux/phylink.h
+index afb74404e8bf..cff779414883 100644
+--- a/include/linux/phylink.h
++++ b/include/linux/phylink.h
+@@ -143,5 +143,6 @@ int phylink_mii_ioctl(struct phylink *, struct ifreq *, int);
+ #define phylink_test(bm, mode)	__phylink_do_bit(test_bit, bm, mode)
+ 
+ void phylink_set_port_modes(unsigned long *bits);
++void phylink_helper_basex_speed(struct phylink_link_state *state);
+ 
+ #endif
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90084-net-dsa-mv88e6xxx-add-PHYLINK-support.patch b/target/linux/mvebu/patches-4.14/90084-net-dsa-mv88e6xxx-add-PHYLINK-support.patch
new file mode 100644
index 0000000..aa83d83
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90084-net-dsa-mv88e6xxx-add-PHYLINK-support.patch
@@ -0,0 +1,213 @@
+From 4527d32443e37c28e2055983f61d79311d4f49fd Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Thu, 10 May 2018 13:17:35 -0700
+Subject: [PATCH 084/126] net: dsa: mv88e6xxx: add PHYLINK support
+
+Add rudimentary phylink support to mv88e6xxx. This allows the driver
+using user ports with fixed links to keep operating normally. User ports
+with normal PHYs are not affected since the switch automatically manages
+their link parameters. User facing ports which use a SFP/SFF with a
+non-fixed link mode might require a call to phylink_mac_change() to
+operate properly.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+[Andrew: fixed link setting after adding link polling]
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+[florian: expand commit message]
+Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 83 ++++++++++++++++++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/port.c | 39 +++++++++++++++
+ drivers/net/dsa/mv88e6xxx/port.h |  3 ++
+ 3 files changed, 125 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 14ae3a68d3c6..53374a6f79cb 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -31,6 +31,7 @@
+ #include <linux/netdevice.h>
+ #include <linux/gpio/consumer.h>
+ #include <linux/phy.h>
++#include <linux/phylink.h>
+ #include <net/dsa.h>
+ 
+ #include "chip.h"
+@@ -532,6 +533,83 @@ static void mv88e6xxx_adjust_link(struct dsa_switch *ds, int port,
+ 		dev_err(ds->dev, "p%d: failed to configure MAC\n", port);
+ }
+ 
++static void mv88e6xxx_validate(struct dsa_switch *ds, int port,
++			       unsigned long *supported,
++			       struct phylink_link_state *state)
++{
++}
++
++static int mv88e6xxx_link_state(struct dsa_switch *ds, int port,
++				struct phylink_link_state *state)
++{
++	struct mv88e6xxx_chip *chip = ds->priv;
++	int err;
++
++	mutex_lock(&chip->reg_lock);
++	err = mv88e6xxx_port_link_state(chip, port, state);
++	mutex_unlock(&chip->reg_lock);
++
++	return err;
++}
++
++static void mv88e6xxx_mac_config(struct dsa_switch *ds, int port,
++				 unsigned int mode,
++				 const struct phylink_link_state *state)
++{
++	struct mv88e6xxx_chip *chip = ds->priv;
++	int speed, duplex, link, err;
++
++	if (mode == MLO_AN_PHY)
++		return;
++
++	if (mode == MLO_AN_FIXED) {
++		link = LINK_FORCED_UP;
++		speed = state->speed;
++		duplex = state->duplex;
++	} else {
++		speed = SPEED_UNFORCED;
++		duplex = DUPLEX_UNFORCED;
++		link = LINK_UNFORCED;
++	}
++
++	mutex_lock(&chip->reg_lock);
++	err = mv88e6xxx_port_setup_mac(chip, port, link, speed, duplex,
++				       state->interface);
++	mutex_unlock(&chip->reg_lock);
++
++	if (err && err != -EOPNOTSUPP)
++		dev_err(ds->dev, "p%d: failed to configure MAC\n", port);
++}
++
++static void mv88e6xxx_mac_link_force(struct dsa_switch *ds, int port, int link)
++{
++	struct mv88e6xxx_chip *chip = ds->priv;
++	int err;
++
++	mutex_lock(&chip->reg_lock);
++	err = chip->info->ops->port_set_link(chip, port, link);
++	mutex_unlock(&chip->reg_lock);
++
++	if (err)
++		dev_err(chip->dev, "p%d: failed to force MAC link\n", port);
++}
++
++static void mv88e6xxx_mac_link_down(struct dsa_switch *ds, int port,
++				    unsigned int mode,
++				    phy_interface_t interface)
++{
++	if (mode == MLO_AN_FIXED)
++		mv88e6xxx_mac_link_force(ds, port, LINK_FORCED_DOWN);
++}
++
++static void mv88e6xxx_mac_link_up(struct dsa_switch *ds, int port,
++				  unsigned int mode, phy_interface_t interface,
++				  struct phy_device *phydev)
++{
++	if (mode == MLO_AN_FIXED)
++		mv88e6xxx_mac_link_force(ds, port, LINK_FORCED_UP);
++}
++
+ static int mv88e6xxx_stats_snapshot(struct mv88e6xxx_chip *chip, int port)
+ {
+ 	if (!chip->info->ops->stats_snapshot)
+@@ -3918,6 +3996,11 @@ static const struct dsa_switch_ops mv88e6xxx_switch_ops = {
+ 	.setup			= mv88e6xxx_setup,
+ 	.set_addr		= mv88e6xxx_set_addr,
+ 	.adjust_link		= mv88e6xxx_adjust_link,
++	.phylink_validate	= mv88e6xxx_validate,
++	.phylink_mac_link_state	= mv88e6xxx_link_state,
++	.phylink_mac_config	= mv88e6xxx_mac_config,
++	.phylink_mac_link_down	= mv88e6xxx_mac_link_down,
++	.phylink_mac_link_up	= mv88e6xxx_mac_link_up,
+ 	.get_strings		= mv88e6xxx_get_strings,
+ 	.get_ethtool_stats	= mv88e6xxx_get_ethtool_stats,
+ 	.get_sset_count		= mv88e6xxx_get_sset_count,
+diff --git a/drivers/net/dsa/mv88e6xxx/port.c b/drivers/net/dsa/mv88e6xxx/port.c
+index 2cffecfe86e3..c5248b30186b 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.c
++++ b/drivers/net/dsa/mv88e6xxx/port.c
+@@ -15,6 +15,7 @@
+ #include <linux/bitfield.h>
+ #include <linux/if_bridge.h>
+ #include <linux/phy.h>
++#include <linux/phylink.h>
+ 
+ #include "chip.h"
+ #include "port.h"
+@@ -377,6 +378,44 @@ int mv88e6xxx_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode)
+ 	return 0;
+ }
+ 
++int mv88e6xxx_port_link_state(struct mv88e6xxx_chip *chip, int port,
++			      struct phylink_link_state *state)
++{
++	int err;
++	u16 reg;
++
++	err = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_STS, &reg);
++	if (err)
++		return err;
++
++	switch (reg & MV88E6XXX_PORT_STS_SPEED_MASK) {
++	case MV88E6XXX_PORT_STS_SPEED_10:
++		state->speed = SPEED_10;
++		break;
++	case MV88E6XXX_PORT_STS_SPEED_100:
++		state->speed = SPEED_100;
++		break;
++	case MV88E6XXX_PORT_STS_SPEED_1000:
++		state->speed = SPEED_1000;
++		break;
++	case MV88E6XXX_PORT_STS_SPEED_10000:
++		if ((reg &MV88E6XXX_PORT_STS_CMODE_MASK) ==
++		    MV88E6XXX_PORT_STS_CMODE_2500BASEX)
++			state->speed = SPEED_2500;
++		else
++			state->speed = SPEED_10000;
++		break;
++	}
++
++	state->duplex = reg & MV88E6XXX_PORT_STS_DUPLEX ?
++			DUPLEX_FULL : DUPLEX_HALF;
++	state->link = !!(reg & MV88E6XXX_PORT_STS_LINK);
++	state->an_enabled = 1;
++	state->an_complete = state->link;
++
++	return 0;
++}
++
+ /* Offset 0x02: Jamming Control
+  *
+  * Do not limit the period of time that this port can be paused for by
+diff --git a/drivers/net/dsa/mv88e6xxx/port.h b/drivers/net/dsa/mv88e6xxx/port.h
+index ccdc67fe9079..7dbfa44814a7 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.h
++++ b/drivers/net/dsa/mv88e6xxx/port.h
+@@ -29,6 +29,7 @@
+ #define MV88E6XXX_PORT_STS_SPEED_10		0x0000
+ #define MV88E6XXX_PORT_STS_SPEED_100		0x0100
+ #define MV88E6XXX_PORT_STS_SPEED_1000		0x0200
++#define MV88E6XXX_PORT_STS_SPEED_10000		0x0300
+ #define MV88E6352_PORT_STS_EEE			0x0040
+ #define MV88E6165_PORT_STS_AM_DIS		0x0040
+ #define MV88E6185_PORT_STS_MGMII		0x0040
+@@ -305,6 +306,8 @@ int mv88e6390_port_pause_limit(struct mv88e6xxx_chip *chip, int port, u8 in,
+ int mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
+ 			      phy_interface_t mode);
+ int mv88e6xxx_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode);
++int mv88e6xxx_port_link_state(struct mv88e6xxx_chip *chip, int port,
++			      struct phylink_link_state *state);
+ int mv88e6xxx_port_set_map_da(struct mv88e6xxx_chip *chip, int port);
+ int mv88e6095_port_set_upstream_port(struct mv88e6xxx_chip *chip, int port,
+ 				     int upstream_port);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90085-net-dsa-mv88e6xxx-Add-support-to-enabling-pause.patch b/target/linux/mvebu/patches-4.14/90085-net-dsa-mv88e6xxx-Add-support-to-enabling-pause.patch
new file mode 100644
index 0000000..c549c87
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90085-net-dsa-mv88e6xxx-Add-support-to-enabling-pause.patch
@@ -0,0 +1,171 @@
+From b6bd83fc50c6c7587d76c748a1e5728663a1307f Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:37 +0200
+Subject: [PATCH 085/126] net: dsa: mv88e6xxx: Add support to enabling pause
+
+The 6185 can enable/disable 802.3z pause be setting the MyPause bit in
+the port status register. Add an op to support this.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 20 ++++++++++++++++----
+ drivers/net/dsa/mv88e6xxx/chip.h |  7 +++++++
+ drivers/net/dsa/mv88e6xxx/port.c | 23 +++++++++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/port.h |  2 ++
+ 4 files changed, 48 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 53374a6f79cb..323942f5257d 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -466,7 +466,7 @@ int mv88e6xxx_update(struct mv88e6xxx_chip *chip, int addr, int reg, u16 update)
+ }
+ 
+ static int mv88e6xxx_port_setup_mac(struct mv88e6xxx_chip *chip, int port,
+-				    int link, int speed, int duplex,
++				    int link, int speed, int duplex, int pause,
+ 				    phy_interface_t mode)
+ {
+ 	int err;
+@@ -485,6 +485,12 @@ static int mv88e6xxx_port_setup_mac(struct mv88e6xxx_chip *chip, int port,
+ 			goto restore_link;
+ 	}
+ 
++	if (chip->info->ops->port_set_pause) {
++		err = chip->info->ops->port_set_pause(chip, port, pause);
++		if (err)
++			goto restore_link;
++	}
++
+ 	if (chip->info->ops->port_set_duplex) {
+ 		err = chip->info->ops->port_set_duplex(chip, port, duplex);
+ 		if (err && err != -EOPNOTSUPP)
+@@ -526,7 +532,8 @@ static void mv88e6xxx_adjust_link(struct dsa_switch *ds, int port,
+ 
+ 	mutex_lock(&chip->reg_lock);
+ 	err = mv88e6xxx_port_setup_mac(chip, port, phydev->link, phydev->speed,
+-				       phydev->duplex, phydev->interface);
++				       phydev->duplex, phydev->pause,
++				       phydev->interface);
+ 	mutex_unlock(&chip->reg_lock);
+ 
+ 	if (err && err != -EOPNOTSUPP)
+@@ -557,7 +564,7 @@ static void mv88e6xxx_mac_config(struct dsa_switch *ds, int port,
+ 				 const struct phylink_link_state *state)
+ {
+ 	struct mv88e6xxx_chip *chip = ds->priv;
+-	int speed, duplex, link, err;
++	int speed, duplex, link, pause, err;
+ 
+ 	if (mode == MLO_AN_PHY)
+ 		return;
+@@ -571,9 +578,10 @@ static void mv88e6xxx_mac_config(struct dsa_switch *ds, int port,
+ 		duplex = DUPLEX_UNFORCED;
+ 		link = LINK_UNFORCED;
+ 	}
++	pause = !!phylink_test(state->advertising, Pause);
+ 
+ 	mutex_lock(&chip->reg_lock);
+-	err = mv88e6xxx_port_setup_mac(chip, port, link, speed, duplex,
++	err = mv88e6xxx_port_setup_mac(chip, port, link, speed, duplex, pause,
+ 				       state->interface);
+ 	mutex_unlock(&chip->reg_lock);
+ 
+@@ -1811,10 +1819,12 @@ static int mv88e6xxx_setup_port(struct mv88e6xxx_chip *chip, int port)
+ 	if (dsa_is_cpu_port(ds, port) || dsa_is_dsa_port(ds, port))
+ 		err = mv88e6xxx_port_setup_mac(chip, port, LINK_FORCED_UP,
+ 					       SPEED_MAX, DUPLEX_FULL,
++					       PAUSE_OFF,
+ 					       PHY_INTERFACE_MODE_NA);
+ 	else
+ 		err = mv88e6xxx_port_setup_mac(chip, port, LINK_UNFORCED,
+ 					       SPEED_UNFORCED, DUPLEX_UNFORCED,
++					       PAUSE_ON,
+ 					       PHY_INTERFACE_MODE_NA);
+ 	if (err)
+ 		return err;
+@@ -2579,6 +2589,7 @@ static const struct mv88e6xxx_ops mv88e6131_ops = {
+ 	.port_set_jumbo_size = mv88e6165_port_set_jumbo_size,
+ 	.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
++	.port_set_pause = mv88e6185_port_set_pause,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2836,6 +2847,7 @@ static const struct mv88e6xxx_ops mv88e6185_ops = {
+ 	.port_set_egress_floods = mv88e6185_port_set_egress_floods,
+ 	.port_egress_rate_limiting = mv88e6095_port_egress_rate_limiting,
+ 	.port_set_upstream_port = mv88e6095_port_set_upstream_port,
++	.port_set_pause = mv88e6185_port_set_pause,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.h b/drivers/net/dsa/mv88e6xxx/chip.h
+index 0913eeca53b3..439cae17095b 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.h
++++ b/drivers/net/dsa/mv88e6xxx/chip.h
+@@ -279,6 +279,13 @@ struct mv88e6xxx_ops {
+ 	 */
+ 	int (*port_set_duplex)(struct mv88e6xxx_chip *chip, int port, int dup);
+ 
++#define PAUSE_ON		1
++#define PAUSE_OFF		0
++
++	/* Enable/disable sending Pause */
++	int (*port_set_pause)(struct mv88e6xxx_chip *chip, int port,
++			      int pause);
++
+ #define SPEED_MAX		INT_MAX
+ #define SPEED_UNFORCED		-2
+ 
+diff --git a/drivers/net/dsa/mv88e6xxx/port.c b/drivers/net/dsa/mv88e6xxx/port.c
+index c5248b30186b..c72eec63e8f6 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.c
++++ b/drivers/net/dsa/mv88e6xxx/port.c
+@@ -36,6 +36,29 @@ int mv88e6xxx_port_write(struct mv88e6xxx_chip *chip, int port, int reg,
+ 	return mv88e6xxx_write(chip, addr, reg, val);
+ }
+ 
++/* Offset 0x00: MAC (or PCS or Physical) Status Register
++ *
++ * For most devices, this is read only. However the 6185 has the MyPause
++ * bit read/write.
++ */
++int mv88e6185_port_set_pause(struct mv88e6xxx_chip *chip, int port,
++			     int pause)
++{
++	u16 reg;
++	int err;
++
++	err = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_STS, &reg);
++	if (err)
++		return err;
++
++	if (pause)
++		reg |= MV88E6XXX_PORT_STS_MY_PAUSE;
++	else
++		reg &= ~MV88E6XXX_PORT_STS_MY_PAUSE;
++
++	return mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_STS, reg);
++}
++
+ /* Offset 0x01: MAC (or PCS or Physical) Control Register
+  *
+  * Link, Duplex and Flow Control have one force bit, one value bit.
+diff --git a/drivers/net/dsa/mv88e6xxx/port.h b/drivers/net/dsa/mv88e6xxx/port.h
+index 7dbfa44814a7..c2fce7c1cb37 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.h
++++ b/drivers/net/dsa/mv88e6xxx/port.h
+@@ -252,6 +252,8 @@ int mv88e6xxx_port_read(struct mv88e6xxx_chip *chip, int port, int reg,
+ int mv88e6xxx_port_write(struct mv88e6xxx_chip *chip, int port, int reg,
+ 			 u16 val);
+ 
++int mv88e6185_port_set_pause(struct mv88e6xxx_chip *chip, int port,
++			     int pause);
+ int mv88e6352_port_set_rgmii_delay(struct mv88e6xxx_chip *chip, int port,
+ 				   phy_interface_t mode);
+ int mv88e6390_port_set_rgmii_delay(struct mv88e6xxx_chip *chip, int port,
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90086-net-dsa-mv88e6xxx-add-phylink-support.patch b/target/linux/mvebu/patches-4.14/90086-net-dsa-mv88e6xxx-add-phylink-support.patch
new file mode 100644
index 0000000..45c3baf
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90086-net-dsa-mv88e6xxx-add-phylink-support.patch
@@ -0,0 +1,705 @@
+From 9861270c061bd1893bcdb0aa92c85a9871f2c758 Mon Sep 17 00:00:00 2001
+From: Russell King <rmk+kernel@armlinux.org.uk>
+Date: Thu, 9 Aug 2018 15:38:39 +0200
+Subject: [PATCH 086/126] net: dsa: mv88e6xxx: add phylink support
+
+Add rudimentary phylink support to mv88e6xxx.
+
+TODO:
+- needs to call phylink_mac_change() when the port link comes up/goes down.
+
+Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 139 ++++++++++++++++++++++++++++++-
+ drivers/net/dsa/mv88e6xxx/chip.h |   8 ++
+ drivers/net/dsa/mv88e6xxx/port.c |  56 ++++++++++++-
+ drivers/net/dsa/mv88e6xxx/port.h |  18 +++-
+ 4 files changed, 217 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 323942f5257d..f83c1cb44a80 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -540,10 +540,92 @@ static void mv88e6xxx_adjust_link(struct dsa_switch *ds, int port,
+ 		dev_err(ds->dev, "p%d: failed to configure MAC\n", port);
+ }
+ 
++static void mv88e6065_phylink_validate(struct mv88e6xxx_chip *chip, int port,
++				       unsigned long *mask,
++				       struct phylink_link_state *state)
++{
++	if (!phy_interface_mode_is_8023z(state->interface)) {
++		/* 10M and 100M are only supported in non-802.3z mode */
++		phylink_set(mask, 10baseT_Half);
++		phylink_set(mask, 10baseT_Full);
++		phylink_set(mask, 100baseT_Half);
++		phylink_set(mask, 100baseT_Full);
++	}
++}
++
++static void mv88e6185_phylink_validate(struct mv88e6xxx_chip *chip, int port,
++				       unsigned long *mask,
++				       struct phylink_link_state *state)
++{
++	/* FIXME: if the port is in 1000Base-X mode, then it only supports
++	 * 1000M FD speeds.  In this case, CMODE will indicate 5.
++	 */
++	phylink_set(mask, 1000baseT_Full);
++	phylink_set(mask, 1000baseX_Full);
++
++	mv88e6065_phylink_validate(chip, port, mask, state);
++}
++
++static void mv88e6352_phylink_validate(struct mv88e6xxx_chip *chip, int port,
++				       unsigned long *mask,
++				       struct phylink_link_state *state)
++{
++	/* No ethtool bits for 200Mbps */
++	phylink_set(mask, 1000baseT_Full);
++	phylink_set(mask, 1000baseX_Full);
++
++	mv88e6065_phylink_validate(chip, port, mask, state);
++}
++
++static void mv88e6390_phylink_validate(struct mv88e6xxx_chip *chip, int port,
++				       unsigned long *mask,
++				       struct phylink_link_state *state)
++{
++	if (port >= 9)
++		phylink_set(mask, 2500baseX_Full);
++
++	/* No ethtool bits for 200Mbps */
++	phylink_set(mask, 1000baseT_Full);
++	phylink_set(mask, 1000baseX_Full);
++
++	mv88e6065_phylink_validate(chip, port, mask, state);
++}
++
++static void mv88e6390x_phylink_validate(struct mv88e6xxx_chip *chip, int port,
++					unsigned long *mask,
++					struct phylink_link_state *state)
++{
++	if (port >= 9) {
++		phylink_set(mask, 10000baseT_Full);
++		phylink_set(mask, 10000baseKR_Full);
++	}
++
++	mv88e6390_phylink_validate(chip, port, mask, state);
++}
++
+ static void mv88e6xxx_validate(struct dsa_switch *ds, int port,
+ 			       unsigned long *supported,
+ 			       struct phylink_link_state *state)
+ {
++	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
++	struct mv88e6xxx_chip *chip = ds->priv;
++
++	/* Allow all the expected bits */
++	phylink_set(mask, Autoneg);
++	phylink_set(mask, Pause);
++	phylink_set_port_modes(mask);
++
++	if (chip->info->ops->phylink_validate)
++		chip->info->ops->phylink_validate(chip, port, mask, state);
++
++	bitmap_and(supported, supported, mask, __ETHTOOL_LINK_MODE_MASK_NBITS);
++	bitmap_and(state->advertising, state->advertising, mask,
++		   __ETHTOOL_LINK_MODE_MASK_NBITS);
++
++	/* We can only operate at 2500BaseX or 1000BaseX.  If requested
++	 * to advertise both, only report advertising at 2500BaseX.
++	 */
++	phylink_helper_basex_speed(state);
+ }
+ 
+ static int mv88e6xxx_link_state(struct dsa_switch *ds, int port,
+@@ -553,7 +635,10 @@ static int mv88e6xxx_link_state(struct dsa_switch *ds, int port,
+ 	int err;
+ 
+ 	mutex_lock(&chip->reg_lock);
+-	err = mv88e6xxx_port_link_state(chip, port, state);
++	if (chip->info->ops->port_link_state)
++		err = chip->info->ops->port_link_state(chip, port, state);
++	else
++		err = -EOPNOTSUPP;
+ 	mutex_unlock(&chip->reg_lock);
+ 
+ 	return err;
+@@ -2475,6 +2560,7 @@ static const struct mv88e6xxx_ops mv88e6085_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2489,6 +2575,7 @@ static const struct mv88e6xxx_ops mv88e6085_ops = {
+ 	.reset = mv88e6185_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6095_ops = {
+@@ -2502,6 +2589,7 @@ static const struct mv88e6xxx_ops mv88e6095_ops = {
+ 	.port_set_frame_mode = mv88e6085_port_set_frame_mode,
+ 	.port_set_egress_floods = mv88e6185_port_set_egress_floods,
+ 	.port_set_upstream_port = mv88e6095_port_set_upstream_port,
++	.port_link_state = mv88e6185_port_link_state,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2512,6 +2600,7 @@ static const struct mv88e6xxx_ops mv88e6095_ops = {
+ 	.reset = mv88e6185_g1_reset,
+ 	.vtu_getnext = mv88e6185_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6185_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6097_ops = {
+@@ -2532,6 +2621,7 @@ static const struct mv88e6xxx_ops mv88e6097_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2544,6 +2634,7 @@ static const struct mv88e6xxx_ops mv88e6097_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6123_ops = {
+@@ -2559,6 +2650,7 @@ static const struct mv88e6xxx_ops mv88e6123_ops = {
+ 	.port_set_egress_floods = mv88e6352_port_set_egress_floods,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2571,6 +2663,7 @@ static const struct mv88e6xxx_ops mv88e6123_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6131_ops = {
+@@ -2590,6 +2683,7 @@ static const struct mv88e6xxx_ops mv88e6131_ops = {
+ 	.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_set_pause = mv88e6185_port_set_pause,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2603,6 +2697,7 @@ static const struct mv88e6xxx_ops mv88e6131_ops = {
+ 	.reset = mv88e6185_g1_reset,
+ 	.vtu_getnext = mv88e6185_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6185_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6141_ops = {
+@@ -2626,6 +2721,7 @@ static const struct mv88e6xxx_ops mv88e6141_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6320_stats_get_strings,
+@@ -2638,6 +2734,7 @@ static const struct mv88e6xxx_ops mv88e6141_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6161_ops = {
+@@ -2658,6 +2755,7 @@ static const struct mv88e6xxx_ops mv88e6161_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2670,6 +2768,7 @@ static const struct mv88e6xxx_ops mv88e6161_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6165_ops = {
+@@ -2683,6 +2782,7 @@ static const struct mv88e6xxx_ops mv88e6165_ops = {
+ 	.port_set_speed = mv88e6185_port_set_speed,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2695,6 +2795,7 @@ static const struct mv88e6xxx_ops mv88e6165_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6171_ops = {
+@@ -2716,6 +2817,7 @@ static const struct mv88e6xxx_ops mv88e6171_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2728,6 +2830,7 @@ static const struct mv88e6xxx_ops mv88e6171_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6172_ops = {
+@@ -2751,6 +2854,7 @@ static const struct mv88e6xxx_ops mv88e6172_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2764,6 +2868,7 @@ static const struct mv88e6xxx_ops mv88e6172_ops = {
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6352_serdes_power,
++	.phylink_validate = mv88e6352_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6175_ops = {
+@@ -2785,6 +2890,7 @@ static const struct mv88e6xxx_ops mv88e6175_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2797,6 +2903,7 @@ static const struct mv88e6xxx_ops mv88e6175_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6176_ops = {
+@@ -2820,6 +2927,7 @@ static const struct mv88e6xxx_ops mv88e6176_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2833,6 +2941,7 @@ static const struct mv88e6xxx_ops mv88e6176_ops = {
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6352_serdes_power,
++	.phylink_validate = mv88e6352_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6185_ops = {
+@@ -2848,6 +2957,7 @@ static const struct mv88e6xxx_ops mv88e6185_ops = {
+ 	.port_egress_rate_limiting = mv88e6095_port_egress_rate_limiting,
+ 	.port_set_upstream_port = mv88e6095_port_set_upstream_port,
+ 	.port_set_pause = mv88e6185_port_set_pause,
++	.port_link_state = mv88e6185_port_link_state,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2861,6 +2971,7 @@ static const struct mv88e6xxx_ops mv88e6185_ops = {
+ 	.reset = mv88e6185_g1_reset,
+ 	.vtu_getnext = mv88e6185_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6185_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6190_ops = {
+@@ -2883,6 +2994,7 @@ static const struct mv88e6xxx_ops mv88e6190_ops = {
+ 	.port_pause_limit = mv88e6390_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -2897,6 +3009,7 @@ static const struct mv88e6xxx_ops mv88e6190_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390_serdes_power,
++	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6190x_ops = {
+@@ -2919,6 +3032,7 @@ static const struct mv88e6xxx_ops mv88e6190x_ops = {
+ 	.port_pause_limit = mv88e6390_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -2933,6 +3047,7 @@ static const struct mv88e6xxx_ops mv88e6190x_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390_serdes_power,
++	.phylink_validate = mv88e6390x_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6191_ops = {
+@@ -2955,6 +3070,7 @@ static const struct mv88e6xxx_ops mv88e6191_ops = {
+ 	.port_pause_limit = mv88e6390_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -2969,6 +3085,7 @@ static const struct mv88e6xxx_ops mv88e6191_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390_serdes_power,
++	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6240_ops = {
+@@ -2992,6 +3109,7 @@ static const struct mv88e6xxx_ops mv88e6240_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -3005,6 +3123,7 @@ static const struct mv88e6xxx_ops mv88e6240_ops = {
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6352_serdes_power,
++	.phylink_validate = mv88e6352_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6290_ops = {
+@@ -3028,6 +3147,7 @@ static const struct mv88e6xxx_ops mv88e6290_ops = {
+ 	.port_set_cmode = mv88e6390x_port_set_cmode,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -3042,6 +3162,7 @@ static const struct mv88e6xxx_ops mv88e6290_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390_serdes_power,
++	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6320_ops = {
+@@ -3064,6 +3185,7 @@ static const struct mv88e6xxx_ops mv88e6320_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6320_stats_get_strings,
+@@ -3075,6 +3197,7 @@ static const struct mv88e6xxx_ops mv88e6320_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6185_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6185_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6321_ops = {
+@@ -3097,6 +3220,7 @@ static const struct mv88e6xxx_ops mv88e6321_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6320_stats_get_strings,
+@@ -3106,6 +3230,7 @@ static const struct mv88e6xxx_ops mv88e6321_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6185_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6185_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6341_ops = {
+@@ -3129,6 +3254,7 @@ static const struct mv88e6xxx_ops mv88e6341_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6320_stats_get_strings,
+@@ -3141,6 +3267,7 @@ static const struct mv88e6xxx_ops mv88e6341_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6350_ops = {
+@@ -3162,6 +3289,7 @@ static const struct mv88e6xxx_ops mv88e6350_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -3174,6 +3302,7 @@ static const struct mv88e6xxx_ops mv88e6350_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6351_ops = {
+@@ -3195,6 +3324,7 @@ static const struct mv88e6xxx_ops mv88e6351_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -3207,6 +3337,7 @@ static const struct mv88e6xxx_ops mv88e6351_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.phylink_validate = mv88e6185_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6352_ops = {
+@@ -3230,6 +3361,7 @@ static const struct mv88e6xxx_ops mv88e6352_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -3243,6 +3375,7 @@ static const struct mv88e6xxx_ops mv88e6352_ops = {
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6352_serdes_power,
++	.phylink_validate = mv88e6352_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6390_ops = {
+@@ -3268,6 +3401,7 @@ static const struct mv88e6xxx_ops mv88e6390_ops = {
+ 	.port_set_cmode = mv88e6390x_port_set_cmode,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -3282,6 +3416,7 @@ static const struct mv88e6xxx_ops mv88e6390_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390_serdes_power,
++	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_ops mv88e6390x_ops = {
+@@ -3307,6 +3442,7 @@ static const struct mv88e6xxx_ops mv88e6390x_ops = {
+ 	.port_set_cmode = mv88e6390x_port_set_cmode,
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
++	.port_link_state = mv88e6352_port_link_state,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -3321,6 +3457,7 @@ static const struct mv88e6xxx_ops mv88e6390x_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390_serdes_power,
++	.phylink_validate = mv88e6390x_phylink_validate,
+ };
+ 
+ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.h b/drivers/net/dsa/mv88e6xxx/chip.h
+index 439cae17095b..f6053799aa5a 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.h
++++ b/drivers/net/dsa/mv88e6xxx/chip.h
+@@ -324,6 +324,9 @@ struct mv88e6xxx_ops {
+ 	 */
+ 	int (*port_set_upstream_port)(struct mv88e6xxx_chip *chip, int port,
+ 				      int upstream_port);
++	/* Return the port link state, as required by phylink */
++	int (*port_link_state)(struct mv88e6xxx_chip *chip, int port,
++			       struct phylink_link_state *state);
+ 
+ 	/* Snapshot the statistics for a port. The statistics can then
+ 	 * be read back a leisure but still with a consistent view.
+@@ -354,6 +357,11 @@ struct mv88e6xxx_ops {
+ 			   struct mv88e6xxx_vtu_entry *entry);
+ 	int (*vtu_loadpurge)(struct mv88e6xxx_chip *chip,
+ 			     struct mv88e6xxx_vtu_entry *entry);
++
++	/* Phylink */
++	void (*phylink_validate)(struct mv88e6xxx_chip *chip, int port,
++				 unsigned long *mask,
++				 struct phylink_link_state *state);
+ };
+ 
+ struct mv88e6xxx_irq_ops {
+diff --git a/drivers/net/dsa/mv88e6xxx/port.c b/drivers/net/dsa/mv88e6xxx/port.c
+index c72eec63e8f6..62f39603920f 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.c
++++ b/drivers/net/dsa/mv88e6xxx/port.c
+@@ -387,6 +387,19 @@ int mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
+ 	return 0;
+ }
+ 
++/* mv88e6185 only has 3 bits for CMODE */
++static int mv88e6185_port_get_cmode(struct mv88e6xxx_chip *chip, int port)
++{
++	int err;
++	u16 reg;
++
++	err = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_STS, &reg);
++	if (err)
++		return err;
++
++	return reg & MV88E6185_PORT_STS_CMODE_MASK;
++}
++
+ int mv88e6xxx_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode)
+ {
+ 	int err;
+@@ -401,7 +414,7 @@ int mv88e6xxx_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode)
+ 	return 0;
+ }
+ 
+-int mv88e6xxx_port_link_state(struct mv88e6xxx_chip *chip, int port,
++int mv88e6352_port_link_state(struct mv88e6xxx_chip *chip, int port,
+ 			      struct phylink_link_state *state)
+ {
+ 	int err;
+@@ -422,7 +435,7 @@ int mv88e6xxx_port_link_state(struct mv88e6xxx_chip *chip, int port,
+ 		state->speed = SPEED_1000;
+ 		break;
+ 	case MV88E6XXX_PORT_STS_SPEED_10000:
+-		if ((reg &MV88E6XXX_PORT_STS_CMODE_MASK) ==
++		if ((reg & MV88E6XXX_PORT_STS_CMODE_MASK) ==
+ 		    MV88E6XXX_PORT_STS_CMODE_2500BASEX)
+ 			state->speed = SPEED_2500;
+ 		else
+@@ -439,6 +452,45 @@ int mv88e6xxx_port_link_state(struct mv88e6xxx_chip *chip, int port,
+ 	return 0;
+ }
+ 
++int mv88e6185_port_link_state(struct mv88e6xxx_chip *chip, int port,
++			      struct phylink_link_state *state)
++{
++	if (state->interface == PHY_INTERFACE_MODE_1000BASEX) {
++		int cmode = mv88e6185_port_get_cmode(chip, port);
++
++		if (cmode < 0)
++			return cmode;
++
++		/* When a port is in "Cross-chip serdes" mode, it uses
++		 * 1000Base-X full duplex mode, but there is no automatic
++		 * link detection. Use the sync OK status for link (as it
++		 * would do for 1000Base-X mode.)
++		 */
++		if (cmode == MV88E6185_PORT_STS_CMODE_SERDES) {
++			u16 mac;
++			int err;
++
++			err = mv88e6xxx_port_read(chip, port,
++						  MV88E6XXX_PORT_MAC_CTL, &mac);
++			if (err)
++				return err;
++
++			state->link = !!(mac & MV88E6185_PORT_MAC_CTL_SYNC_OK);
++			state->an_enabled = 1;
++			state->an_complete =
++				!!(mac & MV88E6185_PORT_MAC_CTL_AN_DONE);
++			state->duplex =
++				state->link ? DUPLEX_FULL : DUPLEX_UNKNOWN;
++			state->speed =
++				state->link ? SPEED_1000 : SPEED_UNKNOWN;
++
++			return 0;
++		}
++	}
++
++	return mv88e6352_port_link_state(chip, port, state);
++}
++
+ /* Offset 0x02: Jamming Control
+  *
+  * Do not limit the period of time that this port can be paused for by
+diff --git a/drivers/net/dsa/mv88e6xxx/port.h b/drivers/net/dsa/mv88e6xxx/port.h
+index c2fce7c1cb37..7dd0c6e1991b 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.h
++++ b/drivers/net/dsa/mv88e6xxx/port.h
+@@ -42,14 +42,28 @@
+ #define MV88E6XXX_PORT_STS_CMODE_2500BASEX	0x000b
+ #define MV88E6XXX_PORT_STS_CMODE_XAUI		0x000c
+ #define MV88E6XXX_PORT_STS_CMODE_RXAUI		0x000d
++#define MV88E6185_PORT_STS_CDUPLEX		0x0008
++#define MV88E6185_PORT_STS_CMODE_MASK		0x0007
++#define MV88E6185_PORT_STS_CMODE_GMII_FD	0x0000
++#define MV88E6185_PORT_STS_CMODE_MII_100_FD_PS	0x0001
++#define MV88E6185_PORT_STS_CMODE_MII_100	0x0002
++#define MV88E6185_PORT_STS_CMODE_MII_10		0x0003
++#define MV88E6185_PORT_STS_CMODE_SERDES		0x0004
++#define MV88E6185_PORT_STS_CMODE_1000BASE_X	0x0005
++#define MV88E6185_PORT_STS_CMODE_PHY		0x0006
++#define MV88E6185_PORT_STS_CMODE_DISABLED	0x0007
+ 
+ /* Offset 0x01: MAC (or PCS or Physical) Control Register */
+ #define MV88E6XXX_PORT_MAC_CTL				0x01
+ #define MV88E6XXX_PORT_MAC_CTL_RGMII_DELAY_RXCLK	0x8000
+ #define MV88E6XXX_PORT_MAC_CTL_RGMII_DELAY_TXCLK	0x4000
++#define MV88E6185_PORT_MAC_CTL_SYNC_OK			0x4000
+ #define MV88E6390_PORT_MAC_CTL_FORCE_SPEED		0x2000
+ #define MV88E6390_PORT_MAC_CTL_ALTSPEED			0x1000
+ #define MV88E6352_PORT_MAC_CTL_200BASE			0x1000
++#define MV88E6185_PORT_MAC_CTL_AN_EN			0x0400
++#define MV88E6185_PORT_MAC_CTL_AN_RESTART		0x0200
++#define MV88E6185_PORT_MAC_CTL_AN_DONE			0x0100
+ #define MV88E6XXX_PORT_MAC_CTL_FC			0x0080
+ #define MV88E6XXX_PORT_MAC_CTL_FORCE_FC			0x0040
+ #define MV88E6XXX_PORT_MAC_CTL_LINK_UP			0x0020
+@@ -308,7 +322,9 @@ int mv88e6390_port_pause_limit(struct mv88e6xxx_chip *chip, int port, u8 in,
+ int mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
+ 			      phy_interface_t mode);
+ int mv88e6xxx_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode);
+-int mv88e6xxx_port_link_state(struct mv88e6xxx_chip *chip, int port,
++int mv88e6185_port_link_state(struct mv88e6xxx_chip *chip, int port,
++			      struct phylink_link_state *state);
++int mv88e6352_port_link_state(struct mv88e6xxx_chip *chip, int port,
+ 			      struct phylink_link_state *state);
+ int mv88e6xxx_port_set_map_da(struct mv88e6xxx_chip *chip, int port);
+ int mv88e6095_port_set_upstream_port(struct mv88e6xxx_chip *chip, int port,
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90087-net-dsa-mv88e6xxx-Refactor-SERDES-lane-code.patch b/target/linux/mvebu/patches-4.14/90087-net-dsa-mv88e6xxx-Refactor-SERDES-lane-code.patch
new file mode 100644
index 0000000..28e357c
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90087-net-dsa-mv88e6xxx-Refactor-SERDES-lane-code.patch
@@ -0,0 +1,284 @@
+From d3a4ff01fb15fc08c3edbf9d3baf457af47d4403 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:40 +0200
+Subject: [PATCH 087/126] net: dsa: mv88e6xxx: Refactor SERDES lane code
+
+The 6390 family has 8 SERDES lanes. What ports use these lanes depends
+on how ports 9 and 10 are configured. If 9 and 10 does not make use of
+a line, one of the lower ports can use it.
+
+Add a function to return the lane a port is using, if any, and simplify
+the code to power up/down the lane.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/serdes.c | 195 +++++++++++++++++------------
+ 1 file changed, 114 insertions(+), 81 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index f3c01119b3d1..c467adb874a6 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -75,8 +75,97 @@ int mv88e6352_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ 	return 0;
+ }
+ 
++/* Return the SERDES lane address a port is using. Ports 9 and 10 can
++ * use multiple lanes. If so, return the first lane the port uses.
++ * Returns -ENODEV if a port does not have a lane.
++ */
++static int mv88e6390_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
++{
++	u8 cmode_port9, cmode_port10, cmode_port;
++	int err;
++
++	err = mv88e6xxx_port_get_cmode(chip, 9, &cmode_port9);
++	if (err)
++		return err;
++
++	err = mv88e6xxx_port_get_cmode(chip, 10, &cmode_port10);
++	if (err)
++		return err;
++
++	err = mv88e6xxx_port_get_cmode(chip, port, &cmode_port);
++	if (err)
++		return err;
++
++	switch (port) {
++	case 2:
++		if (cmode_port9 == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_SGMII ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_2500BASEX)
++			if (cmode_port == MV88E6XXX_PORT_STS_CMODE_1000BASE_X)
++				return MV88E6390_PORT9_LANE1;
++		return -ENODEV;
++	case 3:
++		if (cmode_port9 == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_SGMII ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_2500BASEX ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_RXAUI)
++			if (cmode_port == MV88E6XXX_PORT_STS_CMODE_1000BASE_X)
++				return MV88E6390_PORT9_LANE2;
++		return -ENODEV;
++	case 4:
++		if (cmode_port9 == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_SGMII ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_2500BASEX ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_RXAUI)
++			if (cmode_port == MV88E6XXX_PORT_STS_CMODE_1000BASE_X)
++				return MV88E6390_PORT9_LANE3;
++		return -ENODEV;
++	case 5:
++		if (cmode_port10 == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_SGMII ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_2500BASEX)
++			if (cmode_port == MV88E6XXX_PORT_STS_CMODE_1000BASE_X)
++				return MV88E6390_PORT10_LANE1;
++		return -ENODEV;
++	case 6:
++		if (cmode_port10 == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_SGMII ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_2500BASEX ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_RXAUI)
++			if (cmode_port == MV88E6XXX_PORT_STS_CMODE_1000BASE_X)
++				return MV88E6390_PORT10_LANE2;
++		return -ENODEV;
++	case 7:
++		if (cmode_port10 == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_SGMII ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_2500BASEX ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_RXAUI)
++			if (cmode_port == MV88E6XXX_PORT_STS_CMODE_1000BASE_X)
++				return MV88E6390_PORT10_LANE3;
++		return -ENODEV;
++	case 9:
++		if (cmode_port9 == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_SGMII ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_2500BASEX ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_XAUI ||
++		    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_RXAUI)
++			return MV88E6390_PORT9_LANE0;
++		return -ENODEV;
++	case 10:
++		if (cmode_port10 == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_SGMII ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_2500BASEX ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_XAUI ||
++		    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_RXAUI)
++			return MV88E6390_PORT10_LANE0;
++		return -ENODEV;
++	default:
++		return -ENODEV;
++	}
++}
++
+ /* Set the power on/off for 10GBASE-R and 10GBASE-X4/X2 */
+-static int mv88e6390_serdes_10g(struct mv88e6xxx_chip *chip, int addr, bool on)
++static int mv88e6390_serdes_10g(struct mv88e6xxx_chip *chip, int lane, bool on)
+ {
+ 	u16 val, new_val;
+ 	int reg_c45;
+@@ -84,7 +173,7 @@ static int mv88e6390_serdes_10g(struct mv88e6xxx_chip *chip, int addr, bool on)
+ 
+ 	reg_c45 = MII_ADDR_C45 | MV88E6390_SERDES_DEVICE |
+ 		MV88E6390_PCS_CONTROL_1;
+-	err = mv88e6xxx_phy_read(chip, addr, reg_c45, &val);
++	err = mv88e6xxx_phy_read(chip, lane, reg_c45, &val);
+ 	if (err)
+ 		return err;
+ 
+@@ -96,13 +185,13 @@ static int mv88e6390_serdes_10g(struct mv88e6xxx_chip *chip, int addr, bool on)
+ 		new_val = val | MV88E6390_PCS_CONTROL_1_PDOWN;
+ 
+ 	if (val != new_val)
+-		err = mv88e6xxx_phy_write(chip, addr, reg_c45, new_val);
++		err = mv88e6xxx_phy_write(chip, lane, reg_c45, new_val);
+ 
+ 	return err;
+ }
+ 
+-/* Set the power on/off for 10GBASE-R and 10GBASE-X4/X2 */
+-static int mv88e6390_serdes_sgmii(struct mv88e6xxx_chip *chip, int addr,
++/* Set the power on/off for SGMII and 1000Base-X */
++static int mv88e6390_serdes_sgmii(struct mv88e6xxx_chip *chip, int lane,
+ 				  bool on)
+ {
+ 	u16 val, new_val;
+@@ -111,7 +200,7 @@ static int mv88e6390_serdes_sgmii(struct mv88e6xxx_chip *chip, int addr,
+ 
+ 	reg_c45 = MII_ADDR_C45 | MV88E6390_SERDES_DEVICE |
+ 		MV88E6390_SGMII_CONTROL;
+-	err = mv88e6xxx_phy_read(chip, addr, reg_c45, &val);
++	err = mv88e6xxx_phy_read(chip, lane, reg_c45, &val);
+ 	if (err)
+ 		return err;
+ 
+@@ -123,63 +212,29 @@ static int mv88e6390_serdes_sgmii(struct mv88e6xxx_chip *chip, int addr,
+ 		new_val = val | MV88E6390_SGMII_CONTROL_PDOWN;
+ 
+ 	if (val != new_val)
+-		err = mv88e6xxx_phy_write(chip, addr, reg_c45, new_val);
++		err = mv88e6xxx_phy_write(chip, lane, reg_c45, new_val);
+ 
+ 	return err;
+ }
+ 
+-static int mv88e6390_serdes_lower(struct mv88e6xxx_chip *chip, u8 cmode,
+-				  int port_donor, int lane, bool rxaui, bool on)
++static int mv88e6390_serdes_power_lane(struct mv88e6xxx_chip *chip, int port,
++				       int lane, bool on)
+ {
++	u8 cmode;
+ 	int err;
+-	u8 cmode_donor;
+ 
+-	err = mv88e6xxx_port_get_cmode(chip, port_donor, &cmode_donor);
++	err = mv88e6xxx_port_get_cmode(chip, port, &cmode);
+ 	if (err)
+ 		return err;
+ 
+-	switch (cmode_donor) {
+-	case MV88E6XXX_PORT_STS_CMODE_RXAUI:
+-		if (!rxaui)
+-			break;
+-		/* Fall through */
+-	case MV88E6XXX_PORT_STS_CMODE_1000BASE_X:
+-	case MV88E6XXX_PORT_STS_CMODE_SGMII:
+-	case MV88E6XXX_PORT_STS_CMODE_2500BASEX:
+-		if (cmode == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
+-		    cmode == MV88E6XXX_PORT_STS_CMODE_SGMII)
+-			return	mv88e6390_serdes_sgmii(chip, lane, on);
+-	}
+-	return 0;
+-}
+-
+-static int mv88e6390_serdes_port9(struct mv88e6xxx_chip *chip, u8 cmode,
+-				  bool on)
+-{
+-	switch (cmode) {
+-	case MV88E6XXX_PORT_STS_CMODE_1000BASE_X:
+-	case MV88E6XXX_PORT_STS_CMODE_SGMII:
+-		return mv88e6390_serdes_sgmii(chip, MV88E6390_PORT9_LANE0, on);
+-	case MV88E6XXX_PORT_STS_CMODE_XAUI:
+-	case MV88E6XXX_PORT_STS_CMODE_RXAUI:
+-	case MV88E6XXX_PORT_STS_CMODE_2500BASEX:
+-		return mv88e6390_serdes_10g(chip, MV88E6390_PORT9_LANE0, on);
+-	}
+-
+-	return 0;
+-}
+-
+-static int mv88e6390_serdes_port10(struct mv88e6xxx_chip *chip, u8 cmode,
+-				   bool on)
+-{
+ 	switch (cmode) {
+ 	case MV88E6XXX_PORT_STS_CMODE_SGMII:
+-		return mv88e6390_serdes_sgmii(chip, MV88E6390_PORT10_LANE0, on);
++	case MV88E6XXX_PORT_STS_CMODE_1000BASE_X:
++		return mv88e6390_serdes_sgmii(chip, lane, on);
+ 	case MV88E6XXX_PORT_STS_CMODE_XAUI:
+ 	case MV88E6XXX_PORT_STS_CMODE_RXAUI:
+-	case MV88E6XXX_PORT_STS_CMODE_1000BASE_X:
+ 	case MV88E6XXX_PORT_STS_CMODE_2500BASEX:
+-		return mv88e6390_serdes_10g(chip, MV88E6390_PORT10_LANE0, on);
++		return mv88e6390_serdes_10g(chip, lane, on);
+ 	}
+ 
+ 	return 0;
+@@ -187,42 +242,20 @@ static int mv88e6390_serdes_port10(struct mv88e6xxx_chip *chip, u8 cmode,
+ 
+ int mv88e6390_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ {
+-	u8 cmode;
+-	int err;
++	int lane;
+ 
+-	err = mv88e6xxx_port_get_cmode(chip, port, &cmode);
+-	if (err)
+-		return err;
++	lane = mv88e6390_serdes_get_lane(chip, port);
++	if (lane == -ENODEV)
++		return 0;
++
++	if (lane < 0)
++		return lane;
+ 
+ 	switch (port) {
+-	case 2:
+-		return mv88e6390_serdes_lower(chip, cmode, 9,
+-					      MV88E6390_PORT9_LANE1,
+-					      false, on);
+-	case 3:
+-		return mv88e6390_serdes_lower(chip, cmode, 9,
+-					      MV88E6390_PORT9_LANE2,
+-					      true, on);
+-	case 4:
+-		return mv88e6390_serdes_lower(chip, cmode, 9,
+-					      MV88E6390_PORT9_LANE3,
+-					      true, on);
+-	case 5:
+-		return mv88e6390_serdes_lower(chip, cmode, 10,
+-					      MV88E6390_PORT10_LANE1,
+-					      false, on);
+-	case 6:
+-		return mv88e6390_serdes_lower(chip, cmode, 10,
+-					      MV88E6390_PORT10_LANE2,
+-					      true, on);
+-	case 7:
+-		return mv88e6390_serdes_lower(chip, cmode, 10,
+-					      MV88E6390_PORT10_LANE3,
+-					      true, on);
+-	case 9:
+-		return mv88e6390_serdes_port9(chip, cmode, on);
+-	case 10:
+-		return mv88e6390_serdes_port10(chip, cmode, on);
++	case 2 ... 4:
++	case 5 ... 7:
++	case 9 ... 10:
++		return mv88e6390_serdes_power_lane(chip, port, lane, on);
+ 	}
+ 
+ 	return 0;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90088-net-dsa-mv88e6xxx-6390-vs-6390X-SERDES-support.patch b/target/linux/mvebu/patches-4.14/90088-net-dsa-mv88e6xxx-6390-vs-6390X-SERDES-support.patch
new file mode 100644
index 0000000..fd31f30
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90088-net-dsa-mv88e6xxx-6390-vs-6390X-SERDES-support.patch
@@ -0,0 +1,126 @@
+From d2e12da262c207b5abe8278248aff3d3fc5e1bb3 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:41 +0200
+Subject: [PATCH 088/126] net: dsa: mv88e6xxx: 6390 vs 6390X SERDES support
+
+The 6390 has two SERDES interfaces, used by ports 9 and 10.  The 6390X
+has eight SERDES interfaces. These allow ports 9 and 10 to do 10G. Or
+if lower speeds are used, some of the SERDES interfaces can be used by
+ports 2-8 for 1000Base-X.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c   |  4 +--
+ drivers/net/dsa/mv88e6xxx/serdes.c | 51 +++++++++++++++++++++++++++++-
+ drivers/net/dsa/mv88e6xxx/serdes.h |  1 +
+ 3 files changed, 53 insertions(+), 3 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index f83c1cb44a80..4ca6728123ff 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -3046,7 +3046,7 @@ static const struct mv88e6xxx_ops mv88e6190x_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+-	.serdes_power = mv88e6390_serdes_power,
++	.serdes_power = mv88e6390x_serdes_power,
+ 	.phylink_validate = mv88e6390x_phylink_validate,
+ };
+ 
+@@ -3456,7 +3456,7 @@ static const struct mv88e6xxx_ops mv88e6390x_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+-	.serdes_power = mv88e6390_serdes_power,
++	.serdes_power = mv88e6390x_serdes_power,
+ 	.phylink_validate = mv88e6390x_phylink_validate,
+ };
+ 
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index c467adb874a6..8728c14b9ab5 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -75,11 +75,41 @@ int mv88e6352_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ 	return 0;
+ }
+ 
++/* Return the SERDES lane address a port is using. Only Ports 9 and 10
++ * have SERDES lanes. Returns -ENODEV if a port does not have a lane.
++ */
++static int mv88e6390_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
++{
++	u8 cmode;
++	int err;
++
++	err = mv88e6xxx_port_get_cmode(chip, port, &cmode);
++	if (err)
++		return err;
++
++	switch (port) {
++	case 9:
++		if (cmode == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
++		    cmode == MV88E6XXX_PORT_STS_CMODE_SGMII ||
++		    cmode == MV88E6XXX_PORT_STS_CMODE_2500BASEX)
++			return MV88E6390_PORT9_LANE0;
++		return -ENODEV;
++	case 10:
++		if (cmode == MV88E6XXX_PORT_STS_CMODE_1000BASE_X ||
++		    cmode == MV88E6XXX_PORT_STS_CMODE_SGMII ||
++		    cmode == MV88E6XXX_PORT_STS_CMODE_2500BASEX)
++			return MV88E6390_PORT10_LANE0;
++		return -ENODEV;
++	default:
++		return -ENODEV;
++	}
++}
++
+ /* Return the SERDES lane address a port is using. Ports 9 and 10 can
+  * use multiple lanes. If so, return the first lane the port uses.
+  * Returns -ENODEV if a port does not have a lane.
+  */
+-static int mv88e6390_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
++static int mv88e6390x_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
+ {
+ 	u8 cmode_port9, cmode_port10, cmode_port;
+ 	int err;
+@@ -251,6 +281,25 @@ int mv88e6390_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ 	if (lane < 0)
+ 		return lane;
+ 
++	switch (port) {
++	case 9 ... 10:
++		return mv88e6390_serdes_power_lane(chip, port, lane, on);
++	}
++
++	return 0;
++}
++
++int mv88e6390x_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
++{
++	int lane;
++
++	lane = mv88e6390x_serdes_get_lane(chip, port);
++	if (lane == -ENODEV)
++		return 0;
++
++	if (lane < 0)
++		return lane;
++
+ 	switch (port) {
+ 	case 2 ... 4:
+ 	case 5 ... 7:
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.h b/drivers/net/dsa/mv88e6xxx/serdes.h
+index 5c1cd6d8e9a5..24bbe848a434 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.h
++++ b/drivers/net/dsa/mv88e6xxx/serdes.h
+@@ -44,5 +44,6 @@
+ 
+ int mv88e6352_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6390_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
++int mv88e6390x_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ 
+ #endif
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90089-net-dsa-mv88e6xxx-88E6141-6341-SERDES-support.patch b/target/linux/mvebu/patches-4.14/90089-net-dsa-mv88e6xxx-88E6141-6341-SERDES-support.patch
new file mode 100644
index 0000000..a755ae9
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90089-net-dsa-mv88e6xxx-88E6141-6341-SERDES-support.patch
@@ -0,0 +1,87 @@
+From 40d97086cccb0cbc9e83deaadcfd4124eb39b11a Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Thu, 3 May 2018 16:23:53 +0200
+Subject: [PATCH 089/126] net: dsa: mv88e6xxx: 88E6141/6341 SERDES support
+
+The 88E6141/6341 switches (also known as Topaz) have 1 SGMII lane,
+which can be configured the same way as the SERDES lane on 88E6390.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c   |  2 ++
+ drivers/net/dsa/mv88e6xxx/serdes.c | 20 ++++++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/serdes.h |  3 +++
+ 3 files changed, 25 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 4ca6728123ff..f95495a8dc66 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -2734,6 +2734,7 @@ static const struct mv88e6xxx_ops mv88e6141_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.serdes_power = mv88e6341_serdes_power,
+ 	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+@@ -3267,6 +3268,7 @@ static const struct mv88e6xxx_ops mv88e6341_ops = {
+ 	.reset = mv88e6352_g1_reset,
+ 	.vtu_getnext = mv88e6352_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,
++	.serdes_power = mv88e6341_serdes_power,
+ 	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index 8728c14b9ab5..591703f182dd 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -309,3 +309,23 @@ int mv88e6390x_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ 
+ 	return 0;
+ }
++
++int mv88e6341_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
++{
++	int err;
++	u8 cmode;
++
++	if (port != 5)
++		return 0;
++
++	err = mv88e6xxx_port_get_cmode(chip, port, &cmode);
++	if (err)
++		return err;
++
++	if ((cmode == MV88E6XXX_PORT_STS_CMODE_1000BASE_X) ||
++	     (cmode == MV88E6XXX_PORT_STS_CMODE_SGMII) ||
++	     (cmode == MV88E6XXX_PORT_STS_CMODE_2500BASEX))
++		return mv88e6390_serdes_sgmii(chip, MV88E6341_ADDR_SERDES, on);
++
++	return 0;
++}
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.h b/drivers/net/dsa/mv88e6xxx/serdes.h
+index 24bbe848a434..73781b627564 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.h
++++ b/drivers/net/dsa/mv88e6xxx/serdes.h
+@@ -19,6 +19,8 @@
+ #define MV88E6352_ADDR_SERDES		0x0f
+ #define MV88E6352_SERDES_PAGE_FIBER	0x01
+ 
++#define MV88E6341_ADDR_SERDES		0x15
++
+ #define MV88E6390_PORT9_LANE0		0x09
+ #define MV88E6390_PORT9_LANE1		0x12
+ #define MV88E6390_PORT9_LANE2		0x13
+@@ -42,6 +44,7 @@
+ #define MV88E6390_SGMII_CONTROL_LOOPBACK	BIT(14)
+ #define MV88E6390_SGMII_CONTROL_PDOWN		BIT(11)
+ 
++int mv88e6341_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6352_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6390_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6390x_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90090-net-dsa-mv88e6xxx-Rename-sgmii-10g-power-functions.patch b/target/linux/mvebu/patches-4.14/90090-net-dsa-mv88e6xxx-Rename-sgmii-10g-power-functions.patch
new file mode 100644
index 0000000..4cd2bed
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90090-net-dsa-mv88e6xxx-Rename-sgmii-10g-power-functions.patch
@@ -0,0 +1,65 @@
+From 76afb16c9d4b48d057ff68984fac766a95f874b0 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:42 +0200
+Subject: [PATCH 090/126] net: dsa: mv88e6xxx: Rename sgmii/10g power functions
+
+There is a need to add more functions manipulating the SERDES
+interfaces. Cleanup the namespace.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/serdes.c | 14 ++++++++------
+ 1 file changed, 8 insertions(+), 6 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index 591703f182dd..8886ee41c7f4 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -195,7 +195,8 @@ static int mv88e6390x_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
+ }
+ 
+ /* Set the power on/off for 10GBASE-R and 10GBASE-X4/X2 */
+-static int mv88e6390_serdes_10g(struct mv88e6xxx_chip *chip, int lane, bool on)
++static int mv88e6390_serdes_power_10g(struct mv88e6xxx_chip *chip, int lane,
++				      bool on)
+ {
+ 	u16 val, new_val;
+ 	int reg_c45;
+@@ -221,8 +222,8 @@ static int mv88e6390_serdes_10g(struct mv88e6xxx_chip *chip, int lane, bool on)
+ }
+ 
+ /* Set the power on/off for SGMII and 1000Base-X */
+-static int mv88e6390_serdes_sgmii(struct mv88e6xxx_chip *chip, int lane,
+-				  bool on)
++static int mv88e6390_serdes_power_sgmii(struct mv88e6xxx_chip *chip, int lane,
++					bool on)
+ {
+ 	u16 val, new_val;
+ 	int reg_c45;
+@@ -260,11 +261,11 @@ static int mv88e6390_serdes_power_lane(struct mv88e6xxx_chip *chip, int port,
+ 	switch (cmode) {
+ 	case MV88E6XXX_PORT_STS_CMODE_SGMII:
+ 	case MV88E6XXX_PORT_STS_CMODE_1000BASE_X:
+-		return mv88e6390_serdes_sgmii(chip, lane, on);
++		return mv88e6390_serdes_power_sgmii(chip, lane, on);
+ 	case MV88E6XXX_PORT_STS_CMODE_XAUI:
+ 	case MV88E6XXX_PORT_STS_CMODE_RXAUI:
+ 	case MV88E6XXX_PORT_STS_CMODE_2500BASEX:
+-		return mv88e6390_serdes_10g(chip, lane, on);
++		return mv88e6390_serdes_power_10g(chip, lane, on);
+ 	}
+ 
+ 	return 0;
+@@ -325,7 +326,8 @@ int mv88e6341_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ 	if ((cmode == MV88E6XXX_PORT_STS_CMODE_1000BASE_X) ||
+ 	     (cmode == MV88E6XXX_PORT_STS_CMODE_SGMII) ||
+ 	     (cmode == MV88E6XXX_PORT_STS_CMODE_2500BASEX))
+-		return mv88e6390_serdes_sgmii(chip, MV88E6341_ADDR_SERDES, on);
++		return mv88e6390_serdes_power_sgmii(chip, MV88E6341_ADDR_SERDES,
++						    on);
+ 
+ 	return 0;
+ }
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90091-net-dsa-mv88e6xxx-Add-serdes-register-read-write-hel.patch b/target/linux/mvebu/patches-4.14/90091-net-dsa-mv88e6xxx-Add-serdes-register-read-write-hel.patch
new file mode 100644
index 0000000..870deb6
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90091-net-dsa-mv88e6xxx-Add-serdes-register-read-write-hel.patch
@@ -0,0 +1,107 @@
+From 48e064e620263fabba4ed31509386b60073d5a7d Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:43 +0200
+Subject: [PATCH 091/126] net: dsa: mv88e6xxx: Add serdes register read/write
+ helper
+
+Add a helper for accessing SERDES registers of the 6390 family.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/serdes.c | 35 +++++++++++++++++++++---------
+ drivers/net/dsa/mv88e6xxx/serdes.h |  1 -
+ 2 files changed, 25 insertions(+), 11 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index 8886ee41c7f4..e8ce757c6ae0 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -35,6 +35,22 @@ static int mv88e6352_serdes_write(struct mv88e6xxx_chip *chip, int reg,
+ 					reg, val);
+ }
+ 
++static int mv88e6390_serdes_read(struct mv88e6xxx_chip *chip,
++				 int lane, int device, int reg, u16 *val)
++{
++	int reg_c45 = MII_ADDR_C45 | device << 16 | reg;
++
++	return mv88e6xxx_phy_read(chip, lane, reg_c45, val);
++}
++
++static int mv88e6390_serdes_write(struct mv88e6xxx_chip *chip,
++				  int lane, int device, int reg, u16 val)
++{
++	int reg_c45 = MII_ADDR_C45 | device << 16 | reg;
++
++	return mv88e6xxx_phy_write(chip, lane, reg_c45, val);
++}
++
+ static int mv88e6352_serdes_power_set(struct mv88e6xxx_chip *chip, bool on)
+ {
+ 	u16 val, new_val;
+@@ -199,12 +215,11 @@ static int mv88e6390_serdes_power_10g(struct mv88e6xxx_chip *chip, int lane,
+ 				      bool on)
+ {
+ 	u16 val, new_val;
+-	int reg_c45;
+ 	int err;
+ 
+-	reg_c45 = MII_ADDR_C45 | MV88E6390_SERDES_DEVICE |
+-		MV88E6390_PCS_CONTROL_1;
+-	err = mv88e6xxx_phy_read(chip, lane, reg_c45, &val);
++	err = mv88e6390_serdes_read(chip, lane, MDIO_MMD_PHYXS,
++				    MV88E6390_PCS_CONTROL_1, &val);
++
+ 	if (err)
+ 		return err;
+ 
+@@ -216,7 +231,8 @@ static int mv88e6390_serdes_power_10g(struct mv88e6xxx_chip *chip, int lane,
+ 		new_val = val | MV88E6390_PCS_CONTROL_1_PDOWN;
+ 
+ 	if (val != new_val)
+-		err = mv88e6xxx_phy_write(chip, lane, reg_c45, new_val);
++		err = mv88e6390_serdes_write(chip, lane, MDIO_MMD_PHYXS,
++					     MV88E6390_PCS_CONTROL_1, new_val);
+ 
+ 	return err;
+ }
+@@ -226,12 +242,10 @@ static int mv88e6390_serdes_power_sgmii(struct mv88e6xxx_chip *chip, int lane,
+ 					bool on)
+ {
+ 	u16 val, new_val;
+-	int reg_c45;
+ 	int err;
+ 
+-	reg_c45 = MII_ADDR_C45 | MV88E6390_SERDES_DEVICE |
+-		MV88E6390_SGMII_CONTROL;
+-	err = mv88e6xxx_phy_read(chip, lane, reg_c45, &val);
++	err = mv88e6390_serdes_read(chip, lane, MDIO_MMD_PHYXS,
++				    MV88E6390_SGMII_CONTROL, &val);
+ 	if (err)
+ 		return err;
+ 
+@@ -243,7 +257,8 @@ static int mv88e6390_serdes_power_sgmii(struct mv88e6xxx_chip *chip, int lane,
+ 		new_val = val | MV88E6390_SGMII_CONTROL_PDOWN;
+ 
+ 	if (val != new_val)
+-		err = mv88e6xxx_phy_write(chip, lane, reg_c45, new_val);
++		err = mv88e6390_serdes_write(chip, lane, MDIO_MMD_PHYXS,
++					     MV88E6390_SGMII_CONTROL, new_val);
+ 
+ 	return err;
+ }
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.h b/drivers/net/dsa/mv88e6xxx/serdes.h
+index 73781b627564..aa156d2a4004 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.h
++++ b/drivers/net/dsa/mv88e6xxx/serdes.h
+@@ -29,7 +29,6 @@
+ #define MV88E6390_PORT10_LANE1		0x15
+ #define MV88E6390_PORT10_LANE2		0x16
+ #define MV88E6390_PORT10_LANE3		0x17
+-#define MV88E6390_SERDES_DEVICE		(4 << 16)
+ 
+ /* 10GBASE-R and 10GBASE-X4/X2 */
+ #define MV88E6390_PCS_CONTROL_1		0x1000
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90092-net-dsa-mv88e6xxx-2500Base-X-uses-the-1000Base-X-SER.patch b/target/linux/mvebu/patches-4.14/90092-net-dsa-mv88e6xxx-2500Base-X-uses-the-1000Base-X-SER.patch
new file mode 100644
index 0000000..89e1a46
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90092-net-dsa-mv88e6xxx-2500Base-X-uses-the-1000Base-X-SER.patch
@@ -0,0 +1,34 @@
+From 6ee5c154b5b9a6fd7f07ec087f03e14a5b6ab667 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:44 +0200
+Subject: [PATCH 092/126] net: dsa: mv88e6xxx: 2500Base-X uses the 1000Base-X
+ SERDES
+
+The 6390 has three different SERDES interface types. 2500Base-X is
+implemented by the SGMII/1000Base-X SERDES. So power on/off the
+correct SERDES.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/serdes.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index e8ce757c6ae0..be72f0e02951 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -276,10 +276,10 @@ static int mv88e6390_serdes_power_lane(struct mv88e6xxx_chip *chip, int port,
+ 	switch (cmode) {
+ 	case MV88E6XXX_PORT_STS_CMODE_SGMII:
+ 	case MV88E6XXX_PORT_STS_CMODE_1000BASE_X:
++	case MV88E6XXX_PORT_STS_CMODE_2500BASEX:
+ 		return mv88e6390_serdes_power_sgmii(chip, lane, on);
+ 	case MV88E6XXX_PORT_STS_CMODE_XAUI:
+ 	case MV88E6XXX_PORT_STS_CMODE_RXAUI:
+-	case MV88E6XXX_PORT_STS_CMODE_2500BASEX:
+ 		return mv88e6390_serdes_power_10g(chip, lane, on);
+ 	}
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90093-net-dsa-mv88e6xxx-Cache-the-port-cmode.patch b/target/linux/mvebu/patches-4.14/90093-net-dsa-mv88e6xxx-Cache-the-port-cmode.patch
new file mode 100644
index 0000000..5bd4ece
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90093-net-dsa-mv88e6xxx-Cache-the-port-cmode.patch
@@ -0,0 +1,439 @@
+From 12344a79a9537a38b30eecddccb88596a1bcad03 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:45 +0200
+Subject: [PATCH 093/126] net: dsa: mv88e6xxx: Cache the port cmode
+
+The ports CMODE indicates the type of link between the MAC and the
+PHY. It is used often in the SERDES code. Rather than read it each
+time, cache its value.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c   | 38 +++++++++++++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/chip.h   |  8 ++++++
+ drivers/net/dsa/mv88e6xxx/port.c   | 16 ++++++------
+ drivers/net/dsa/mv88e6xxx/port.h   |  3 ++-
+ drivers/net/dsa/mv88e6xxx/serdes.c | 42 +++++-------------------------
+ 5 files changed, 63 insertions(+), 44 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index f95495a8dc66..9a4bec1627f1 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -2272,6 +2272,7 @@ static int mv88e6390_setup_errata(struct mv88e6xxx_chip *chip)
+ static int mv88e6xxx_setup(struct dsa_switch *ds)
+ {
+ 	struct mv88e6xxx_chip *chip = ds->priv;
++	u8 cmode;
+ 	int err;
+ 	int i;
+ 
+@@ -2286,6 +2287,17 @@ static int mv88e6xxx_setup(struct dsa_switch *ds)
+ 			goto unlock;
+ 	}
+ 
++	/* Cache the cmode of each port. */
++	for (i = 0; i < mv88e6xxx_num_ports(chip); i++) {
++		if (chip->info->ops->port_get_cmode) {
++			err = chip->info->ops->port_get_cmode(chip, i, &cmode);
++			if (err)
++				return err;
++
++			chip->ports[i].cmode = cmode;
++		}
++	}
++
+ 	/* Setup Switch Port Registers */
+ 	for (i = 0; i < mv88e6xxx_num_ports(chip); i++) {
+ 		err = mv88e6xxx_setup_port(chip, i);
+@@ -2561,6 +2573,7 @@ static const struct mv88e6xxx_ops mv88e6085_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6185_port_get_cmode,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2590,6 +2603,7 @@ static const struct mv88e6xxx_ops mv88e6095_ops = {
+ 	.port_set_egress_floods = mv88e6185_port_set_egress_floods,
+ 	.port_set_upstream_port = mv88e6095_port_set_upstream_port,
+ 	.port_link_state = mv88e6185_port_link_state,
++	.port_get_cmode = mv88e6185_port_get_cmode,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2622,6 +2636,7 @@ static const struct mv88e6xxx_ops mv88e6097_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6185_port_get_cmode,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2651,6 +2666,7 @@ static const struct mv88e6xxx_ops mv88e6123_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6185_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2684,6 +2700,7 @@ static const struct mv88e6xxx_ops mv88e6131_ops = {
+ 	.port_pause_limit = mv88e6097_port_pause_limit,
+ 	.port_set_pause = mv88e6185_port_set_pause,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6185_port_get_cmode,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2722,6 +2739,7 @@ static const struct mv88e6xxx_ops mv88e6141_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6320_stats_get_strings,
+@@ -2757,6 +2775,7 @@ static const struct mv88e6xxx_ops mv88e6161_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6185_port_get_cmode,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2784,6 +2803,7 @@ static const struct mv88e6xxx_ops mv88e6165_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6185_port_get_cmode,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2819,6 +2839,7 @@ static const struct mv88e6xxx_ops mv88e6171_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2856,6 +2877,7 @@ static const struct mv88e6xxx_ops mv88e6172_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2892,6 +2914,7 @@ static const struct mv88e6xxx_ops mv88e6175_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2929,6 +2952,7 @@ static const struct mv88e6xxx_ops mv88e6176_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2959,6 +2983,7 @@ static const struct mv88e6xxx_ops mv88e6185_ops = {
+ 	.port_set_upstream_port = mv88e6095_port_set_upstream_port,
+ 	.port_set_pause = mv88e6185_port_set_pause,
+ 	.port_link_state = mv88e6185_port_link_state,
++	.port_get_cmode = mv88e6185_port_get_cmode,
+ 	.stats_snapshot = mv88e6xxx_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -2996,6 +3021,7 @@ static const struct mv88e6xxx_ops mv88e6190_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -3034,6 +3060,7 @@ static const struct mv88e6xxx_ops mv88e6190x_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -3072,6 +3099,7 @@ static const struct mv88e6xxx_ops mv88e6191_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -3111,6 +3139,7 @@ static const struct mv88e6xxx_ops mv88e6240_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -3149,6 +3178,7 @@ static const struct mv88e6xxx_ops mv88e6290_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -3187,6 +3217,7 @@ static const struct mv88e6xxx_ops mv88e6320_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6320_stats_get_strings,
+@@ -3222,6 +3253,7 @@ static const struct mv88e6xxx_ops mv88e6321_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6320_stats_get_strings,
+@@ -3256,6 +3288,7 @@ static const struct mv88e6xxx_ops mv88e6341_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6320_stats_get_strings,
+@@ -3292,6 +3325,7 @@ static const struct mv88e6xxx_ops mv88e6350_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -3327,6 +3361,7 @@ static const struct mv88e6xxx_ops mv88e6351_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -3364,6 +3399,7 @@ static const struct mv88e6xxx_ops mv88e6352_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6320_g1_stats_snapshot,
+ 	.stats_get_sset_count = mv88e6095_stats_get_sset_count,
+ 	.stats_get_strings = mv88e6095_stats_get_strings,
+@@ -3404,6 +3440,7 @@ static const struct mv88e6xxx_ops mv88e6390_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+@@ -3445,6 +3482,7 @@ static const struct mv88e6xxx_ops mv88e6390x_ops = {
+ 	.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,
+ 	.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,
+ 	.port_link_state = mv88e6352_port_link_state,
++	.port_get_cmode = mv88e6352_port_get_cmode,
+ 	.stats_snapshot = mv88e6390_g1_stats_snapshot,
+ 	.stats_set_histogram = mv88e6390_g1_stats_set_histogram,
+ 	.stats_get_sset_count = mv88e6320_stats_get_sset_count,
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.h b/drivers/net/dsa/mv88e6xxx/chip.h
+index f6053799aa5a..d1f706c27cec 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.h
++++ b/drivers/net/dsa/mv88e6xxx/chip.h
+@@ -154,6 +154,10 @@ struct mv88e6xxx_irq {
+ 	unsigned int nirqs;
+ };
+ 
++struct mv88e6xxx_port {
++	u8 cmode;
++};
++
+ struct mv88e6xxx_chip {
+ 	const struct mv88e6xxx_info *info;
+ 
+@@ -207,6 +211,9 @@ struct mv88e6xxx_chip {
+ 	int irq;
+ 	int device_irq;
+ 	int watchdog_irq;
++
++	/* Array of port structures. */
++	struct mv88e6xxx_port ports[DSA_MAX_PORTS];
+ };
+ 
+ struct mv88e6xxx_bus_ops {
+@@ -318,6 +325,7 @@ struct mv88e6xxx_ops {
+ 	 */
+ 	int (*port_set_cmode)(struct mv88e6xxx_chip *chip, int port,
+ 			      phy_interface_t mode);
++	int (*port_get_cmode)(struct mv88e6xxx_chip *chip, int port, u8 *cmode);
+ 
+ 	/* Some devices have a per port register indicating what is
+ 	 * the upstream port this port should forward to.
+diff --git a/drivers/net/dsa/mv88e6xxx/port.c b/drivers/net/dsa/mv88e6xxx/port.c
+index 62f39603920f..8260310bf393 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.c
++++ b/drivers/net/dsa/mv88e6xxx/port.c
+@@ -384,11 +384,12 @@ int mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
+ 			return err;
+ 	}
+ 
++	chip->ports[port].cmode = cmode;
++
+ 	return 0;
+ }
+ 
+-/* mv88e6185 only has 3 bits for CMODE */
+-static int mv88e6185_port_get_cmode(struct mv88e6xxx_chip *chip, int port)
++int mv88e6185_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode)
+ {
+ 	int err;
+ 	u16 reg;
+@@ -397,10 +398,12 @@ static int mv88e6185_port_get_cmode(struct mv88e6xxx_chip *chip, int port)
+ 	if (err)
+ 		return err;
+ 
+-	return reg & MV88E6185_PORT_STS_CMODE_MASK;
++	*cmode = reg & MV88E6185_PORT_STS_CMODE_MASK;
++
++	return 0;
+ }
+ 
+-int mv88e6xxx_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode)
++int mv88e6352_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode)
+ {
+ 	int err;
+ 	u16 reg;
+@@ -456,10 +459,7 @@ int mv88e6185_port_link_state(struct mv88e6xxx_chip *chip, int port,
+ 			      struct phylink_link_state *state)
+ {
+ 	if (state->interface == PHY_INTERFACE_MODE_1000BASEX) {
+-		int cmode = mv88e6185_port_get_cmode(chip, port);
+-
+-		if (cmode < 0)
+-			return cmode;
++		u8 cmode = chip->ports[port].cmode;
+ 
+ 		/* When a port is in "Cross-chip serdes" mode, it uses
+ 		 * 1000Base-X full duplex mode, but there is no automatic
+diff --git a/drivers/net/dsa/mv88e6xxx/port.h b/drivers/net/dsa/mv88e6xxx/port.h
+index 7dd0c6e1991b..b31910023bb6 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.h
++++ b/drivers/net/dsa/mv88e6xxx/port.h
+@@ -321,7 +321,8 @@ int mv88e6390_port_pause_limit(struct mv88e6xxx_chip *chip, int port, u8 in,
+ 			       u8 out);
+ int mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
+ 			      phy_interface_t mode);
+-int mv88e6xxx_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode);
++int mv88e6185_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode);
++int mv88e6352_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode);
+ int mv88e6185_port_link_state(struct mv88e6xxx_chip *chip, int port,
+ 			      struct phylink_link_state *state);
+ int mv88e6352_port_link_state(struct mv88e6xxx_chip *chip, int port,
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index be72f0e02951..9469bb819a34 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -73,12 +73,8 @@ static int mv88e6352_serdes_power_set(struct mv88e6xxx_chip *chip, bool on)
+ 
+ int mv88e6352_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ {
++	u8 cmode = chip->ports[port].cmode;
+ 	int err;
+-	u8 cmode;
+-
+-	err = mv88e6xxx_port_get_cmode(chip, port, &cmode);
+-	if (err)
+-		return err;
+ 
+ 	if ((cmode == MV88E6XXX_PORT_STS_CMODE_100BASE_X) ||
+ 	    (cmode == MV88E6XXX_PORT_STS_CMODE_1000BASE_X) ||
+@@ -96,12 +92,7 @@ int mv88e6352_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+  */
+ static int mv88e6390_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
+ {
+-	u8 cmode;
+-	int err;
+-
+-	err = mv88e6xxx_port_get_cmode(chip, port, &cmode);
+-	if (err)
+-		return err;
++	u8 cmode = chip->ports[port].cmode;
+ 
+ 	switch (port) {
+ 	case 9:
+@@ -128,19 +119,10 @@ static int mv88e6390_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
+ static int mv88e6390x_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
+ {
+ 	u8 cmode_port9, cmode_port10, cmode_port;
+-	int err;
+-
+-	err = mv88e6xxx_port_get_cmode(chip, 9, &cmode_port9);
+-	if (err)
+-		return err;
+-
+-	err = mv88e6xxx_port_get_cmode(chip, 10, &cmode_port10);
+-	if (err)
+-		return err;
+ 
+-	err = mv88e6xxx_port_get_cmode(chip, port, &cmode_port);
+-	if (err)
+-		return err;
++	cmode_port9 = chip->ports[9].cmode;
++	cmode_port10 = chip->ports[10].cmode;
++	cmode_port = chip->ports[port].cmode;
+ 
+ 	switch (port) {
+ 	case 2:
+@@ -266,12 +248,7 @@ static int mv88e6390_serdes_power_sgmii(struct mv88e6xxx_chip *chip, int lane,
+ static int mv88e6390_serdes_power_lane(struct mv88e6xxx_chip *chip, int port,
+ 				       int lane, bool on)
+ {
+-	u8 cmode;
+-	int err;
+-
+-	err = mv88e6xxx_port_get_cmode(chip, port, &cmode);
+-	if (err)
+-		return err;
++	u8 cmode = chip->ports[port].cmode;
+ 
+ 	switch (cmode) {
+ 	case MV88E6XXX_PORT_STS_CMODE_SGMII:
+@@ -328,16 +305,11 @@ int mv88e6390x_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ 
+ int mv88e6341_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ {
+-	int err;
+-	u8 cmode;
++	u8 cmode = chip->ports[port].cmode;
+ 
+ 	if (port != 5)
+ 		return 0;
+ 
+-	err = mv88e6xxx_port_get_cmode(chip, port, &cmode);
+-	if (err)
+-		return err;
+-
+ 	if ((cmode == MV88E6XXX_PORT_STS_CMODE_1000BASE_X) ||
+ 	     (cmode == MV88E6XXX_PORT_STS_CMODE_SGMII) ||
+ 	     (cmode == MV88E6XXX_PORT_STS_CMODE_2500BASEX))
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90094-net-dsa-mv88e6xxx-Power-on-off-SERDES-on-cmode-chang.patch b/target/linux/mvebu/patches-4.14/90094-net-dsa-mv88e6xxx-Power-on-off-SERDES-on-cmode-chang.patch
new file mode 100644
index 0000000..4611fc0
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90094-net-dsa-mv88e6xxx-Power-on-off-SERDES-on-cmode-chang.patch
@@ -0,0 +1,53 @@
+From 1f684c1eeed93c8acc38fbfa5a64b0bfb0260a02 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:46 +0200
+Subject: [PATCH 094/126] net: dsa: mv88e6xxx: Power on/off SERDES on cmode
+ change
+
+The 6390 family has a number of SERDES interfaces per port. When the
+cmode changes, eg 1000Base-X to XAUI, the SERDES interface in use will
+also change. Power down the old SERDES interface and power up the new
+SERDES interface.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/port.c | 9 +++++++++
+ 1 file changed, 9 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/port.c b/drivers/net/dsa/mv88e6xxx/port.c
+index 8260310bf393..20162add36be 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.c
++++ b/drivers/net/dsa/mv88e6xxx/port.c
+@@ -19,6 +19,7 @@
+ 
+ #include "chip.h"
+ #include "port.h"
++#include "serdes.h"
+ 
+ int mv88e6xxx_port_read(struct mv88e6xxx_chip *chip, int port, int reg,
+ 			u16 *val)
+@@ -371,6 +372,10 @@ int mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
+ 		cmode = 0;
+ 	}
+ 
++	err = mv88e6390_serdes_power(chip, port, false);
++	if (err)
++		return err;
++
+ 	if (cmode) {
+ 		err = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_STS, &reg);
+ 		if (err)
+@@ -382,6 +387,10 @@ int mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
+ 		err = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_STS, reg);
+ 		if (err)
+ 			return err;
++
++		err = mv88e6390_serdes_power(chip, port, true);
++		if (err)
++			return err;
+ 	}
+ 
+ 	chip->ports[port].cmode = cmode;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90095-net-dsa-mv88e6xxx-link-mv88e6xxx_port-to-mv88e6xxx_c.patch b/target/linux/mvebu/patches-4.14/90095-net-dsa-mv88e6xxx-link-mv88e6xxx_port-to-mv88e6xxx_c.patch
new file mode 100644
index 0000000..c6cd7ff
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90095-net-dsa-mv88e6xxx-link-mv88e6xxx_port-to-mv88e6xxx_c.patch
@@ -0,0 +1,48 @@
+From cf237556ee1e91fe575767c6fa2342b323aa2af5 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:47 +0200
+Subject: [PATCH 095/126] net: dsa: mv88e6xxx: link mv88e6xxx_port to
+ mv88e6xxx_chip
+
+An up coming change will register interrupts for individual switch
+ports, using the mv88e6xxx_port as the interrupt context information.
+Add members to the mv88e6xxx_port structure so we can link it back to
+the mv88e6xxx_chip member the port belongs to and the port number of
+the port.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 3 +++
+ drivers/net/dsa/mv88e6xxx/chip.h | 2 ++
+ 2 files changed, 5 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 9a4bec1627f1..80b22ecbf6f0 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -1897,6 +1897,9 @@ static int mv88e6xxx_setup_port(struct mv88e6xxx_chip *chip, int port)
+ 	int err;
+ 	u16 reg;
+ 
++	chip->ports[port].chip = chip;
++	chip->ports[port].port = port;
++
+ 	/* MAC Forcing register: don't force link, speed, duplex or flow control
+ 	 * state to any particular values on physical ports, but force the CPU
+ 	 * port and all DSA ports to their maximum bandwidth and full duplex.
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.h b/drivers/net/dsa/mv88e6xxx/chip.h
+index d1f706c27cec..0d93b21157d4 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.h
++++ b/drivers/net/dsa/mv88e6xxx/chip.h
+@@ -155,6 +155,8 @@ struct mv88e6xxx_irq {
+ };
+ 
+ struct mv88e6xxx_port {
++	struct mv88e6xxx_chip *chip;
++	int port;
+ 	u8 cmode;
+ };
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90096-net-dsa-mv88e6xxx-Add-SERDES-phydev_mac_change-up-fo.patch b/target/linux/mvebu/patches-4.14/90096-net-dsa-mv88e6xxx-Add-SERDES-phydev_mac_change-up-fo.patch
new file mode 100644
index 0000000..69d0663
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90096-net-dsa-mv88e6xxx-Add-SERDES-phydev_mac_change-up-fo.patch
@@ -0,0 +1,361 @@
+From bc17145f0452d8cdc9d234e5df932bc3fdc9cc8f Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:48 +0200
+Subject: [PATCH 096/126] net: dsa: mv88e6xxx: Add SERDES phydev_mac_change up
+ for 6390
+
+phylink wants to know when the MAC layers notices a change in the
+link. For the 6390 family, this is a change in the SERDES state.
+
+Add interrupt support for the SERDES interface used to implement
+SGMII/1000Base-X/2500Base-X. This is currently limited to ports 9 and
+10. Support for the 10G SERDES and other ports will be added later,
+building on this basic framework.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c   |  22 ++++
+ drivers/net/dsa/mv88e6xxx/chip.h   |   5 +
+ drivers/net/dsa/mv88e6xxx/serdes.c | 179 +++++++++++++++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/serdes.h |  17 +++
+ 4 files changed, 223 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 80b22ecbf6f0..78a436f0cb54 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -2065,7 +2065,12 @@ static int mv88e6xxx_port_enable(struct dsa_switch *ds, int port,
+ 	int err;
+ 
+ 	mutex_lock(&chip->reg_lock);
++
+ 	err = mv88e6xxx_serdes_power(chip, port, true);
++
++	if (!err && chip->info->ops->serdes_irq_setup)
++		err = chip->info->ops->serdes_irq_setup(chip, port);
++
+ 	mutex_unlock(&chip->reg_lock);
+ 
+ 	return err;
+@@ -2077,8 +2082,13 @@ static void mv88e6xxx_port_disable(struct dsa_switch *ds, int port,
+ 	struct mv88e6xxx_chip *chip = ds->priv;
+ 
+ 	mutex_lock(&chip->reg_lock);
++
++	if (chip->info->ops->serdes_irq_free)
++		chip->info->ops->serdes_irq_free(chip, port);
++
+ 	if (mv88e6xxx_serdes_power(chip, port, false))
+ 		dev_err(chip->dev, "failed to power off SERDES\n");
++
+ 	mutex_unlock(&chip->reg_lock);
+ }
+ 
+@@ -3039,6 +3049,8 @@ static const struct mv88e6xxx_ops mv88e6190_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390_serdes_power,
++	.serdes_irq_setup = mv88e6390_serdes_irq_setup,
++	.serdes_irq_free = mv88e6390_serdes_irq_free,
+ 	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+@@ -3078,6 +3090,8 @@ static const struct mv88e6xxx_ops mv88e6190x_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390x_serdes_power,
++	.serdes_irq_setup = mv88e6390_serdes_irq_setup,
++	.serdes_irq_free = mv88e6390_serdes_irq_free,
+ 	.phylink_validate = mv88e6390x_phylink_validate,
+ };
+ 
+@@ -3117,6 +3131,8 @@ static const struct mv88e6xxx_ops mv88e6191_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390_serdes_power,
++	.serdes_irq_setup = mv88e6390_serdes_irq_setup,
++	.serdes_irq_free = mv88e6390_serdes_irq_free,
+ 	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+@@ -3196,6 +3212,8 @@ static const struct mv88e6xxx_ops mv88e6290_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390_serdes_power,
++	.serdes_irq_setup = mv88e6390_serdes_irq_setup,
++	.serdes_irq_free = mv88e6390_serdes_irq_free,
+ 	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+@@ -3458,6 +3476,8 @@ static const struct mv88e6xxx_ops mv88e6390_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390_serdes_power,
++	.serdes_irq_setup = mv88e6390_serdes_irq_setup,
++	.serdes_irq_free = mv88e6390_serdes_irq_free,
+ 	.phylink_validate = mv88e6390_phylink_validate,
+ };
+ 
+@@ -3500,6 +3520,8 @@ static const struct mv88e6xxx_ops mv88e6390x_ops = {
+ 	.vtu_getnext = mv88e6390_g1_vtu_getnext,
+ 	.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,
+ 	.serdes_power = mv88e6390x_serdes_power,
++	.serdes_irq_setup = mv88e6390_serdes_irq_setup,
++	.serdes_irq_free = mv88e6390_serdes_irq_free,
+ 	.phylink_validate = mv88e6390x_phylink_validate,
+ };
+ 
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.h b/drivers/net/dsa/mv88e6xxx/chip.h
+index 0d93b21157d4..cf22ff447028 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.h
++++ b/drivers/net/dsa/mv88e6xxx/chip.h
+@@ -158,6 +158,7 @@ struct mv88e6xxx_port {
+ 	struct mv88e6xxx_chip *chip;
+ 	int port;
+ 	u8 cmode;
++	int serdes_irq;
+ };
+ 
+ struct mv88e6xxx_chip {
+@@ -362,6 +363,10 @@ struct mv88e6xxx_ops {
+ 	/* Power on/off a SERDES interface */
+ 	int (*serdes_power)(struct mv88e6xxx_chip *chip, int port, bool on);
+ 
++	/* SERDES interrupt handling */
++	int (*serdes_irq_setup)(struct mv88e6xxx_chip *chip, int port);
++	void (*serdes_irq_free)(struct mv88e6xxx_chip *chip, int port);
++
+ 	/* VLAN Translation Unit operations */
+ 	int (*vtu_getnext)(struct mv88e6xxx_chip *chip,
+ 			   struct mv88e6xxx_vtu_entry *entry);
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index 9469bb819a34..591557590dab 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -11,6 +11,8 @@
+  * (at your option) any later version.
+  */
+ 
++#include <linux/interrupt.h>
++#include <linux/irqdomain.h>
+ #include <linux/mii.h>
+ 
+ #include "chip.h"
+@@ -303,6 +305,183 @@ int mv88e6390x_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ 	return 0;
+ }
+ 
++static void mv88e6390_serdes_irq_link_sgmii(struct mv88e6xxx_chip *chip,
++					    int port, int lane)
++{
++	struct dsa_switch *ds = chip->ds;
++	u16 status;
++	bool up;
++
++	mv88e6390_serdes_read(chip, lane, MDIO_MMD_PHYXS,
++			      MV88E6390_SGMII_STATUS, &status);
++
++	/* Status must be read twice in order to give the current link
++	 * status. Otherwise the change in link status since the last
++	 * read of the register is returned.
++	 */
++	mv88e6390_serdes_read(chip, lane, MDIO_MMD_PHYXS,
++			      MV88E6390_SGMII_STATUS, &status);
++	up = status & MV88E6390_SGMII_STATUS_LINK;
++
++	dsa_port_phylink_mac_change(ds, port, up);
++}
++
++static int mv88e6390_serdes_irq_enable_sgmii(struct mv88e6xxx_chip *chip,
++					     int lane)
++{
++	return mv88e6390_serdes_write(chip, lane, MDIO_MMD_PHYXS,
++				      MV88E6390_SGMII_INT_ENABLE,
++				      MV88E6390_SGMII_INT_LINK_DOWN |
++				      MV88E6390_SGMII_INT_LINK_UP);
++}
++
++static int mv88e6390_serdes_irq_disable_sgmii(struct mv88e6xxx_chip *chip,
++					      int lane)
++{
++	return mv88e6390_serdes_write(chip, lane, MDIO_MMD_PHYXS,
++				      MV88E6390_SGMII_INT_ENABLE, 0);
++}
++
++int mv88e6390_serdes_irq_enable(struct mv88e6xxx_chip *chip, int port,
++				int lane)
++{
++	u8 cmode = chip->ports[port].cmode;
++	int err = 0;
++
++	switch (cmode) {
++	case MV88E6XXX_PORT_STS_CMODE_SGMII:
++	case MV88E6XXX_PORT_STS_CMODE_1000BASE_X:
++	case MV88E6XXX_PORT_STS_CMODE_2500BASEX:
++		err = mv88e6390_serdes_irq_enable_sgmii(chip, lane);
++	}
++
++	return err;
++}
++
++int mv88e6390_serdes_irq_disable(struct mv88e6xxx_chip *chip, int port,
++				 int lane)
++{
++	u8 cmode = chip->ports[port].cmode;
++	int err = 0;
++
++	switch (cmode) {
++	case MV88E6XXX_PORT_STS_CMODE_SGMII:
++	case MV88E6XXX_PORT_STS_CMODE_1000BASE_X:
++	case MV88E6XXX_PORT_STS_CMODE_2500BASEX:
++		err = mv88e6390_serdes_irq_disable_sgmii(chip, lane);
++	}
++
++	return err;
++}
++
++static int mv88e6390_serdes_irq_status_sgmii(struct mv88e6xxx_chip *chip,
++					     int lane, u16 *status)
++{
++	int err;
++
++	err = mv88e6390_serdes_read(chip, lane, MDIO_MMD_PHYXS,
++				    MV88E6390_SGMII_INT_STATUS, status);
++
++	return err;
++}
++
++static irqreturn_t mv88e6390_serdes_thread_fn(int irq, void *dev_id)
++{
++	struct mv88e6xxx_port *port = dev_id;
++	struct mv88e6xxx_chip *chip = port->chip;
++	irqreturn_t ret = IRQ_NONE;
++	u8 cmode = port->cmode;
++	u16 status;
++	int lane;
++	int err;
++
++	lane = mv88e6390x_serdes_get_lane(chip, port->port);
++
++	mutex_lock(&chip->reg_lock);
++
++	switch (cmode) {
++	case MV88E6XXX_PORT_STS_CMODE_SGMII:
++	case MV88E6XXX_PORT_STS_CMODE_1000BASE_X:
++	case MV88E6XXX_PORT_STS_CMODE_2500BASEX:
++		err = mv88e6390_serdes_irq_status_sgmii(chip, lane, &status);
++		if (err)
++			goto out;
++		if (status && (MV88E6390_SGMII_INT_LINK_DOWN ||
++			       MV88E6390_SGMII_INT_LINK_UP)) {
++			ret = IRQ_HANDLED;
++			mv88e6390_serdes_irq_link_sgmii(chip, port->port, lane);
++		}
++	}
++out:
++	mutex_unlock(&chip->reg_lock);
++
++	return ret;
++}
++
++int mv88e6390_serdes_irq_setup(struct mv88e6xxx_chip *chip, int port)
++{
++	int lane;
++	int err;
++
++	/* Only support ports 9 and 10 at the moment */
++	if (port < 9)
++		return 0;
++
++	lane = mv88e6390x_serdes_get_lane(chip, port);
++
++	if (lane == -ENODEV)
++		return 0;
++
++	if (lane < 0)
++		return lane;
++
++	chip->ports[port].serdes_irq = irq_find_mapping(chip->g2_irq.domain,
++							port);
++	if (chip->ports[port].serdes_irq < 0) {
++		dev_err(chip->dev, "Unable to map SERDES irq: %d\n",
++			chip->ports[port].serdes_irq);
++		return chip->ports[port].serdes_irq;
++	}
++
++	/* Requesting the IRQ will trigger irq callbacks. So we cannot
++	 * hold the reg_lock.
++	 */
++	mutex_unlock(&chip->reg_lock);
++	err = request_threaded_irq(chip->ports[port].serdes_irq, NULL,
++				   mv88e6390_serdes_thread_fn,
++				   IRQF_ONESHOT, "mv88e6xxx-serdes",
++				   &chip->ports[port]);
++	mutex_lock(&chip->reg_lock);
++
++	if (err) {
++		dev_err(chip->dev, "Unable to request SERDES interrupt: %d\n",
++			err);
++		return err;
++	}
++
++	return mv88e6390_serdes_irq_enable(chip, port, lane);
++}
++
++void mv88e6390_serdes_irq_free(struct mv88e6xxx_chip *chip, int port)
++{
++	int lane = mv88e6390x_serdes_get_lane(chip, port);
++
++	if (port < 9)
++		return;
++
++	if (lane < 0)
++		return;
++
++	mv88e6390_serdes_irq_disable(chip, port, lane);
++
++	/* Freeing the IRQ will trigger irq callbacks. So we cannot
++	 * hold the reg_lock.
++	 */
++	mutex_unlock(&chip->reg_lock);
++	free_irq(chip->ports[port].serdes_irq, &chip->ports[port]);
++	mutex_lock(&chip->reg_lock);
++}
++
+ int mv88e6341_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+ {
+ 	u8 cmode = chip->ports[port].cmode;
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.h b/drivers/net/dsa/mv88e6xxx/serdes.h
+index aa156d2a4004..10441f019945 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.h
++++ b/drivers/net/dsa/mv88e6xxx/serdes.h
+@@ -43,9 +43,26 @@
+ #define MV88E6390_SGMII_CONTROL_LOOPBACK	BIT(14)
+ #define MV88E6390_SGMII_CONTROL_PDOWN		BIT(11)
+ 
++#define MV88E6390_SGMII_STATUS		0x2001
++#define MV88E6390_SGMII_STATUS_AN_DONE		BIT(5)
++#define MV88E6390_SGMII_STATUS_REMOTE_FAULT	BIT(4)
++#define MV88E6390_SGMII_STATUS_LINK		BIT(2)
++#define MV88E6390_SGMII_INT_ENABLE	0xa001
++#define MV88E6390_SGMII_INT_SPEED_CHANGE	BIT(14)
++#define MV88E6390_SGMII_INT_DUPLEX_CHANGE	BIT(13)
++#define MV88E6390_SGMII_INT_PAGE_RX		BIT(12)
++#define MV88E6390_SGMII_INT_AN_COMPLETE		BIT(11)
++#define MV88E6390_SGMII_INT_LINK_DOWN		BIT(10)
++#define MV88E6390_SGMII_INT_LINK_UP		BIT(9)
++#define MV88E6390_SGMII_INT_SYMBOL_ERROR	BIT(8)
++#define MV88E6390_SGMII_INT_FALSE_CARRIER	BIT(7)
++#define MV88E6390_SGMII_INT_STATUS	0xa002
++
+ int mv88e6341_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6352_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6390_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6390x_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
++int mv88e6390_serdes_irq_setup(struct mv88e6xxx_chip *chip, int port);
++void mv88e6390_serdes_irq_free(struct mv88e6xxx_chip *chip, int port);
+ 
+ #endif
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90097-net-dsa-mv88e6xxx-Re-setup-interrupts-on-CMODE-chang.patch b/target/linux/mvebu/patches-4.14/90097-net-dsa-mv88e6xxx-Re-setup-interrupts-on-CMODE-chang.patch
new file mode 100644
index 0000000..ef80f7f
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90097-net-dsa-mv88e6xxx-Re-setup-interrupts-on-CMODE-chang.patch
@@ -0,0 +1,108 @@
+From 1a33f37354b514c5a3642492474ad37ac2e0af52 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 9 Aug 2018 15:38:49 +0200
+Subject: [PATCH 097/126] net: dsa: mv88e6xxx: Re-setup interrupts on CMODE
+ change.
+
+When a port changes CMODE, the SERDES interface being used can change.
+Disable interrupts for the old SERDES interface, and enable interrupts
+on the new.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+---
+ drivers/net/dsa/mv88e6xxx/port.c   | 19 ++++++++++++++++++-
+ drivers/net/dsa/mv88e6xxx/serdes.c |  4 +++-
+ drivers/net/dsa/mv88e6xxx/serdes.h |  5 +++++
+ 3 files changed, 26 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/port.c b/drivers/net/dsa/mv88e6xxx/port.c
+index 20162add36be..78c9e6c50ab0 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.c
++++ b/drivers/net/dsa/mv88e6xxx/port.c
+@@ -342,8 +342,9 @@ int mv88e6390x_port_set_speed(struct mv88e6xxx_chip *chip, int port, int speed)
+ int mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
+ 			      phy_interface_t mode)
+ {
+-	u16 reg;
++	int lane;
+ 	u16 cmode;
++	u16 reg;
+ 	int err;
+ 
+ 	if (mode == PHY_INTERFACE_MODE_NA)
+@@ -372,6 +373,16 @@ int mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
+ 		cmode = 0;
+ 	}
+ 
++	lane = mv88e6390x_serdes_get_lane(chip, port);
++	if (lane < 0)
++		return lane;
++
++	if (chip->ports[port].serdes_irq) {
++		err = mv88e6390_serdes_irq_disable(chip, port, lane);
++		if (err)
++			return err;
++	}
++
+ 	err = mv88e6390_serdes_power(chip, port, false);
+ 	if (err)
+ 		return err;
+@@ -391,6 +402,12 @@ int mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,
+ 		err = mv88e6390_serdes_power(chip, port, true);
+ 		if (err)
+ 			return err;
++
++		if (chip->ports[port].serdes_irq) {
++			err = mv88e6390_serdes_irq_enable(chip, port, lane);
++			if (err)
++				return err;
++		}
+ 	}
+ 
+ 	chip->ports[port].cmode = cmode;
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.c b/drivers/net/dsa/mv88e6xxx/serdes.c
+index 591557590dab..ec788cce3e25 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.c
++++ b/drivers/net/dsa/mv88e6xxx/serdes.c
+@@ -118,7 +118,7 @@ static int mv88e6390_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
+  * use multiple lanes. If so, return the first lane the port uses.
+  * Returns -ENODEV if a port does not have a lane.
+  */
+-static int mv88e6390x_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
++int mv88e6390x_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)
+ {
+ 	u8 cmode_port9, cmode_port10, cmode_port;
+ 
+@@ -480,6 +480,8 @@ void mv88e6390_serdes_irq_free(struct mv88e6xxx_chip *chip, int port)
+ 	mutex_unlock(&chip->reg_lock);
+ 	free_irq(chip->ports[port].serdes_irq, &chip->ports[port]);
+ 	mutex_lock(&chip->reg_lock);
++
++	chip->ports[port].serdes_irq = 0;
+ }
+ 
+ int mv88e6341_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on)
+diff --git a/drivers/net/dsa/mv88e6xxx/serdes.h b/drivers/net/dsa/mv88e6xxx/serdes.h
+index 10441f019945..6b41f914d156 100644
+--- a/drivers/net/dsa/mv88e6xxx/serdes.h
++++ b/drivers/net/dsa/mv88e6xxx/serdes.h
+@@ -58,11 +58,16 @@
+ #define MV88E6390_SGMII_INT_FALSE_CARRIER	BIT(7)
+ #define MV88E6390_SGMII_INT_STATUS	0xa002
+ 
++int mv88e6390x_serdes_get_lane(struct mv88e6xxx_chip *chip, int port);
+ int mv88e6341_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6352_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6390_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6390x_serdes_power(struct mv88e6xxx_chip *chip, int port, bool on);
+ int mv88e6390_serdes_irq_setup(struct mv88e6xxx_chip *chip, int port);
+ void mv88e6390_serdes_irq_free(struct mv88e6xxx_chip *chip, int port);
++int mv88e6390_serdes_irq_enable(struct mv88e6xxx_chip *chip, int port,
++				int lane);
++int mv88e6390_serdes_irq_disable(struct mv88e6xxx_chip *chip, int port,
++				 int lane);
+ 
+ #endif
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90098-net-dsa-mv88e6xxx-Poll-when-no-interrupt-defined.patch b/target/linux/mvebu/patches-4.14/90098-net-dsa-mv88e6xxx-Poll-when-no-interrupt-defined.patch
new file mode 100644
index 0000000..1fa9e00
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90098-net-dsa-mv88e6xxx-Poll-when-no-interrupt-defined.patch
@@ -0,0 +1,249 @@
+From dbf391453f922c1fba9f1cbefe72f1a334c7825e Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 22 Feb 2018 22:58:32 +0100
+Subject: [PATCH 098/126] net: dsa: mv88e6xxx: Poll when no interrupt defined
+
+Not all boards have the interrupt output from the switch connected to
+a GPIO line. In such cases, phylib has to poll the internal PHYs,
+rather than receive an interrupt when there is a change in the link
+state. phylib polls once per second, and per PHY reads around 4
+words. With a switch typically having 4 internal PHYs, this means 16
+MDIO transactions per second.
+
+Rather than performing this phylib level polling, have the driver poll
+the interrupt status register. If the status register indicates an
+interrupt condition processing of interrupts in the same way as if a
+GPIO was used.
+
+Polling 10 times a second places less load on the MDIO bus. But rather
+than taking on average 0.5s to detect a link change, it takes less
+than 0.05s. Additionally, other interrupts, such as the watchdog, ATU
+and VTU violations will be reported.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 124 +++++++++++++++++++++++--------
+ drivers/net/dsa/mv88e6xxx/chip.h |   3 +
+ 2 files changed, 96 insertions(+), 31 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 78a436f0cb54..0bf5de536880 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -252,9 +252,8 @@ static void mv88e6xxx_g1_irq_unmask(struct irq_data *d)
+ 	chip->g1_irq.masked &= ~(1 << n);
+ }
+ 
+-static irqreturn_t mv88e6xxx_g1_irq_thread_fn(int irq, void *dev_id)
++static irqreturn_t mv88e6xxx_g1_irq_thread_work(struct mv88e6xxx_chip *chip)
+ {
+-	struct mv88e6xxx_chip *chip = dev_id;
+ 	unsigned int nhandled = 0;
+ 	unsigned int sub_irq;
+ 	unsigned int n;
+@@ -295,6 +294,13 @@ static irqreturn_t mv88e6xxx_g1_irq_thread_fn(int irq, void *dev_id)
+ 	return (nhandled > 0 ? IRQ_HANDLED : IRQ_NONE);
+ }
+ 
++static irqreturn_t mv88e6xxx_g1_irq_thread_fn(int irq, void *dev_id)
++{
++	struct mv88e6xxx_chip *chip = dev_id;
++
++	return mv88e6xxx_g1_irq_thread_work(chip);
++}
++
+ static void mv88e6xxx_g1_irq_bus_lock(struct irq_data *d)
+ {
+ 	struct mv88e6xxx_chip *chip = irq_data_get_irq_chip_data(d);
+@@ -350,7 +356,7 @@ static const struct irq_domain_ops mv88e6xxx_g1_irq_domain_ops = {
+ 	.xlate	= irq_domain_xlate_twocell,
+ };
+ 
+-static void mv88e6xxx_g1_irq_free(struct mv88e6xxx_chip *chip)
++static void mv88e6xxx_g1_irq_free_common(struct mv88e6xxx_chip *chip)
+ {
+ 	int irq, virq;
+ 	u16 mask;
+@@ -359,8 +365,6 @@ static void mv88e6xxx_g1_irq_free(struct mv88e6xxx_chip *chip)
+ 	mask &= ~GENMASK(chip->g1_irq.nirqs, 0);
+ 	mv88e6xxx_g1_write(chip, MV88E6XXX_G1_CTL1, mask);
+ 
+-	free_irq(chip->irq, chip);
+-
+ 	for (irq = 0; irq < chip->g1_irq.nirqs; irq++) {
+ 		virq = irq_find_mapping(chip->g1_irq.domain, irq);
+ 		irq_dispose_mapping(virq);
+@@ -369,7 +373,14 @@ static void mv88e6xxx_g1_irq_free(struct mv88e6xxx_chip *chip)
+ 	irq_domain_remove(chip->g1_irq.domain);
+ }
+ 
+-static int mv88e6xxx_g1_irq_setup(struct mv88e6xxx_chip *chip)
++static void mv88e6xxx_g1_irq_free(struct mv88e6xxx_chip *chip)
++{
++	mv88e6xxx_g1_irq_free(chip);
++
++	free_irq(chip->irq, chip);
++}
++
++static int mv88e6xxx_g1_irq_setup_common(struct mv88e6xxx_chip *chip)
+ {
+ 	int err, irq, virq;
+ 	u16 reg, mask;
+@@ -402,13 +413,6 @@ static int mv88e6xxx_g1_irq_setup(struct mv88e6xxx_chip *chip)
+ 	if (err)
+ 		goto out_disable;
+ 
+-	err = request_threaded_irq(chip->irq, NULL,
+-				   mv88e6xxx_g1_irq_thread_fn,
+-				   IRQF_ONESHOT | IRQF_TRIGGER_FALLING,
+-				   dev_name(chip->dev), chip);
+-	if (err)
+-		goto out_disable;
+-
+ 	return 0;
+ 
+ out_disable:
+@@ -426,6 +430,62 @@ static int mv88e6xxx_g1_irq_setup(struct mv88e6xxx_chip *chip)
+ 	return err;
+ }
+ 
++static int mv88e6xxx_g1_irq_setup(struct mv88e6xxx_chip *chip)
++{
++	int err;
++
++	err = mv88e6xxx_g1_irq_setup_common(chip);
++	if (err)
++		return err;
++
++	err = request_threaded_irq(chip->irq, NULL,
++				   mv88e6xxx_g1_irq_thread_fn,
++				   IRQF_ONESHOT | IRQF_TRIGGER_FALLING,
++				   dev_name(chip->dev), chip);
++	if (err)
++		mv88e6xxx_g1_irq_free_common(chip);
++
++	return err;
++}
++
++static void mv88e6xxx_irq_poll(struct kthread_work *work)
++{
++	struct mv88e6xxx_chip *chip = container_of(work,
++						   struct mv88e6xxx_chip,
++						   irq_poll_work.work);
++	mv88e6xxx_g1_irq_thread_work(chip);
++
++	kthread_queue_delayed_work(chip->kworker, &chip->irq_poll_work,
++				   msecs_to_jiffies(100));
++}
++
++static int mv88e6xxx_irq_poll_setup(struct mv88e6xxx_chip *chip)
++{
++	int err;
++
++	err = mv88e6xxx_g1_irq_setup_common(chip);
++	if (err)
++		return err;
++
++	kthread_init_delayed_work(&chip->irq_poll_work,
++				  mv88e6xxx_irq_poll);
++
++	chip->kworker = kthread_create_worker(0, dev_name(chip->dev));
++	if (IS_ERR(chip->kworker))
++		return PTR_ERR(chip->kworker);
++
++	kthread_queue_delayed_work(chip->kworker, &chip->irq_poll_work,
++				   msecs_to_jiffies(100));
++
++	return 0;
++}
++
++static void mv88e6xxx_irq_poll_free(struct mv88e6xxx_chip *chip)
++{
++	kthread_cancel_delayed_work_sync(&chip->irq_poll_work);
++	kthread_destroy_worker(chip->kworker);
++}
++
+ int mv88e6xxx_wait(struct mv88e6xxx_chip *chip, int addr, int reg, u16 mask)
+ {
+ 	int i;
+@@ -4323,23 +4383,24 @@ static int mv88e6xxx_probe(struct mdio_device *mdiodev)
+ 		goto out;
+ 	}
+ 
+-	if (chip->irq > 0) {
+-		/* Has to be performed before the MDIO bus is created,
+-		 * because the PHYs will link there interrupts to these
+-		 * interrupt controllers
+-		 */
+-		mutex_lock(&chip->reg_lock);
++	/* Has to be performed before the MDIO bus is created,
++	 * because the PHYs will link there interrupts to these
++	 * interrupt controllers
++	 */
++	mutex_lock(&chip->reg_lock);
++	if (chip->irq > 0)
+ 		err = mv88e6xxx_g1_irq_setup(chip);
+-		mutex_unlock(&chip->reg_lock);
++	else
++		err = mv88e6xxx_irq_poll_setup(chip);
++	mutex_unlock(&chip->reg_lock);
+ 
+-		if (err)
+-			goto out;
++	if (err)
++		goto out;
+ 
+-		if (chip->info->g2_irqs > 0) {
+-			err = mv88e6xxx_g2_irq_setup(chip);
+-			if (err)
+-				goto out_g1_irq;
+-		}
++	if (chip->info->g2_irqs > 0) {
++		err = mv88e6xxx_g2_irq_setup(chip);
++		if (err)
++			goto out_g1_irq;
+ 	}
+ 
+ 	err = mv88e6xxx_mdios_register(chip, np);
+@@ -4358,11 +4419,12 @@ static int mv88e6xxx_probe(struct mdio_device *mdiodev)
+ 	if (chip->info->g2_irqs > 0 && chip->irq > 0)
+ 		mv88e6xxx_g2_irq_free(chip);
+ out_g1_irq:
+-	if (chip->irq > 0) {
+-		mutex_lock(&chip->reg_lock);
++	mutex_lock(&chip->reg_lock);
++	if (chip->irq > 0)
+ 		mv88e6xxx_g1_irq_free(chip);
+-		mutex_unlock(&chip->reg_lock);
+-	}
++	else
++		mv88e6xxx_irq_poll_free(chip);
++	mutex_unlock(&chip->reg_lock);
+ out:
+ 	return err;
+ }
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.h b/drivers/net/dsa/mv88e6xxx/chip.h
+index cf22ff447028..c666089af5db 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.h
++++ b/drivers/net/dsa/mv88e6xxx/chip.h
+@@ -15,6 +15,7 @@
+ #include <linux/if_vlan.h>
+ #include <linux/irq.h>
+ #include <linux/gpio/consumer.h>
++#include <linux/kthread.h>
+ #include <linux/phy.h>
+ #include <net/dsa.h>
+ 
+@@ -214,6 +215,8 @@ struct mv88e6xxx_chip {
+ 	int irq;
+ 	int device_irq;
+ 	int watchdog_irq;
++	struct kthread_worker *kworker;
++	struct kthread_delayed_work irq_poll_work;
+ 
+ 	/* Array of port structures. */
+ 	struct mv88e6xxx_port ports[DSA_MAX_PORTS];
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90099-net-dsa-mv88e6xxx-Add-missing-g1-IRQ-numbers.patch b/target/linux/mvebu/patches-4.14/90099-net-dsa-mv88e6xxx-Add-missing-g1-IRQ-numbers.patch
new file mode 100644
index 0000000..2e54ea3
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90099-net-dsa-mv88e6xxx-Add-missing-g1-IRQ-numbers.patch
@@ -0,0 +1,41 @@
+From d0bda55c7cc657e8f556bd3eacd304a1ebc54873 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Sat, 17 Mar 2018 20:32:03 +0100
+Subject: [PATCH 099/126] net: dsa: mv88e6xxx: Add missing g1 IRQ numbers
+
+With the recent change to polling for interrupts, it is important that
+the number of global 1 interrupts is listed. Without it, the driver
+requests an interrupt domain for zero interrupts, which returns
+EINVAL, and the probe fails.
+
+Add two missing entries.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 0bf5de536880..6136be3bb58c 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -3694,6 +3694,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 3750,
+ 		.atu_move_port_mask = 0x1f,
++		.g1_irqs = 9,
+ 		.g2_irqs = 10,
+ 		.pvt = true,
+ 		.multi_chip = true,
+@@ -3988,6 +3989,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 3750,
+ 		.atu_move_port_mask = 0x1f,
++		.g1_irqs = 9,
+ 		.g2_irqs = 10,
+ 		.pvt = true,
+ 		.multi_chip = true,
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90100-net-dsa-mv88e6xxx-Add-number-of-internal-PHYs.patch b/target/linux/mvebu/patches-4.14/90100-net-dsa-mv88e6xxx-Add-number-of-internal-PHYs.patch
new file mode 100644
index 0000000..eec016b
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90100-net-dsa-mv88e6xxx-Add-number-of-internal-PHYs.patch
@@ -0,0 +1,257 @@
+From fad30d16054828f200bcacc71ef10f7c907e8c2f Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Sat, 17 Mar 2018 20:32:04 +0100
+Subject: [PATCH 100/126] net: dsa: mv88e6xxx: Add number of internal PHYs
+
+Add to the info structure the number of internal PHYs, if they generate
+interrupts. Some of the older generations of switches have internal
+PHYs, but no interrupt registers. In this case, set the count to zero.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 28 ++++++++++++++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/chip.h |  1 +
+ 2 files changed, 29 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 6136be3bb58c..40d33a24875f 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -3592,6 +3592,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6085",
+ 		.num_databases = 4096,
+ 		.num_ports = 10,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3612,6 +3613,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6095/88E6095F",
+ 		.num_databases = 256,
+ 		.num_ports = 11,
++		.num_internal_phys = 0,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3630,6 +3632,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6097/88E6097F",
+ 		.num_databases = 4096,
+ 		.num_ports = 11,
++		.num_internal_phys = 8,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3650,6 +3653,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6123",
+ 		.num_databases = 4096,
+ 		.num_ports = 3,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3670,6 +3674,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6131",
+ 		.num_databases = 256,
+ 		.num_ports = 8,
++		.num_internal_phys = 0,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3688,6 +3693,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6141",
+ 		.num_databases = 4096,
+ 		.num_ports = 6,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3708,6 +3714,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6161",
+ 		.num_databases = 4096,
+ 		.num_ports = 6,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3728,6 +3735,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6165",
+ 		.num_databases = 4096,
+ 		.num_ports = 6,
++		.num_internal_phys = 0,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3748,6 +3756,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6171",
+ 		.num_databases = 4096,
+ 		.num_ports = 7,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3768,6 +3777,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6172",
+ 		.num_databases = 4096,
+ 		.num_ports = 7,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3788,6 +3798,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6175",
+ 		.num_databases = 4096,
+ 		.num_ports = 7,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3808,6 +3819,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6176",
+ 		.num_databases = 4096,
+ 		.num_ports = 7,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3828,6 +3840,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6185",
+ 		.num_databases = 256,
+ 		.num_ports = 10,
++		.num_internal_phys = 0,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3846,6 +3859,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6190",
+ 		.num_databases = 4096,
+ 		.num_ports = 11,	/* 10 + Z80 */
++		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+@@ -3866,6 +3880,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6190X",
+ 		.num_databases = 4096,
+ 		.num_ports = 11,	/* 10 + Z80 */
++		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+@@ -3886,6 +3901,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6191",
+ 		.num_databases = 4096,
+ 		.num_ports = 11,	/* 10 + Z80 */
++		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+@@ -3906,6 +3922,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6240",
+ 		.num_databases = 4096,
+ 		.num_ports = 7,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -3926,6 +3943,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6290",
+ 		.num_databases = 4096,
+ 		.num_ports = 11,	/* 10 + Z80 */
++		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+@@ -3946,12 +3964,14 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6320",
+ 		.num_databases = 4096,
+ 		.num_ports = 7,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+ 		.g1_irqs = 8,
++		.g2_irqs = 10,
+ 		.atu_move_port_mask = 0xf,
+ 		.pvt = true,
+ 		.multi_chip = true,
+@@ -3965,12 +3985,14 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6321",
+ 		.num_databases = 4096,
+ 		.num_ports = 7,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+ 		.g1_irqs = 8,
++		.g2_irqs = 10,
+ 		.atu_move_port_mask = 0xf,
+ 		.multi_chip = true,
+ 		.tag_protocol = DSA_TAG_PROTO_EDSA,
+@@ -3983,6 +4005,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6341",
+ 		.num_databases = 4096,
+ 		.num_ports = 6,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -4003,6 +4026,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6350",
+ 		.num_databases = 4096,
+ 		.num_ports = 7,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -4023,6 +4047,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6351",
+ 		.num_databases = 4096,
+ 		.num_ports = 7,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -4043,6 +4068,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6352",
+ 		.num_databases = 4096,
+ 		.num_ports = 7,
++		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+@@ -4062,6 +4088,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6390",
+ 		.num_databases = 4096,
+ 		.num_ports = 11,	/* 10 + Z80 */
++		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+@@ -4081,6 +4108,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.name = "Marvell 88E6390X",
+ 		.num_databases = 4096,
+ 		.num_ports = 11,	/* 10 + Z80 */
++		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.h b/drivers/net/dsa/mv88e6xxx/chip.h
+index c666089af5db..c3ea525a3b19 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.h
++++ b/drivers/net/dsa/mv88e6xxx/chip.h
+@@ -106,6 +106,7 @@ struct mv88e6xxx_info {
+ 	const char *name;
+ 	unsigned int num_databases;
+ 	unsigned int num_ports;
++	unsigned int num_internal_phys;
+ 	unsigned int max_vid;
+ 	unsigned int port_base_addr;
+ 	unsigned int global1_addr;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90101-net-dsa-mv88e6xxx-Add-MDIO-interrupts-for-internal-P.patch b/target/linux/mvebu/patches-4.14/90101-net-dsa-mv88e6xxx-Add-MDIO-interrupts-for-internal-P.patch
new file mode 100644
index 0000000..b2d94ec
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90101-net-dsa-mv88e6xxx-Add-MDIO-interrupts-for-internal-P.patch
@@ -0,0 +1,135 @@
+From 2399e39cdbc22cbf937307288f3a580767518bf2 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Sat, 17 Mar 2018 20:32:05 +0100
+Subject: [PATCH 101/126] net: dsa: mv88e6xxx: Add MDIO interrupts for internal
+ PHYs
+
+When registering an MDIO bus, it is possible to pass an array of
+interrupts, one per address on the bus. phylib will then associate the
+interrupt to the PHY device, if no other interrupt is provided.
+
+Some of the global2 interrupts are PHY interrupts. Place them into the
+MDIO bus structure.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c    | 10 +++++++++
+ drivers/net/dsa/mv88e6xxx/global2.c | 32 +++++++++++++++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/global2.h | 16 +++++++++++++++
+ 3 files changed, 58 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 40d33a24875f..9f60e8fa8783 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -2511,12 +2511,19 @@ static int mv88e6xxx_mdio_register(struct mv88e6xxx_chip *chip,
+ 	bus->write = mv88e6xxx_mdio_write;
+ 	bus->parent = chip->dev;
+ 
++	if (!external) {
++		err = mv88e6xxx_g2_irq_mdio_setup(chip, bus);
++		if (err)
++			return err;
++	}
++
+ 	if (np)
+ 		err = of_mdiobus_register(bus, np);
+ 	else
+ 		err = mdiobus_register(bus);
+ 	if (err) {
+ 		dev_err(chip->dev, "Cannot register MDIO bus (%d)\n", err);
++		mv88e6xxx_g2_irq_mdio_free(chip, bus);
+ 		return err;
+ 	}
+ 
+@@ -2543,6 +2550,9 @@ static void mv88e6xxx_mdios_unregister(struct mv88e6xxx_chip *chip)
+ 	list_for_each_entry(mdio_bus, &chip->mdios, list) {
+ 		bus = mdio_bus->bus;
+ 
++		if (!mdio_bus->external)
++			mv88e6xxx_g2_irq_mdio_free(chip, bus);
++
+ 		mdiobus_unregister(bus);
+ 	}
+ }
+diff --git a/drivers/net/dsa/mv88e6xxx/global2.c b/drivers/net/dsa/mv88e6xxx/global2.c
+index af0727877825..84dbcfb07f4f 100644
+--- a/drivers/net/dsa/mv88e6xxx/global2.c
++++ b/drivers/net/dsa/mv88e6xxx/global2.c
+@@ -1106,6 +1106,38 @@ int mv88e6xxx_g2_irq_setup(struct mv88e6xxx_chip *chip)
+ 	return err;
+ }
+ 
++int mv88e6xxx_g2_irq_mdio_setup(struct mv88e6xxx_chip *chip,
++				struct mii_bus *bus)
++{
++	int phy, irq, err, err_phy;
++
++	for (phy = 0; phy < chip->info->num_internal_phys; phy++) {
++		irq = irq_find_mapping(chip->g2_irq.domain, phy);
++		if (irq < 0) {
++			err = irq;
++			goto out;
++		}
++		bus->irq[chip->info->port_base_addr + phy] = irq;
++	}
++	return 0;
++out:
++	err_phy = phy;
++
++	for (phy = 0; phy < err_phy; phy++)
++		irq_dispose_mapping(bus->irq[phy]);
++
++	return err;
++}
++
++void mv88e6xxx_g2_irq_mdio_free(struct mv88e6xxx_chip *chip,
++				struct mii_bus *bus)
++{
++	int phy;
++
++	for (phy = 0; phy < chip->info->num_internal_phys; phy++)
++		irq_dispose_mapping(bus->irq[phy]);
++}
++
+ int mv88e6xxx_g2_setup(struct mv88e6xxx_chip *chip)
+ {
+ 	u16 reg;
+diff --git a/drivers/net/dsa/mv88e6xxx/global2.h b/drivers/net/dsa/mv88e6xxx/global2.h
+index 669f59017b12..0835cda2bba6 100644
+--- a/drivers/net/dsa/mv88e6xxx/global2.h
++++ b/drivers/net/dsa/mv88e6xxx/global2.h
+@@ -259,6 +259,11 @@ int mv88e6xxx_g2_setup(struct mv88e6xxx_chip *chip);
+ int mv88e6xxx_g2_irq_setup(struct mv88e6xxx_chip *chip);
+ void mv88e6xxx_g2_irq_free(struct mv88e6xxx_chip *chip);
+ 
++int mv88e6xxx_g2_irq_mdio_setup(struct mv88e6xxx_chip *chip,
++				struct mii_bus *bus);
++void mv88e6xxx_g2_irq_mdio_free(struct mv88e6xxx_chip *chip,
++				struct mii_bus *bus);
++
+ int mv88e6185_g2_mgmt_rsvd2cpu(struct mv88e6xxx_chip *chip);
+ int mv88e6352_g2_mgmt_rsvd2cpu(struct mv88e6xxx_chip *chip);
+ 
+@@ -364,6 +369,17 @@ static inline void mv88e6xxx_g2_irq_free(struct mv88e6xxx_chip *chip)
+ {
+ }
+ 
++static inline int mv88e6xxx_g2_irq_mdio_setup(struct mv88e6xxx_chip *chip,
++					      struct mii_bus *bus)
++{
++	return 0;
++}
++
++static inline void mv88e6xxx_g2_irq_mdio_free(struct mv88e6xxx_chip *chip,
++					      struct mii_bus *bus)
++{
++}
++
+ static inline int mv88e6185_g2_mgmt_rsvd2cpu(struct mv88e6xxx_chip *chip)
+ {
+ 	return -EOPNOTSUPP;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90102-net-dsa-mv88e6xxx-Fix-PHY-interrupts-by-parameterisi.patch b/target/linux/mvebu/patches-4.14/90102-net-dsa-mv88e6xxx-Fix-PHY-interrupts-by-parameterisi.patch
new file mode 100644
index 0000000..f969983
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90102-net-dsa-mv88e6xxx-Fix-PHY-interrupts-by-parameterisi.patch
@@ -0,0 +1,263 @@
+From d918fd360d2907e81bd096f4ec3c357c6509ed60 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Sat, 5 May 2018 20:58:22 +0200
+Subject: [PATCH 102/126] net: dsa: mv88e6xxx: Fix PHY interrupts by
+ parameterising PHY base address
+
+Most of the mv88e6xxx switches have the PHYs at address 0, 1, 2, ...
+The 6341 however has the PHYs at 0x10, 0x11, 0x12. Add a parameter to
+the info structure for this base address.
+
+Testing of 6f88284f3bd7 ("net: dsa: mv88e6xxx: Add MDIO interrupts for
+internal PHYs") was performed on the 6341. So it works only on the
+6341. Use this base information to correctly set the interrupt.
+
+Fixes: 6f88284f3bd7 ("net: dsa: mv88e6xxx: Add MDIO interrupts for internal PHYs")
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c    | 26 ++++++++++++++++++++++++++
+ drivers/net/dsa/mv88e6xxx/chip.h    |  1 +
+ drivers/net/dsa/mv88e6xxx/global2.c |  2 +-
+ 3 files changed, 28 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 9f60e8fa8783..93f2697efc65 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -3605,6 +3605,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3626,6 +3627,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 0,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3645,6 +3647,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 8,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3666,6 +3669,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3687,6 +3691,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 0,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3706,6 +3711,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 3750,
+@@ -3727,6 +3733,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3748,6 +3755,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 0,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3769,6 +3777,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3790,6 +3799,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3811,6 +3821,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3832,6 +3843,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3853,6 +3865,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 0,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3872,6 +3885,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.tag_protocol = DSA_TAG_PROTO_DSA,
+@@ -3893,6 +3907,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 3750,
+@@ -3914,6 +3929,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 3750,
+@@ -3935,6 +3951,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3956,6 +3973,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 3750,
+@@ -3977,6 +3995,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -3998,6 +4017,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -4018,6 +4038,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x10,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 3750,
+@@ -4039,6 +4060,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -4060,6 +4082,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -4081,6 +4104,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 5,
+ 		.max_vid = 4095,
+ 		.port_base_addr = 0x10,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 15000,
+@@ -4101,6 +4125,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 3750,
+@@ -4121,6 +4146,7 @@ static const struct mv88e6xxx_info mv88e6xxx_table[] = {
+ 		.num_internal_phys = 11,
+ 		.max_vid = 8191,
+ 		.port_base_addr = 0x0,
++		.phy_base_addr = 0x0,
+ 		.global1_addr = 0x1b,
+ 		.global2_addr = 0x1c,
+ 		.age_time_coeff = 3750,
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.h b/drivers/net/dsa/mv88e6xxx/chip.h
+index c3ea525a3b19..e76b9cd07578 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.h
++++ b/drivers/net/dsa/mv88e6xxx/chip.h
+@@ -109,6 +109,7 @@ struct mv88e6xxx_info {
+ 	unsigned int num_internal_phys;
+ 	unsigned int max_vid;
+ 	unsigned int port_base_addr;
++	unsigned int phy_base_addr;
+ 	unsigned int global1_addr;
+ 	unsigned int global2_addr;
+ 	unsigned int age_time_coeff;
+diff --git a/drivers/net/dsa/mv88e6xxx/global2.c b/drivers/net/dsa/mv88e6xxx/global2.c
+index 84dbcfb07f4f..f133690e8b92 100644
+--- a/drivers/net/dsa/mv88e6xxx/global2.c
++++ b/drivers/net/dsa/mv88e6xxx/global2.c
+@@ -1117,7 +1117,7 @@ int mv88e6xxx_g2_irq_mdio_setup(struct mv88e6xxx_chip *chip,
+ 			err = irq;
+ 			goto out;
+ 		}
+-		bus->irq[chip->info->port_base_addr + phy] = irq;
++		bus->irq[chip->info->phy_base_addr + phy] = irq;
+ 	}
+ 	return 0;
+ out:
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90103-net-dsa-mv88e6xxx-Fix-interrupt-name-for-g2-irq.patch b/target/linux/mvebu/patches-4.14/90103-net-dsa-mv88e6xxx-Fix-interrupt-name-for-g2-irq.patch
new file mode 100644
index 0000000..b01d158
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90103-net-dsa-mv88e6xxx-Fix-interrupt-name-for-g2-irq.patch
@@ -0,0 +1,41 @@
+From caa8f17b134d1ed638b2a2b069691f09032b7cd0 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig?= <u.kleine-koenig@pengutronix.de>
+Date: Tue, 20 Mar 2018 10:44:42 +0100
+Subject: [PATCH 103/126] net: dsa: mv88e6xxx: Fix interrupt name for g2 irq
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This changes the respective line in /proc/interrupts from
+
+ 49:          x          x  mv88e6xxx-g1   7 Edge      mv88e6xxx-g1
+
+to
+
+ 49:          x          x  mv88e6xxx-g1   7 Edge      mv88e6xxx-g2
+
+which makes more sense.
+
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/global2.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/global2.c b/drivers/net/dsa/mv88e6xxx/global2.c
+index f133690e8b92..ddf8baaf5ca7 100644
+--- a/drivers/net/dsa/mv88e6xxx/global2.c
++++ b/drivers/net/dsa/mv88e6xxx/global2.c
+@@ -1089,7 +1089,7 @@ int mv88e6xxx_g2_irq_setup(struct mv88e6xxx_chip *chip)
+ 
+ 	err = request_threaded_irq(chip->device_irq, NULL,
+ 				   mv88e6xxx_g2_irq_thread_fn,
+-				   IRQF_ONESHOT, "mv88e6xxx-g1", chip);
++				   IRQF_ONESHOT, "mv88e6xxx-g2", chip);
+ 	if (err)
+ 		goto out;
+ 
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90104-net-dsa-mv88e6xxx-Fix-irq-free-ing.patch b/target/linux/mvebu/patches-4.14/90104-net-dsa-mv88e6xxx-Fix-irq-free-ing.patch
new file mode 100644
index 0000000..b75c6ca
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90104-net-dsa-mv88e6xxx-Fix-irq-free-ing.patch
@@ -0,0 +1,31 @@
+From 449552974d9f46837db2eb70e9314efe7eea683c Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Thu, 8 Mar 2018 21:21:36 +0100
+Subject: [PATCH 104/126] net: dsa: mv88e6xxx: Fix irq free'ing
+
+Call the common irq free function, rather than going recursive and
+blowing away the stack, followed by the machine.
+
+Fixes: 294d711ee8c0 ("net: dsa: mv88e6xxx: Poll when no interrupt defined")
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 93f2697efc65..5d9250bf4299 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -375,7 +375,7 @@ static void mv88e6xxx_g1_irq_free_common(struct mv88e6xxx_chip *chip)
+ 
+ static void mv88e6xxx_g1_irq_free(struct mv88e6xxx_chip *chip)
+ {
+-	mv88e6xxx_g1_irq_free(chip);
++	mv88e6xxx_g1_irq_free_common(chip);
+ 
+ 	free_irq(chip->irq, chip);
+ }
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90105-net-dsa-mv88e6xxx-Use-the-DT-IRQ-trigger-mode.patch b/target/linux/mvebu/patches-4.14/90105-net-dsa-mv88e6xxx-Use-the-DT-IRQ-trigger-mode.patch
new file mode 100644
index 0000000..984dff0
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90105-net-dsa-mv88e6xxx-Use-the-DT-IRQ-trigger-mode.patch
@@ -0,0 +1,38 @@
+From 83f5636f9b2d927e9e0c4d80ea13711899b87431 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Sun, 25 Mar 2018 23:43:14 +0200
+Subject: [PATCH 105/126] net: dsa: mv88e6xxx: Use the DT IRQ trigger mode
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+By calling request_threaded_irq() with the flag IRQF_TRIGGER_FALLING
+we override the trigger mode provided in device tree. And the
+interrupt is actually active low, which is what all the current device
+tree descriptions use.
+
+Suggested-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Acked-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
+Tested-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 5d9250bf4299..c947cf4fcb54 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -440,7 +440,7 @@ static int mv88e6xxx_g1_irq_setup(struct mv88e6xxx_chip *chip)
+ 
+ 	err = request_threaded_irq(chip->irq, NULL,
+ 				   mv88e6xxx_g1_irq_thread_fn,
+-				   IRQF_ONESHOT | IRQF_TRIGGER_FALLING,
++				   IRQF_ONESHOT,
+ 				   dev_name(chip->dev), chip);
+ 	if (err)
+ 		mv88e6xxx_g1_irq_free_common(chip);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90106-net-dsa-mv88e6xxx-Call-the-common-IRQ-free-code.patch b/target/linux/mvebu/patches-4.14/90106-net-dsa-mv88e6xxx-Call-the-common-IRQ-free-code.patch
new file mode 100644
index 0000000..a0b5f20
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90106-net-dsa-mv88e6xxx-Call-the-common-IRQ-free-code.patch
@@ -0,0 +1,31 @@
+From f7399689867c46c8e8d060adca10baa17eed8c8e Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Sun, 25 Mar 2018 23:43:15 +0200
+Subject: [PATCH 106/126] net: dsa: mv88e6xxx: Call the common IRQ free code
+
+When free'ing the polled IRQs, call the common irq free code.
+Otherwise the interrupts are left registered, and when we come to load
+the driver a second time, we get an Opps.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index c947cf4fcb54..011ae46497b3 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -482,6 +482,8 @@ static int mv88e6xxx_irq_poll_setup(struct mv88e6xxx_chip *chip)
+ 
+ static void mv88e6xxx_irq_poll_free(struct mv88e6xxx_chip *chip)
+ {
++	mv88e6xxx_g1_irq_free_common(chip);
++
+ 	kthread_cancel_delayed_work_sync(&chip->irq_poll_work);
+ 	kthread_destroy_worker(chip->kworker);
+ }
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90107-net-dsa-mv88e6xxx-Fix-IRQ-when-loading-module.patch b/target/linux/mvebu/patches-4.14/90107-net-dsa-mv88e6xxx-Fix-IRQ-when-loading-module.patch
new file mode 100644
index 0000000..7f8d1bd
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90107-net-dsa-mv88e6xxx-Fix-IRQ-when-loading-module.patch
@@ -0,0 +1,43 @@
+From 6dc27d8bb965b895eee531fd36dd4ced2b89d9c1 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Sat, 17 Mar 2018 20:21:09 +0100
+Subject: [PATCH 107/126] net: dsa: mv88e6xxx: Fix IRQ when loading module
+
+Handle polled interrupts correctly when loading the module.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Fixes: 294d711ee8c0 ("net: dsa: mv88e6xxx: Poll when no interrupt defined")
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 14 ++++++++------
+ 1 file changed, 8 insertions(+), 6 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 011ae46497b3..da30516d14fb 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -4506,13 +4506,15 @@ static void mv88e6xxx_remove(struct mdio_device *mdiodev)
+ 	mv88e6xxx_unregister_switch(chip);
+ 	mv88e6xxx_mdios_unregister(chip);
+ 
+-	if (chip->irq > 0) {
+-		if (chip->info->g2_irqs > 0)
+-			mv88e6xxx_g2_irq_free(chip);
+-		mutex_lock(&chip->reg_lock);
++	if (chip->info->g2_irqs > 0)
++		mv88e6xxx_g2_irq_free(chip);
++
++	mutex_lock(&chip->reg_lock);
++	if (chip->irq > 0)
+ 		mv88e6xxx_g1_irq_free(chip);
+-		mutex_unlock(&chip->reg_lock);
+-	}
++	else
++		mv88e6xxx_irq_poll_free(chip);
++	mutex_unlock(&chip->reg_lock);
+ }
+ 
+ static const struct of_device_id mv88e6xxx_of_match[] = {
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90108-net-dsa-mv88e6xxx-fix-races-between-lock-and-irq-fre.patch b/target/linux/mvebu/patches-4.14/90108-net-dsa-mv88e6xxx-fix-races-between-lock-and-irq-fre.patch
new file mode 100644
index 0000000..c9f17a0
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90108-net-dsa-mv88e6xxx-fix-races-between-lock-and-irq-fre.patch
@@ -0,0 +1,102 @@
+From a89b059be36ef1d221f9a6faa986d56a94b1a7ea Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig?= <u.kleine-koenig@pengutronix.de>
+Date: Fri, 20 Jul 2018 11:53:15 +0200
+Subject: [PATCH 108/126] net: dsa: mv88e6xxx: fix races between lock and irq
+ freeing
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+free_irq() waits until all handlers for this IRQ have completed. As the
+relevant handler (mv88e6xxx_g1_irq_thread_fn()) takes the chip's reg_lock
+it might never return if the thread calling free_irq() holds this lock.
+
+For the same reason kthread_cancel_delayed_work_sync() in the polling case
+must not hold this lock.
+
+Also first free the irq (or stop the worker respectively) such that
+mv88e6xxx_g1_irq_thread_work() isn't called any more before the irq
+mappings are dropped in mv88e6xxx_g1_irq_free_common() to prevent the
+worker thread to call handle_nested_irq(0) which results in a NULL-pointer
+exception.
+
+Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 21 +++++++++++++--------
+ 1 file changed, 13 insertions(+), 8 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index da30516d14fb..cfcd981da236 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -356,6 +356,7 @@ static const struct irq_domain_ops mv88e6xxx_g1_irq_domain_ops = {
+ 	.xlate	= irq_domain_xlate_twocell,
+ };
+ 
++/* To be called with reg_lock held */
+ static void mv88e6xxx_g1_irq_free_common(struct mv88e6xxx_chip *chip)
+ {
+ 	int irq, virq;
+@@ -375,9 +376,15 @@ static void mv88e6xxx_g1_irq_free_common(struct mv88e6xxx_chip *chip)
+ 
+ static void mv88e6xxx_g1_irq_free(struct mv88e6xxx_chip *chip)
+ {
+-	mv88e6xxx_g1_irq_free_common(chip);
+-
++	/*
++	 * free_irq must be called without reg_lock taken because the irq
++	 * handler takes this lock, too.
++	 */
+ 	free_irq(chip->irq, chip);
++
++	mutex_lock(&chip->reg_lock);
++	mv88e6xxx_g1_irq_free_common(chip);
++	mutex_unlock(&chip->reg_lock);
+ }
+ 
+ static int mv88e6xxx_g1_irq_setup_common(struct mv88e6xxx_chip *chip)
+@@ -482,10 +489,12 @@ static int mv88e6xxx_irq_poll_setup(struct mv88e6xxx_chip *chip)
+ 
+ static void mv88e6xxx_irq_poll_free(struct mv88e6xxx_chip *chip)
+ {
+-	mv88e6xxx_g1_irq_free_common(chip);
+-
+ 	kthread_cancel_delayed_work_sync(&chip->irq_poll_work);
+ 	kthread_destroy_worker(chip->kworker);
++
++	mutex_lock(&chip->reg_lock);
++	mv88e6xxx_g1_irq_free_common(chip);
++	mutex_unlock(&chip->reg_lock);
+ }
+ 
+ int mv88e6xxx_wait(struct mv88e6xxx_chip *chip, int addr, int reg, u16 mask)
+@@ -4487,12 +4496,10 @@ static int mv88e6xxx_probe(struct mdio_device *mdiodev)
+ 	if (chip->info->g2_irqs > 0 && chip->irq > 0)
+ 		mv88e6xxx_g2_irq_free(chip);
+ out_g1_irq:
+-	mutex_lock(&chip->reg_lock);
+ 	if (chip->irq > 0)
+ 		mv88e6xxx_g1_irq_free(chip);
+ 	else
+ 		mv88e6xxx_irq_poll_free(chip);
+-	mutex_unlock(&chip->reg_lock);
+ out:
+ 	return err;
+ }
+@@ -4509,12 +4516,10 @@ static void mv88e6xxx_remove(struct mdio_device *mdiodev)
+ 	if (chip->info->g2_irqs > 0)
+ 		mv88e6xxx_g2_irq_free(chip);
+ 
+-	mutex_lock(&chip->reg_lock);
+ 	if (chip->irq > 0)
+ 		mv88e6xxx_g1_irq_free(chip);
+ 	else
+ 		mv88e6xxx_irq_poll_free(chip);
+-	mutex_unlock(&chip->reg_lock);
+ }
+ 
+ static const struct of_device_id mv88e6xxx_of_match[] = {
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90109-net-dsa-mv88e6xxx-Share-main-switch-IRQ.patch b/target/linux/mvebu/patches-4.14/90109-net-dsa-mv88e6xxx-Share-main-switch-IRQ.patch
new file mode 100644
index 0000000..6734b93
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90109-net-dsa-mv88e6xxx-Share-main-switch-IRQ.patch
@@ -0,0 +1,29 @@
+From 0ed95c830283285145f8f3bb2b1ccbcb722c64a5 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Fri, 17 Aug 2018 12:09:49 +0200
+Subject: [PATCH 109/126] net: dsa: mv88e6xxx: Share main switch IRQ
+
+On some boards the interrupt can be shared between multiple devices.
+For example on Turris Mox the interrupt is shared between all switches.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index cfcd981da236..1335c4b5acc1 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -447,7 +447,7 @@ static int mv88e6xxx_g1_irq_setup(struct mv88e6xxx_chip *chip)
+ 
+ 	err = request_threaded_irq(chip->irq, NULL,
+ 				   mv88e6xxx_g1_irq_thread_fn,
+-				   IRQF_ONESHOT,
++				   IRQF_ONESHOT | IRQF_SHARED,
+ 				   dev_name(chip->dev), chip);
+ 	if (err)
+ 		mv88e6xxx_g1_irq_free_common(chip);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90110-net-dsa-mc88e6xxx-Fix-88E6141-6341-2500mbps-SERDES-s.patch b/target/linux/mvebu/patches-4.14/90110-net-dsa-mc88e6xxx-Fix-88E6141-6341-2500mbps-SERDES-s.patch
new file mode 100644
index 0000000..9b86f5d
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90110-net-dsa-mc88e6xxx-Fix-88E6141-6341-2500mbps-SERDES-s.patch
@@ -0,0 +1,103 @@
+From dc9c03cbf564ef633cc00038f3a00698e620daad Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Fri, 5 Oct 2018 13:23:05 +0200
+Subject: [PATCH 110/126] net: dsa: mc88e6xxx: Fix 88E6141/6341 2500mbps SERDES
+ speed
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+The port_set_speed method for the Topaz family must not be the same
+as for Peridot family, since on Topaz port 5 is the SERDES port and
+can be set to 2500mbps spped mode.
+
+This patch adds a new method for the Topaz family, allowing the alt_bit
+mode only for port 0 and 2500 mbps mode for port 5.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ drivers/net/dsa/mv88e6xxx/chip.c |  4 ++--
+ drivers/net/dsa/mv88e6xxx/port.c | 25 +++++++++++++++++++++++--
+ drivers/net/dsa/mv88e6xxx/port.h |  1 +
+ 3 files changed, 26 insertions(+), 4 deletions(-)
+
+diff --git a/drivers/net/dsa/mv88e6xxx/chip.c b/drivers/net/dsa/mv88e6xxx/chip.c
+index 1335c4b5acc1..4dabd878521c 100644
+--- a/drivers/net/dsa/mv88e6xxx/chip.c
++++ b/drivers/net/dsa/mv88e6xxx/chip.c
+@@ -2822,7 +2822,7 @@ static const struct mv88e6xxx_ops mv88e6141_ops = {
+ 	.port_set_link = mv88e6xxx_port_set_link,
+ 	.port_set_duplex = mv88e6xxx_port_set_duplex,
+ 	.port_set_rgmii_delay = mv88e6390_port_set_rgmii_delay,
+-	.port_set_speed = mv88e6390_port_set_speed,
++	.port_set_speed = mv88e6341_port_set_speed,
+ 	.port_tag_remap = mv88e6095_port_tag_remap,
+ 	.port_set_frame_mode = mv88e6351_port_set_frame_mode,
+ 	.port_set_egress_floods = mv88e6352_port_set_egress_floods,
+@@ -3379,7 +3379,7 @@ static const struct mv88e6xxx_ops mv88e6341_ops = {
+ 	.port_set_link = mv88e6xxx_port_set_link,
+ 	.port_set_duplex = mv88e6xxx_port_set_duplex,
+ 	.port_set_rgmii_delay = mv88e6390_port_set_rgmii_delay,
+-	.port_set_speed = mv88e6390_port_set_speed,
++	.port_set_speed = mv88e6341_port_set_speed,
+ 	.port_tag_remap = mv88e6095_port_tag_remap,
+ 	.port_set_frame_mode = mv88e6351_port_set_frame_mode,
+ 	.port_set_egress_floods = mv88e6352_port_set_egress_floods,
+diff --git a/drivers/net/dsa/mv88e6xxx/port.c b/drivers/net/dsa/mv88e6xxx/port.c
+index 78c9e6c50ab0..ead75477a6a3 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.c
++++ b/drivers/net/dsa/mv88e6xxx/port.c
+@@ -228,8 +228,11 @@ static int mv88e6xxx_port_set_speed(struct mv88e6xxx_chip *chip, int port,
+ 		ctrl = MV88E6XXX_PORT_MAC_CTL_SPEED_1000;
+ 		break;
+ 	case 2500:
+-		ctrl = MV88E6390_PORT_MAC_CTL_SPEED_10000 |
+-			MV88E6390_PORT_MAC_CTL_ALTSPEED;
++		if (alt_bit)
++			ctrl = MV88E6390_PORT_MAC_CTL_SPEED_10000 |
++				MV88E6390_PORT_MAC_CTL_ALTSPEED;
++		else
++			ctrl = MV88E6390_PORT_MAC_CTL_SPEED_10000;
+ 		break;
+ 	case 10000:
+ 		/* all bits set, fall through... */
+@@ -291,6 +294,24 @@ int mv88e6185_port_set_speed(struct mv88e6xxx_chip *chip, int port, int speed)
+ 	return mv88e6xxx_port_set_speed(chip, port, speed, false, false);
+ }
+ 
++/* Support 10, 100, 200, 1000, 2500 Mbps (e.g. 88E6341) */
++int mv88e6341_port_set_speed(struct mv88e6xxx_chip *chip, int port, int speed)
++{
++	if (speed == SPEED_MAX)
++		speed = port < 5 ? 1000 : 2500;
++
++	if (speed > 2500)
++		return -EOPNOTSUPP;
++
++	if (speed == 200 && port != 0)
++		return -EOPNOTSUPP;
++
++	if (speed == 2500 && port < 5)
++		return -EOPNOTSUPP;
++
++	return mv88e6xxx_port_set_speed(chip, port, speed, !port, true);
++}
++
+ /* Support 10, 100, 200, 1000 Mbps (e.g. 88E6352 family) */
+ int mv88e6352_port_set_speed(struct mv88e6xxx_chip *chip, int port, int speed)
+ {
+diff --git a/drivers/net/dsa/mv88e6xxx/port.h b/drivers/net/dsa/mv88e6xxx/port.h
+index b31910023bb6..091aa0057f1f 100644
+--- a/drivers/net/dsa/mv88e6xxx/port.h
++++ b/drivers/net/dsa/mv88e6xxx/port.h
+@@ -279,6 +279,7 @@ int mv88e6xxx_port_set_duplex(struct mv88e6xxx_chip *chip, int port, int dup);
+ 
+ int mv88e6065_port_set_speed(struct mv88e6xxx_chip *chip, int port, int speed);
+ int mv88e6185_port_set_speed(struct mv88e6xxx_chip *chip, int port, int speed);
++int mv88e6341_port_set_speed(struct mv88e6xxx_chip *chip, int port, int speed);
+ int mv88e6352_port_set_speed(struct mv88e6xxx_chip *chip, int port, int speed);
+ int mv88e6390_port_set_speed(struct mv88e6xxx_chip *chip, int port, int speed);
+ int mv88e6390x_port_set_speed(struct mv88e6xxx_chip *chip, int port, int speed);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90111-net-ethernet-mvneta-Fix-napi-structure-mixup-on-arma.patch b/target/linux/mvebu/patches-4.14/90111-net-ethernet-mvneta-Fix-napi-structure-mixup-on-arma.patch
new file mode 100644
index 0000000..5e58ed3
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90111-net-ethernet-mvneta-Fix-napi-structure-mixup-on-arma.patch
@@ -0,0 +1,107 @@
+From cb0da3adfe03f7275dbbf4574b46137cb8a23f66 Mon Sep 17 00:00:00 2001
+From: Andrew Lunn <andrew@lunn.ch>
+Date: Fri, 13 Jul 2018 18:18:35 +0200
+Subject: [PATCH 111/126] net: ethernet: mvneta: Fix napi structure mixup on
+ armada 3700
+
+The mvneta Ethernet driver is used on a few different Marvell SoCs.
+Some SoCs have per cpu interrupts for Ethernet events. Some SoCs have
+a single interrupt, independent of the CPU. The driver handles this by
+having a per CPU napi structure when there are per CPU interrupts, and
+a global napi structure when there is a single interrupt.
+
+When the napi core calls mvneta_poll(), it passes the napi
+instance. This was not being propagated through the call chain, and
+instead the per-cpu napi instance was passed to napi_gro_receive()
+call. This breaks when there is a single global napi instance.
+
+Signed-off-by: Andrew Lunn <andrew@lunn.ch>
+Fixes: 2636ac3cc2b4 ("net: mvneta: Add network support for Armada 3700 SoC")
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 22 ++++++++++++----------
+ 1 file changed, 12 insertions(+), 10 deletions(-)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index 2986f8f1ae4a..8f9a2f05077e 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -1905,10 +1905,10 @@ static void mvneta_rxq_drop_pkts(struct mvneta_port *pp,
+ }
+ 
+ /* Main rx processing when using software buffer management */
+-static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
++static int mvneta_rx_swbm(struct napi_struct *napi,
++			  struct mvneta_port *pp, int rx_todo,
+ 			  struct mvneta_rx_queue *rxq)
+ {
+-	struct mvneta_pcpu_port *port = this_cpu_ptr(pp->ports);
+ 	struct net_device *dev = pp->dev;
+ 	int rx_done;
+ 	u32 rcvd_pkts = 0;
+@@ -1963,7 +1963,7 @@ static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
+ 
+ 			skb->protocol = eth_type_trans(skb, dev);
+ 			mvneta_rx_csum(pp, rx_status, skb);
+-			napi_gro_receive(&port->napi, skb);
++			napi_gro_receive(napi, skb);
+ 
+ 			rcvd_pkts++;
+ 			rcvd_bytes += rx_bytes;
+@@ -2005,7 +2005,7 @@ static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
+ 
+ 		mvneta_rx_csum(pp, rx_status, skb);
+ 
+-		napi_gro_receive(&port->napi, skb);
++		napi_gro_receive(napi, skb);
+ 	}
+ 
+ 	if (rcvd_pkts) {
+@@ -2024,10 +2024,10 @@ static int mvneta_rx_swbm(struct mvneta_port *pp, int rx_todo,
+ }
+ 
+ /* Main rx processing when using hardware buffer management */
+-static int mvneta_rx_hwbm(struct mvneta_port *pp, int rx_todo,
++static int mvneta_rx_hwbm(struct napi_struct *napi,
++			  struct mvneta_port *pp, int rx_todo,
+ 			  struct mvneta_rx_queue *rxq)
+ {
+-	struct mvneta_pcpu_port *port = this_cpu_ptr(pp->ports);
+ 	struct net_device *dev = pp->dev;
+ 	int rx_done;
+ 	u32 rcvd_pkts = 0;
+@@ -2089,7 +2089,7 @@ static int mvneta_rx_hwbm(struct mvneta_port *pp, int rx_todo,
+ 
+ 			skb->protocol = eth_type_trans(skb, dev);
+ 			mvneta_rx_csum(pp, rx_status, skb);
+-			napi_gro_receive(&port->napi, skb);
++			napi_gro_receive(napi, skb);
+ 
+ 			rcvd_pkts++;
+ 			rcvd_bytes += rx_bytes;
+@@ -2133,7 +2133,7 @@ static int mvneta_rx_hwbm(struct mvneta_port *pp, int rx_todo,
+ 
+ 		mvneta_rx_csum(pp, rx_status, skb);
+ 
+-		napi_gro_receive(&port->napi, skb);
++		napi_gro_receive(napi, skb);
+ 	}
+ 
+ 	if (rcvd_pkts) {
+@@ -2726,9 +2726,11 @@ static int mvneta_poll(struct napi_struct *napi, int budget)
+ 	if (rx_queue) {
+ 		rx_queue = rx_queue - 1;
+ 		if (pp->bm_priv)
+-			rx_done = mvneta_rx_hwbm(pp, budget, &pp->rxqs[rx_queue]);
++			rx_done = mvneta_rx_hwbm(napi, pp, budget,
++						 &pp->rxqs[rx_queue]);
+ 		else
+-			rx_done = mvneta_rx_swbm(pp, budget, &pp->rxqs[rx_queue]);
++			rx_done = mvneta_rx_swbm(napi, pp, budget,
++						 &pp->rxqs[rx_queue]);
+ 	}
+ 
+ 	if (rx_done < budget) {
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90112-net-mvneta-fix-mvneta_config_rss-on-armada-3700.patch b/target/linux/mvebu/patches-4.14/90112-net-mvneta-fix-mvneta_config_rss-on-armada-3700.patch
new file mode 100644
index 0000000..6fc5b61
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90112-net-mvneta-fix-mvneta_config_rss-on-armada-3700.patch
@@ -0,0 +1,77 @@
+From 5f1089e57642c9df9452a5a0c1108080e858b9d0 Mon Sep 17 00:00:00 2001
+From: Jisheng Zhang <Jisheng.Zhang@synaptics.com>
+Date: Fri, 10 Aug 2018 11:36:27 +0800
+Subject: [PATCH 112/126] net: mvneta: fix mvneta_config_rss on armada 3700
+
+The mvneta Ethernet driver is used on a few different Marvell SoCs.
+Some SoCs have per cpu interrupts for Ethernet events, the driver uses
+a per CPU napi structure for this case. Some SoCs such as armada 3700
+have a single interrupt for Ethernet events, the driver uses a global
+napi structure for this case.
+
+Current mvneta_config_rss() always operates the per cpu napi structure.
+Fix it by operating a global napi for "single interrupt" case, and per
+cpu napi structure for remaining cases.
+
+Signed-off-by: Jisheng Zhang <Jisheng.Zhang@synaptics.com>
+Fixes: 2636ac3cc2b4 ("net: mvneta: Add network support for Armada 3700 SoC")
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/ethernet/marvell/mvneta.c | 31 +++++++++++++++++----------
+ 1 file changed, 20 insertions(+), 11 deletions(-)
+
+diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
+index 8f9a2f05077e..4143b3b57aa5 100644
+--- a/drivers/net/ethernet/marvell/mvneta.c
++++ b/drivers/net/ethernet/marvell/mvneta.c
+@@ -3975,13 +3975,18 @@ static int  mvneta_config_rss(struct mvneta_port *pp)
+ 
+ 	on_each_cpu(mvneta_percpu_mask_interrupt, pp, true);
+ 
+-	/* We have to synchronise on the napi of each CPU */
+-	for_each_online_cpu(cpu) {
+-		struct mvneta_pcpu_port *pcpu_port =
+-			per_cpu_ptr(pp->ports, cpu);
++	if (!pp->neta_armada3700) {
++		/* We have to synchronise on the napi of each CPU */
++		for_each_online_cpu(cpu) {
++			struct mvneta_pcpu_port *pcpu_port =
++				per_cpu_ptr(pp->ports, cpu);
+ 
+-		napi_synchronize(&pcpu_port->napi);
+-		napi_disable(&pcpu_port->napi);
++			napi_synchronize(&pcpu_port->napi);
++			napi_disable(&pcpu_port->napi);
++		}
++	} else {
++		napi_synchronize(&pp->napi);
++		napi_disable(&pp->napi);
+ 	}
+ 
+ 	pp->rxq_def = pp->indir[0];
+@@ -3998,12 +4003,16 @@ static int  mvneta_config_rss(struct mvneta_port *pp)
+ 	mvneta_percpu_elect(pp);
+ 	spin_unlock(&pp->lock);
+ 
+-	/* We have to synchronise on the napi of each CPU */
+-	for_each_online_cpu(cpu) {
+-		struct mvneta_pcpu_port *pcpu_port =
+-			per_cpu_ptr(pp->ports, cpu);
++	if (!pp->neta_armada3700) {
++		/* We have to synchronise on the napi of each CPU */
++		for_each_online_cpu(cpu) {
++			struct mvneta_pcpu_port *pcpu_port =
++				per_cpu_ptr(pp->ports, cpu);
+ 
+-		napi_enable(&pcpu_port->napi);
++			napi_enable(&pcpu_port->napi);
++		}
++	} else {
++		napi_enable(&pp->napi);
+ 	}
+ 
+ 	netif_tx_start_all_queues(pp->dev);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90113-pinctrl-armada-37xx-Correct-mpp-definitions.patch b/target/linux/mvebu/patches-4.14/90113-pinctrl-armada-37xx-Correct-mpp-definitions.patch
new file mode 100644
index 0000000..79a841a
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90113-pinctrl-armada-37xx-Correct-mpp-definitions.patch
@@ -0,0 +1,108 @@
+From 841332d49b280dd92f2ad42b6e34f6b64a387d78 Mon Sep 17 00:00:00 2001
+From: Ken Ma <make@marvell.com>
+Date: Thu, 3 May 2018 14:31:41 +0200
+Subject: [PATCH 113/126] pinctrl: armada-37xx: Correct mpp definitions
+
+This patch icorrects below mpp definitions:
+ - The sdio_sb group is composed of 6 pins and not 5;
+ - The rgmii group contains pins mpp2[17:6] and not mpp2[19:6];
+ - Pin of group "pmic0" is mpp1[6] but not mpp1[16];
+ - Pin of group "pmic1" is mpp1[7] but not mpp1[17];
+ - A new group "smi" is added in A0 with 2 pins - mpp2[19:18], its
+   bitmask is bit4;
+ - Group "pcie1" has 3 pins in A0 - mpp2[5:3], its bit mask is
+   bit5 | bit9 | bit10 but not bit4;
+ - Group "ptp" has 3 pins in A0 as Z1, but its bitmask is changed to
+   bit11 | bit12 | bit13.
+
+Reviewed-on: http://vgitil04.il.marvell.com:8080/41830
+Reviewed-on: http://vgitil04.il.marvell.com:8080/42774
+Reviewed-on: http://vgitil04.il.marvell.com:8080/41970
+Reviewed-on: http://vgitil04.il.marvell.com:8080/42775
+Reviewed-by: Wilson Ding <dingwei@marvell.com>
+Reviewed-by: Evan Wang <xswang@marvell.com>
+Reviewed-by: Victor Gu <xigu@marvell.com>
+Tested-by: Wilson Ding <dingwei@marvell.com>
+Tested-by: iSoC Platform CI <ykjenk@marvell.com>
+Tested-by: Victor Gu <xigu@marvell.com>
+Verified-Armada37x0: Wilson Ding <dingwei@marvell.com>
+Signed-off-by: Ken Ma <make@marvell.com>
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ .../pinctrl/marvell,armada-37xx-pinctrl.txt        | 14 +++++++++-----
+ drivers/pinctrl/mvebu/pinctrl-armada-37xx.c        |  9 +++++----
+ 2 files changed, 14 insertions(+), 9 deletions(-)
+
+diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-37xx-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-37xx-pinctrl.txt
+index f64060908d5a..e1469852d5ea 100644
+--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-37xx-pinctrl.txt
++++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-37xx-pinctrl.txt
+@@ -58,11 +58,11 @@ group pwm3
+  - functions pwm, gpio
+ 
+ group pmic1
+- - pin 17
++ - pin 7
+  - functions pmic, gpio
+ 
+ group pmic0
+- - pin 16
++ - pin 6
+  - functions pmic, gpio
+ 
+ group i2c2
+@@ -112,17 +112,21 @@ group usb2_drvvbus1
+  - functions drvbus, gpio
+ 
+ group sdio_sb
+- - pins 60-64
++ - pins 60-65
+  - functions sdio, gpio
+ 
+ group rgmii
+- - pins 42-55
++ - pins 42-53
+  - functions mii, gpio
+ 
+ group pcie1
+- - pins 39-40
++ - pins 39-41
+  - functions pcie, gpio
+ 
++group smi
++ - pins 54-55
++ - functions smi, gpio
++
+ group ptp
+  - pins 56-58
+  - functions ptp, gpio
+diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+index 44897d4b9d88..67a9a747a1b9 100644
+--- a/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
++++ b/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c
+@@ -157,8 +157,8 @@ static struct armada_37xx_pin_group armada_37xx_nb_groups[] = {
+ 	PIN_GRP_GPIO("pwm1", 12, 1, BIT(4), "pwm"),
+ 	PIN_GRP_GPIO("pwm2", 13, 1, BIT(5), "pwm"),
+ 	PIN_GRP_GPIO("pwm3", 14, 1, BIT(6), "pwm"),
+-	PIN_GRP_GPIO("pmic1", 17, 1, BIT(7), "pmic"),
+-	PIN_GRP_GPIO("pmic0", 16, 1, BIT(8), "pmic"),
++	PIN_GRP_GPIO("pmic1", 7, 1, BIT(7), "pmic"),
++	PIN_GRP_GPIO("pmic0", 6, 1, BIT(8), "pmic"),
+ 	PIN_GRP_GPIO("i2c2", 2, 2, BIT(9), "i2c"),
+ 	PIN_GRP_GPIO("i2c1", 0, 2, BIT(10), "i2c"),
+ 	PIN_GRP_GPIO("spi_cs1", 17, 1, BIT(12), "spi"),
+@@ -182,8 +182,9 @@ static struct armada_37xx_pin_group armada_37xx_sb_groups[] = {
+ 	PIN_GRP_GPIO("usb2_drvvbus1", 1, 1, BIT(1), "drvbus"),
+ 	PIN_GRP_GPIO("sdio_sb", 24, 6, BIT(2), "sdio"),
+ 	PIN_GRP_GPIO("rgmii", 6, 12, BIT(3), "mii"),
+-	PIN_GRP_GPIO("pcie1", 3, 2, BIT(4), "pcie"),
+-	PIN_GRP_GPIO("ptp", 20, 3, BIT(5), "ptp"),
++	PIN_GRP_GPIO("smi", 18, 2, BIT(4), "smi"),
++	PIN_GRP_GPIO("pcie1", 3, 3, BIT(5) | BIT(9) | BIT(10), "pcie"),
++	PIN_GRP_GPIO("ptp", 20, 3, BIT(11) | BIT(12) | BIT(13), "ptp"),
+ 	PIN_GRP("ptp_clk", 21, 1, BIT(6), "ptp", "mii"),
+ 	PIN_GRP("ptp_trig", 22, 1, BIT(7), "ptp", "mii"),
+ 	PIN_GRP_GPIO_3("mii_col", 23, 1, BIT(8) | BIT(14), 0, BIT(8), BIT(14),
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90114-arm64-dts-marvell-armada-37xx-mark-the-gpio-controll.patch b/target/linux/mvebu/patches-4.14/90114-arm64-dts-marvell-armada-37xx-mark-the-gpio-controll.patch
new file mode 100644
index 0000000..61095ae
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90114-arm64-dts-marvell-armada-37xx-mark-the-gpio-controll.patch
@@ -0,0 +1,56 @@
+From b1b1740310ae80041b8b6f963076c216bc99bbaf Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig?= <u.kleine-koenig@pengutronix.de>
+Date: Wed, 21 Mar 2018 11:50:03 +0100
+Subject: [PATCH 114/126] arm64: dts: marvell: armada-37xx: mark the gpio
+ controllers as irq controller
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This allows to reference these gpio controller as interrupt parent. Also
+add a comment which cpu line names are managed by the controllers
+because "nb" and "sb" usually doesn't appear in schematics, but MPPX_Y
+do.
+
+Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
+Reviewed-by: Andrew Lunn <andrew@lunn.ch>
+Signed-off-by: Gregory CLEMENT <gregory.clement@bootlin.com>
+---
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+index 8cd43ce38571..783fbb7f3b47 100644
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -169,10 +169,13 @@
+ 				compatible = "marvell,armada3710-nb-pinctrl",
+ 					     "syscon", "simple-mfd";
+ 				reg = <0x13800 0x100>, <0x13C00 0x20>;
++				/* MPP1[19:0] */
+ 				gpionb: gpio {
+ 					#gpio-cells = <2>;
+ 					gpio-ranges = <&pinctrl_nb 0 0 36>;
+ 					gpio-controller;
++					interrupt-controller;
++					#interrupt-cells = <2>;
+ 					interrupts =
+ 					<GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>,
+ 					<GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>,
+@@ -231,10 +234,13 @@
+ 				compatible = "marvell,armada3710-sb-pinctrl",
+ 					     "syscon", "simple-mfd";
+ 				reg = <0x18800 0x100>, <0x18C00 0x20>;
++				/* MPP2[23:0] */
+ 				gpiosb: gpio {
+ 					#gpio-cells = <2>;
+ 					gpio-ranges = <&pinctrl_sb 0 0 30>;
+ 					gpio-controller;
++					interrupt-controller;
++					#interrupt-cells = <2>;
+ 					interrupts =
+ 					<GIC_SPI 160 IRQ_TYPE_LEVEL_HIGH>,
+ 					<GIC_SPI 159 IRQ_TYPE_LEVEL_HIGH>,
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90115-drivers-mfd-Add-support-for-Moxtet-bus.patch b/target/linux/mvebu/patches-4.14/90115-drivers-mfd-Add-support-for-Moxtet-bus.patch
new file mode 100644
index 0000000..eb53c5d
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90115-drivers-mfd-Add-support-for-Moxtet-bus.patch
@@ -0,0 +1,764 @@
+From f090da3ea5975a0d13dcf2c3c3ca3b4790dbaede Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Wed, 8 Aug 2018 16:02:13 +0200
+Subject: [PATCH 115/126] drivers: mfd: Add support for Moxtet bus
+
+On the Turris Mox router there can be connected different modules to
+the main CPU board, currently a module with a SFP cage, a module with
+MiniPCIe connector, a 4-port switch module and a 8-port switch module,
+for example:
+  [CPU]-[PCIe]-[8-port switch]-[8-port switch]-[SFP]
+
+Each of this modules has an input and output shift register, and these
+are connected via SPI to CPU board.
+
+Via this SPI connection we are able to discover which modules are
+connected and we can also read/write some configuration to the modules.
+Fromi/to each module 8 bits can be read (of which lower 4 bits identify
+the module) and written.
+
+For example from the module with a SFP cage we can read the LOS,
+TX-FAULT and MOD-DEF0 signals, while we can write TX-DISABLE and
+RATE-SELECT signals.
+
+Other modules may support something else.
+
+This driver creates a new bus type, called "moxtet". For each Mox module
+it finds via SPI, it creates a new device on the moxtet bus so that
+drivers can be written for them, for example a gpio driver for the
+module with a SFP cage.
+
+The topology of how Mox modules are connected can then be read by
+listing /sys/bus/moxtet/devices.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ .../devicetree/bindings/mfd/moxtet.txt        |  36 ++
+ MAINTAINERS                                   |   7 +
+ drivers/mfd/Kconfig                           |  10 +
+ drivers/mfd/Makefile                          |   1 +
+ drivers/mfd/moxtet.c                          | 504 ++++++++++++++++++
+ include/linux/mfd/moxtet.h                    | 106 ++++
+ 6 files changed, 664 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/mfd/moxtet.txt
+ create mode 100644 drivers/mfd/moxtet.c
+ create mode 100644 include/linux/mfd/moxtet.h
+
+diff --git a/Documentation/devicetree/bindings/mfd/moxtet.txt b/Documentation/devicetree/bindings/mfd/moxtet.txt
+new file mode 100644
+index 000000000000..02b96fbd5ddd
+--- /dev/null
++++ b/Documentation/devicetree/bindings/mfd/moxtet.txt
+@@ -0,0 +1,36 @@
++Turris Mox module configuration bus (over SPI)
++
++Required properties:
++ - compatible		: Should be "cznic,moxtet".
++ - #address-cells	: Has to be 1
++ - #size-cells		: Has to be 0
++For other required and optional properties of SPI slave
++nodes please refer to ../spi/spi-bus.txt.
++
++Required properties of subnodes:
++ - reg			: Should be position on the Moxtet bus
++ - moxtet,id		: Should be ID of the Moxtet device connected
++
++The driver finds the devices connected to the bus by itself, but it may be
++needed to reference some of them from other parts of the device tree. In that
++case the devices can be defined as subnodes of the moxtet node.
++
++Example:
++
++	moxtet@1 {
++		#address-cells = <1>;
++		#size-cells = <0>;
++		compatible = "cznic,moxtet";
++		reg = <1>;
++		spi-max-frequency = <1000000>;
++		spi-cpol;
++		spi-cpha;
++
++		moxtet_sfp: moxtet-sfp@0 {
++			compatible = "cznic,moxtet-sfp";
++			gpio-controller;
++			#gpio-cells;
++			reg = <0>;
++			moxtet,id = <1>;
++		}
++	};
+diff --git a/MAINTAINERS b/MAINTAINERS
+index 6cb70b853323..ab6dc27c14c9 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -1344,6 +1344,13 @@ F:	drivers/clocksource/timer-prima2.c
+ F:	drivers/clocksource/timer-atlas7.c
+ N:	[^a-z]sirf
+ 
++ARM/CZ.NIC TURRIS MOX SUPPORT
++M:	Marek Behun <marek.behun@nic.cz>
++W:	http://mox.turris.cz
++S:	Maintained
++F:	include/mfd/moxtet.h
++F:	drivers/mfd/moxtet.c
++
+ ARM/EBSA110 MACHINE SUPPORT
+ M:	Russell King <linux@armlinux.org.uk>
+ L:	linux-arm-kernel@lists.infradead.org (moderated for non-subscribers)
+diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
+index fc5e4fef89d2..663789ef3225 100644
+--- a/drivers/mfd/Kconfig
++++ b/drivers/mfd/Kconfig
+@@ -761,6 +761,16 @@ config MFD_MAX8998
+ 	  additional drivers must be enabled in order to use the functionality
+ 	  of the device.
+ 
++config MFD_MOXTET
++	tristate "CZ.NIC Turris Mox module configuration bus"
++	depends on SPI_MASTER && OF
++	help
++	  Say yes here to add support for the module configuration bus found
++	  on CZ.NIC's Turris Mox. This is needed for the ability to read
++	  in what order the modules are connected and to get/set some of
++	  their settings. For example the GPIOs on Mox SFP module are
++	  configured through this bus.
++
+ config MFD_MT6397
+ 	tristate "MediaTek MT6397 PMIC Support"
+ 	select MFD_CORE
+diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
+index 8703ff17998e..79b6e06c20c9 100644
+--- a/drivers/mfd/Makefile
++++ b/drivers/mfd/Makefile
+@@ -150,6 +150,7 @@ max8925-objs			:= max8925-core.o max8925-i2c.o
+ obj-$(CONFIG_MFD_MAX8925)	+= max8925.o
+ obj-$(CONFIG_MFD_MAX8997)	+= max8997.o max8997-irq.o
+ obj-$(CONFIG_MFD_MAX8998)	+= max8998.o max8998-irq.o
++obj-$(CONFIG_MFD_MOXTET)	+= moxtet.o
+ 
+ pcf50633-objs			:= pcf50633-core.o pcf50633-irq.o
+ obj-$(CONFIG_MFD_PCF50633)	+= pcf50633.o
+diff --git a/drivers/mfd/moxtet.c b/drivers/mfd/moxtet.c
+new file mode 100644
+index 000000000000..ec525263566a
+--- /dev/null
++++ b/drivers/mfd/moxtet.c
+@@ -0,0 +1,504 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Turris Mox module configuration bus driver
++ *
++ * Copyright (C) 2018 Marek Behun <marek.behun@nic.cz>
++ */
++
++#include <linux/module.h>
++#include <linux/mutex.h>
++#include <linux/of_device.h>
++#include <linux/spi/spi.h>
++#include <linux/mfd/moxtet.h>
++
++static ssize_t
++module_id_show(struct device *dev, struct device_attribute *a, char *buf)
++{
++	struct moxtet_device *mdev = to_moxtet_device(dev);
++
++	return sprintf(buf, "0x%x\n", mdev->id);
++}
++static DEVICE_ATTR_RO(module_id);
++
++static ssize_t
++module_name_show(struct device *dev, struct device_attribute *a, char *buf)
++{
++	struct moxtet_device *mdev = to_moxtet_device(dev);
++
++	return sprintf(buf, "%s\n", turris_mox_module_name(mdev->id));
++}
++static DEVICE_ATTR_RO(module_name);
++
++static ssize_t
++input_value_show(struct device *dev, struct device_attribute *a, char *buf)
++{
++	int ret;
++
++	ret = moxtet_device_read(dev);
++	if (ret < 0)
++		return ret;
++
++	return sprintf(buf, "0x%x\n", ret);
++}
++static DEVICE_ATTR_RO(input_value);
++
++static ssize_t
++output_value_show(struct device *dev, struct device_attribute *a, char *buf)
++{
++	int ret;
++
++	ret = moxtet_device_written(dev);
++	if (ret < 0)
++		return ret;
++
++	return sprintf(buf, "0x%x\n", ret);
++}
++
++static ssize_t
++output_value_store(struct device *dev, struct device_attribute *a,
++		   const char *buf, size_t count)
++{
++	unsigned long val;
++	int ret;
++
++	ret = kstrtoul(buf, 0, &val);
++	if (ret < 0)
++		return ret;
++
++	if (val > 0xff)
++		return -ERANGE;
++
++	ret = moxtet_device_write(dev, val);
++	if (ret < 0)
++		return ret;
++
++	return count;
++}
++static DEVICE_ATTR_RW(output_value);
++
++static struct attribute *moxtet_dev_attrs[] = {
++	&dev_attr_module_id.attr,
++	&dev_attr_module_name.attr,
++	&dev_attr_input_value.attr,
++	&dev_attr_output_value.attr,
++	NULL,
++};
++
++static const struct attribute_group moxtet_dev_group = {
++	.attrs = moxtet_dev_attrs,
++};
++
++static const struct attribute_group *moxtet_dev_groups[] = {
++	&moxtet_dev_group,
++	NULL,
++};
++
++static int moxtet_match(struct device *dev, struct device_driver *drv)
++{
++	struct moxtet_device *mdev = to_moxtet_device(dev);
++	struct moxtet_driver *tdrv = to_moxtet_driver(drv);
++	const enum turris_mox_module_id *t;
++
++	if (of_driver_match_device(dev, drv))
++		return 1;
++
++	if (!tdrv->id_table)
++		return 0;
++
++	for (t = tdrv->id_table; *t; ++t)
++		if (*t == mdev->id)
++			return 1;
++
++	return 0;
++}
++
++struct bus_type moxtet_bus_type = {
++	.name		= "moxtet",
++	.dev_groups	= moxtet_dev_groups,
++	.match		= moxtet_match,
++};
++EXPORT_SYMBOL_GPL(moxtet_bus_type);
++
++int __moxtet_register_driver(struct module *owner,
++			     struct moxtet_driver *mdrv)
++{
++	mdrv->driver.owner = owner;
++	mdrv->driver.bus = &moxtet_bus_type;
++	return driver_register(&mdrv->driver);
++}
++EXPORT_SYMBOL_GPL(__moxtet_register_driver);
++
++static int moxtet_dev_check(struct device *dev, void *data)
++{
++	struct moxtet_device *mdev = to_moxtet_device(dev);
++	struct moxtet_device *new_dev = data;
++
++	if (mdev->moxtet == new_dev->moxtet && mdev->id == new_dev->id &&
++	    mdev->idx == new_dev->idx)
++		return -EBUSY;
++	return 0;
++}
++
++static void moxtet_dev_release(struct device *dev)
++{
++	struct moxtet_device *mdev = to_moxtet_device(dev);
++
++	put_device(mdev->moxtet->dev);
++	kfree(mdev);
++}
++
++static struct moxtet_device *
++moxtet_alloc_device(struct moxtet *moxtet)
++{
++	struct moxtet_device *dev;
++
++	if (!get_device(moxtet->dev))
++		return NULL;
++
++	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
++	if (!dev) {
++		put_device(moxtet->dev);
++		return NULL;
++	}
++
++	dev->moxtet = moxtet;
++	dev->dev.parent = moxtet->dev;
++	dev->dev.bus = &moxtet_bus_type;
++	dev->dev.release = moxtet_dev_release;
++
++	device_initialize(&dev->dev);
++
++	return dev;
++}
++
++static int moxtet_add_device(struct moxtet_device *dev)
++{
++	static DEFINE_MUTEX(add_mutex);
++	int ret;
++
++	if (dev->idx >= TURRIS_MOX_MAX_MODULES || dev->id > 0xf)
++		return -EINVAL;
++
++	dev_set_name(&dev->dev, "moxtet-%s.%u",
++		     turris_mox_module_name(dev->id), dev->idx);
++
++	mutex_lock(&add_mutex);
++
++	ret = bus_for_each_dev(&moxtet_bus_type, NULL, dev,
++			       moxtet_dev_check);
++	if (ret)
++		goto done;
++
++	ret = device_add(&dev->dev);
++	if (ret < 0)
++		dev_err(dev->moxtet->dev, "can't add %s, status %d\n",
++			dev_name(dev->moxtet->dev), ret);
++
++done:
++	mutex_unlock(&add_mutex);
++	return ret;
++}
++
++static int __unregister(struct device *dev, void *null)
++{
++	if (dev->of_node) {
++		of_node_clear_flag(dev->of_node, OF_POPULATED);
++		of_node_put(dev->of_node);
++	}
++
++	device_unregister(dev);
++
++	return 0;
++}
++
++static struct moxtet_device *
++of_register_moxtet_device(struct moxtet *moxtet, struct device_node *nc)
++{
++	struct moxtet_device *dev;
++	u32 val;
++	int ret;
++
++	dev = moxtet_alloc_device(moxtet);
++	if (!dev) {
++		dev_err(moxtet->dev,
++			"Moxtet device alloc error for %pOF\n", nc);
++		return ERR_PTR(-ENOMEM);
++	}
++
++	ret = of_property_read_u32(nc, "reg", &val);
++	if (ret || val >= TURRIS_MOX_MAX_MODULES) {
++		dev_err(moxtet->dev, "%pOF has no valid 'reg' property (%d)\n",
++			nc, ret);
++		goto err_put;
++	}
++	dev->idx = val;
++
++	ret = of_property_read_u32(nc, "moxtet,id", &val);
++	if (ret || val > 0xf) {
++		dev_err(moxtet->dev,
++			"%pOF has no valid 'moxtet,id' property (%d)\n", nc,
++			ret);
++		goto err_put;
++	}
++	dev->id = val;
++
++	if (moxtet->modules[dev->idx] != dev->id) {
++		dev_err(moxtet->dev,
++			"%pOF requested Moxtet device ID 0x%x, 0x%x found\n",
++			nc, dev->id, moxtet->modules[dev->idx]);
++		goto err_put;
++	}
++
++	of_node_get(nc);
++	dev->dev.of_node = nc;
++
++	ret = moxtet_add_device(dev);
++	if (ret) {
++		dev_err(moxtet->dev,
++			"Moxtet device register error for %pOF\n", nc);
++		of_node_put(nc);
++		goto err_put;
++	}
++
++	return dev;
++
++err_put:
++	put_device(&dev->dev);
++	return ERR_PTR(ret);
++}
++
++static void of_register_moxtet_devices(struct moxtet *moxtet)
++{
++	struct moxtet_device *dev;
++	struct device_node *nc;
++
++	if (!moxtet->dev->of_node)
++		return;
++
++	for_each_available_child_of_node(moxtet->dev->of_node, nc) {
++		if (of_node_test_and_set_flag(nc, OF_POPULATED))
++			continue;
++		dev = of_register_moxtet_device(moxtet, nc);
++		if (IS_ERR(dev)) {
++			dev_warn(moxtet->dev,
++				 "Failed to create Moxtet device for %pOF\n",
++				 nc);
++			of_node_clear_flag(nc, OF_POPULATED);
++		}
++	}
++}
++
++static void
++moxtet_register_devices_from_topology(struct moxtet *moxtet)
++{
++	struct moxtet_device *dev;
++	int i, ret;
++
++	for (i = 0; i < moxtet->count; ++i) {
++		dev = moxtet_alloc_device(moxtet);
++		if (!dev) {
++			dev_err(moxtet->dev, "Moxtet device %u alloc error\n",
++				i);
++			continue;
++		}
++
++		dev->idx = i;
++		dev->id = moxtet->modules[i];
++
++		ret = moxtet_add_device(dev);
++		if (ret && ret != -EBUSY) {
++			put_device(&dev->dev);
++			dev_err(moxtet->dev,
++				"Moxtet device %u register error: %i\n", i,
++				ret);
++		}
++	}
++}
++
++static int moxtet_find_topology(struct moxtet *moxtet)
++{
++	u8 buf[TURRIS_MOX_MAX_MODULES];
++	int i, ret;
++
++	ret = spi_read(to_spi_device(moxtet->dev), buf, TURRIS_MOX_MAX_MODULES);
++	if (ret < 0)
++		return ret;
++
++	if (buf[0] == TURRIS_MOX_CPU_ID_EMMC) {
++		dev_info(moxtet->dev, "Found eMMC Turris Mox CPU module\n");
++	} else if (buf[0] == TURRIS_MOX_CPU_ID_SD) {
++		dev_info(moxtet->dev, "Found SD Turris Mox CPU module\n");
++	} else {
++		dev_err(moxtet->dev, "Invalid Turris Mox CPU module 0x%02x\n",
++			buf[0]);
++		return -ENODEV;
++	}
++
++	moxtet->count = 0;
++
++	for (i = 1; i < TURRIS_MOX_MAX_MODULES; ++i) {
++		int module_id;
++
++		if (buf[i] == 0xff)
++			break;
++
++		module_id = buf[i] & 0xf;
++
++		moxtet->modules[i-1] = module_id;
++		++moxtet->count;
++
++		switch (module_id) {
++		case TURRIS_MOX_MODULE_SFP:
++			dev_info(moxtet->dev, "SFP module found\n");
++			break;
++		case TURRIS_MOX_MODULE_PCI:
++			dev_info(moxtet->dev, "PCIe module found\n");
++			break;
++		case TURRIS_MOX_MODULE_TOPAZ:
++			dev_info(moxtet->dev, "Topaz Switch module found\n");
++			break;
++		case TURRIS_MOX_MODULE_PERIDOT:
++			dev_info(moxtet->dev, "Peridot Switch module found\n");
++			break;
++		case TURRIS_MOX_MODULE_USB3:
++			dev_info(moxtet->dev, "USB 3.0 module found\n");
++			break;
++		default:
++			dev_info(moxtet->dev,
++				 "Unknown Moxtet module found (ID 0x%02x)\n",
++				 module_id);
++		}
++	}
++
++	return 0;
++}
++
++int moxtet_device_read(struct device *dev)
++{
++	struct moxtet_device *mdev = to_moxtet_device(dev);
++	struct moxtet *moxtet = mdev->moxtet;
++	u8 buf[TURRIS_MOX_MAX_MODULES];
++	struct spi_transfer xfer = {
++		.rx_buf = buf,
++		.tx_buf = moxtet->tx,
++		.len = moxtet->count + 1
++	};
++	int ret;
++
++	if (mdev->idx >= moxtet->count)
++		return -EINVAL;
++
++	mutex_lock(&moxtet->lock);
++
++	ret = spi_sync_transfer(to_spi_device(moxtet->dev), &xfer, 1);
++
++	mutex_unlock(&moxtet->lock);
++
++	if (ret < 0)
++		return ret;
++
++	return buf[mdev->idx + 1] >> 4;
++}
++EXPORT_SYMBOL_GPL(moxtet_device_read);
++
++int moxtet_device_write(struct device *dev, u8 val)
++{
++	struct moxtet_device *mdev = to_moxtet_device(dev);
++	struct moxtet *moxtet = mdev->moxtet;
++	int ret;
++
++	if (mdev->idx >= moxtet->count)
++		return -EINVAL;
++
++	mutex_lock(&moxtet->lock);
++
++	moxtet->tx[moxtet->count - mdev->idx] = val;
++
++	ret = spi_write(to_spi_device(moxtet->dev), moxtet->tx,
++			moxtet->count + 1);
++
++	mutex_unlock(&moxtet->lock);
++
++	return ret;
++}
++EXPORT_SYMBOL_GPL(moxtet_device_write);
++
++int moxtet_device_written(struct device *dev)
++{
++	struct moxtet_device *mdev = to_moxtet_device(dev);
++	struct moxtet *moxtet = mdev->moxtet;
++
++	if (mdev->idx >= moxtet->count)
++		return -EINVAL;
++
++	return moxtet->tx[moxtet->count - mdev->idx];
++}
++EXPORT_SYMBOL_GPL(moxtet_device_written);
++
++static int moxtet_probe(struct spi_device *spi)
++{
++	struct moxtet *moxtet;
++	int ret;
++
++	ret = spi_setup(spi);
++	if (ret < 0)
++		return ret;
++
++	moxtet = devm_kzalloc(&spi->dev, sizeof(struct moxtet),
++			      GFP_KERNEL);
++	if (!moxtet)
++		return -ENOMEM;
++
++	moxtet->dev = &spi->dev;
++	spi_set_drvdata(spi, moxtet);
++
++	mutex_init(&moxtet->lock);
++
++	ret = moxtet_find_topology(moxtet);
++	if (ret < 0)
++		return ret;
++
++	of_register_moxtet_devices(moxtet);
++	moxtet_register_devices_from_topology(moxtet);
++
++	return 0;
++}
++
++static int moxtet_remove(struct spi_device *spi)
++{
++	struct moxtet *moxtet = spi_get_drvdata(spi);
++	int dummy;
++
++	dummy = device_for_each_child(moxtet->dev, NULL, __unregister);
++
++	mutex_destroy(&moxtet->lock);
++
++	return 0;
++}
++
++static const struct of_device_id moxtet_dt_ids[] = {
++	{ .compatible = "cznic,moxtet" },
++	{},
++};
++MODULE_DEVICE_TABLE(of, moxtet_dt_ids);
++
++static struct spi_driver moxtet_driver = {
++	.driver = {
++		.name		= "moxtet",
++		.of_match_table = moxtet_dt_ids,
++	},
++	.probe		= moxtet_probe,
++	.remove		= moxtet_remove,
++};
++module_spi_driver(moxtet_driver);
++
++static int __init moxtet_init(void)
++{
++	return bus_register(&moxtet_bus_type);
++}
++
++postcore_initcall(moxtet_init);
++
++MODULE_AUTHOR("Marek Behun <marek.behun@nic.cz>");
++MODULE_DESCRIPTION("CZ.NIC's Turris Mox module configuration bus");
++MODULE_LICENSE("GPL v2");
+diff --git a/include/linux/mfd/moxtet.h b/include/linux/mfd/moxtet.h
+new file mode 100644
+index 000000000000..fcb7bb0d4465
+--- /dev/null
++++ b/include/linux/mfd/moxtet.h
+@@ -0,0 +1,106 @@
++/* SPDX-License-Identifier: GPL-2.0 */
++/*
++ * Turris Mox module configuration bus driver
++ *
++ * Copyright (C) 2018 Marek Behun <marek.behun@nic.cz>
++ */
++
++#ifndef __LINUX_MFD_MOXTET_H
++#define __LINUX_MFD_MOXTET_H
++
++#include <linux/device.h>
++#include <linux/mutex.h>
++
++#define TURRIS_MOX_MAX_MODULES	10
++
++enum turris_mox_cpu_module_id {
++	TURRIS_MOX_CPU_ID_EMMC	= 0x00,
++	TURRIS_MOX_CPU_ID_SD	= 0x10,
++};
++
++enum turris_mox_module_id {
++	TURRIS_MOX_MODULE_SFP		= 0x01,
++	TURRIS_MOX_MODULE_PCI		= 0x02,
++	TURRIS_MOX_MODULE_TOPAZ		= 0x03,
++	TURRIS_MOX_MODULE_PERIDOT	= 0x04,
++	TURRIS_MOX_MODULE_USB3		= 0x05,
++};
++
++static inline const char *turris_mox_module_name(unsigned int id)
++{
++	switch (id) {
++	case TURRIS_MOX_MODULE_SFP:
++		return "sfp";
++	case TURRIS_MOX_MODULE_PCI:
++		return "pci";
++	case TURRIS_MOX_MODULE_TOPAZ:
++		return "topaz";
++	case TURRIS_MOX_MODULE_PERIDOT:
++		return "peridot";
++	case TURRIS_MOX_MODULE_USB3:
++		return "usb3";
++	default:
++		return "unknown";
++	}
++}
++
++extern struct bus_type moxtet_type;
++
++struct moxtet {
++	struct device	*dev;
++	struct mutex	lock;
++	u8		modules[TURRIS_MOX_MAX_MODULES];
++	int		count;
++	u8		tx[TURRIS_MOX_MAX_MODULES];
++	char		module_topology[128];
++};
++
++struct moxtet_driver {
++	const enum turris_mox_module_id	*id_table;
++	struct device_driver		driver;
++};
++
++static inline struct moxtet_driver *
++to_moxtet_driver(struct device_driver *drv)
++{
++	if (!drv)
++		return NULL;
++	return container_of(drv, struct moxtet_driver, driver);
++}
++
++extern int __moxtet_register_driver(struct module *owner,
++				    struct moxtet_driver *mdrv);
++
++static inline void moxtet_unregister_driver(struct moxtet_driver *mdrv)
++{
++	if (mdrv)
++		driver_unregister(&mdrv->driver);
++}
++
++#define moxtet_register_driver(driver) \
++	__moxtet_register_driver(THIS_MODULE, driver)
++
++#define module_moxtet_driver(__moxtet_driver) \
++	module_driver(__moxtet_driver, moxtet_register_driver, \
++			moxtet_unregister_driver)
++
++struct moxtet_device {
++	struct device			dev;
++	struct moxtet			*moxtet;
++	enum turris_mox_module_id	id;
++	unsigned int			idx;
++};
++
++extern int moxtet_device_read(struct device *dev);
++extern int moxtet_device_write(struct device *dev, u8 val);
++extern int moxtet_device_written(struct device *dev);
++
++static inline struct moxtet_device *
++to_moxtet_device(struct device *dev)
++{
++	if (!dev)
++		return NULL;
++	return container_of(dev, struct moxtet_device, dev);
++}
++
++#endif /* __LINUX_MFD_MOXTET_H */
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90116-drivers-gpio-Add-support-for-GPIOs-over-Moxtet-bus.patch b/target/linux/mvebu/patches-4.14/90116-drivers-gpio-Add-support-for-GPIOs-over-Moxtet-bus.patch
new file mode 100644
index 0000000..8004b05
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90116-drivers-gpio-Add-support-for-GPIOs-over-Moxtet-bus.patch
@@ -0,0 +1,280 @@
+From f38a007d4d31dafcb911b5d49f401d05dd9f3c76 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Wed, 8 Aug 2018 16:14:52 +0200
+Subject: [PATCH 116/126] drivers: gpio: Add support for GPIOs over Moxtet bus
+
+This adds support for interpreting the input and output bits of one
+device on Moxtet bus as GPIOs.
+This is needed for example by the SFP cage module of Turris Mox.
+
+Signed-off-by: Marek Behun <marek.behun@nic.cz>
+---
+ MAINTAINERS                |   1 +
+ drivers/gpio/Kconfig       |   9 ++
+ drivers/gpio/Makefile      |   1 +
+ drivers/gpio/gpio-moxtet.c | 209 +++++++++++++++++++++++++++++++++++++
+ 4 files changed, 220 insertions(+)
+ create mode 100644 drivers/gpio/gpio-moxtet.c
+
+diff --git a/MAINTAINERS b/MAINTAINERS
+index ab6dc27c14c9..155e88024387 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -1349,6 +1349,7 @@ M:	Marek Behun <marek.behun@nic.cz>
+ W:	http://mox.turris.cz
+ S:	Maintained
+ F:	include/mfd/moxtet.h
++F:	drivers/gpio/gpio-moxtet.c
+ F:	drivers/mfd/moxtet.c
+ 
+ ARM/EBSA110 MACHINE SUPPORT
+diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
+index 3f80f167ed56..798b7aff37a1 100644
+--- a/drivers/gpio/Kconfig
++++ b/drivers/gpio/Kconfig
+@@ -995,6 +995,15 @@ config GPIO_MAX77620
+ 	  driver also provides interrupt support for each of the gpios.
+ 	  Say yes here to enable the max77620 to be used as gpio controller.
+ 
++config GPIO_MOXTET
++	tristate "Turris Mox Moxtet bus GPIO expander"
++	depends on MFD_MOXTET
++	help
++	  Say yes here if you are building for the Turris Mox router.
++	  This is the driver needed for configuring the GPIOs via the Moxtet
++	  bus. For example the Mox module with SFP cage needs this driver
++	  so that phylink can use corresponding GPIOs.
++
+ config GPIO_MSIC
+ 	bool "Intel MSIC mixed signal gpio support"
+ 	depends on (X86 || COMPILE_TEST) && MFD_INTEL_MSIC
+diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
+index 8a2dfba3b231..0adfa2ea5be7 100644
+--- a/drivers/gpio/Makefile
++++ b/drivers/gpio/Makefile
+@@ -83,6 +83,7 @@ obj-$(CONFIG_GPIO_MC9S08DZ60)	+= gpio-mc9s08dz60.o
+ obj-$(CONFIG_GPIO_ML_IOH)	+= gpio-ml-ioh.o
+ obj-$(CONFIG_GPIO_MM_LANTIQ)	+= gpio-mm-lantiq.o
+ obj-$(CONFIG_GPIO_MOCKUP)      += gpio-mockup.o
++obj-$(CONFIG_GPIO_MOXTET)	+= gpio-moxtet.o
+ obj-$(CONFIG_GPIO_MPC5200)	+= gpio-mpc5200.o
+ obj-$(CONFIG_GPIO_MPC8XXX)	+= gpio-mpc8xxx.o
+ obj-$(CONFIG_GPIO_MSIC)		+= gpio-msic.o
+diff --git a/drivers/gpio/gpio-moxtet.c b/drivers/gpio/gpio-moxtet.c
+new file mode 100644
+index 000000000000..d0b50581118d
+--- /dev/null
++++ b/drivers/gpio/gpio-moxtet.c
+@@ -0,0 +1,209 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ *  Turris Mox Moxtet GPIO expander
++ *
++ *  Copyright (C) 2018 Marek Behun <marek.behun@nic.cz>
++ */
++
++#include <linux/gpio/consumer.h>
++#include <linux/gpio.h>
++#include <linux/mfd/moxtet.h>
++#include <linux/module.h>
++#include <linux/of_gpio.h>
++
++struct moxtet_gpio_chip {
++	struct device		*dev;
++	struct gpio_chip	gpio_chip;
++	u8			in_mask;
++	u8			out_mask;
++};
++
++static int moxtet_gpio_dir_mask(struct gpio_chip *gc, unsigned int offset,
++				int *dir, u8 *mask)
++{
++	struct moxtet_gpio_chip *chip = gpiochip_get_data(gc);
++	int i;
++
++	*dir = 0;
++	for (i = 0; i < 4; ++i) {
++		*mask = 1 << i;
++		if (*mask & chip->in_mask) {
++			if (offset == 0)
++				return 0;
++			--offset;
++		}
++	}
++
++	*dir = 1;
++	for (i = 0; i < 8; ++i) {
++		*mask = 1 << i;
++		if (*mask & chip->out_mask) {
++			if (offset == 0)
++				return 0;
++		}
++	}
++
++	return -EINVAL;
++}
++
++static int moxtet_gpio_get_value(struct gpio_chip *gc, unsigned int offset)
++{
++	struct moxtet_gpio_chip *chip = gpiochip_get_data(gc);
++	int ret, dir;
++	u8 mask;
++
++	if (moxtet_gpio_dir_mask(gc, offset, &dir, &mask) < 0)
++		return -EINVAL;
++
++	if (dir)
++		ret = moxtet_device_written(chip->dev);
++	else
++		ret = moxtet_device_read(chip->dev);
++
++	if (ret < 0)
++		return ret;
++
++	return (ret & mask) ? 1 : 0;
++}
++
++static void moxtet_gpio_set_value(struct gpio_chip *gc, unsigned int offset,
++				  int val)
++{
++	struct moxtet_gpio_chip *chip = gpiochip_get_data(gc);
++	int state, dir;
++	u8 mask;
++
++	if (moxtet_gpio_dir_mask(gc, offset, &dir, &mask) < 0)
++		return;
++
++	/* cannot change input GPIO */
++	if (!dir)
++		return;
++
++	state = moxtet_device_written(chip->dev);
++	if (state < 0)
++		return;
++
++	if (val)
++		state |= mask;
++	else
++		state &= ~mask;
++
++	moxtet_device_write(chip->dev, state);
++}
++
++static int moxtet_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)
++{
++	int dir;
++	u8 mask;
++
++	if (moxtet_gpio_dir_mask(gc, offset, &dir, &mask) < 0)
++		return -EINVAL;
++
++	return dir;
++}
++
++static int moxtet_gpio_direction_input(struct gpio_chip *gc,
++				       unsigned int offset)
++{
++	int dir;
++	u8 mask;
++
++	if (moxtet_gpio_dir_mask(gc, offset, &dir, &mask) < 0)
++		return -EINVAL;
++
++	if (dir)
++		return -EINVAL;
++
++	return 0;
++}
++
++static int moxtet_gpio_direction_output(struct gpio_chip *gc,
++					unsigned int offset, int val)
++{
++	int dir;
++	u8 mask;
++
++	if (moxtet_gpio_dir_mask(gc, offset, &dir, &mask) < 0)
++		return -EINVAL;
++
++	if (!dir)
++		return -EINVAL;
++
++	moxtet_gpio_set_value(gc, offset, val);
++	return 0;
++}
++
++static int moxtet_gpio_probe(struct device *dev)
++{
++	struct moxtet_gpio_chip *chip;
++	struct device_node *nc = dev->of_node;
++	int ret;
++	u32 val;
++
++	chip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);
++	if (!chip)
++		return -ENOMEM;
++
++	chip->dev = dev;
++	chip->gpio_chip.parent = dev;
++
++	ret = of_property_read_u32(nc, "moxtet,input-mask", &val);
++	if (ret < 0 || val > 0xf) {
++		dev_err(dev,
++			"%pOF has no valid 'moxtet,input-mask' property\n", nc);
++		return ret < 0 ? ret : -ERANGE;
++	}
++	chip->in_mask = val;
++
++	ret = of_property_read_u32(nc, "moxtet,output-mask", &val);
++	if (ret < 0 || val > 0xff) {
++		dev_err(dev,
++			"%pOF has no valid 'moxtet,output-mask' property\n",
++			nc);
++		return ret < 0 ? ret : -ERANGE;
++	}
++	chip->out_mask = val;
++
++	if (!chip->in_mask && !chip->out_mask) {
++		dev_err(dev, "%pOF has zero GPIOs defined\n", nc);
++		return -EINVAL;
++	}
++
++	dev_set_drvdata(dev, chip);
++
++	chip->gpio_chip.label = dev_name(dev);
++	chip->gpio_chip.get_direction = moxtet_gpio_get_direction;
++	chip->gpio_chip.direction_input = moxtet_gpio_direction_input;
++	chip->gpio_chip.direction_output = moxtet_gpio_direction_output;
++	chip->gpio_chip.get = moxtet_gpio_get_value;
++	chip->gpio_chip.set = moxtet_gpio_set_value;
++	chip->gpio_chip.base = -1;
++
++	chip->gpio_chip.ngpio = hweight8(chip->in_mask) +
++				hweight8(chip->out_mask);
++
++	chip->gpio_chip.can_sleep = true;
++	chip->gpio_chip.owner = THIS_MODULE;
++
++	return devm_gpiochip_add_data(dev, &chip->gpio_chip, chip);
++}
++
++static const struct of_device_id moxtet_gpio_dt_ids[] = {
++	{ .compatible = "cznic,moxtet-gpio" },
++	{},
++};
++MODULE_DEVICE_TABLE(of, moxtet_gpio_dt_ids);
++
++static struct moxtet_driver moxtet_gpio_driver = {
++	.driver = {
++		.name		= "moxtet-gpio",
++		.of_match_table	= moxtet_gpio_dt_ids,
++		.probe		= moxtet_gpio_probe,
++	},
++};
++module_moxtet_driver(moxtet_gpio_driver);
++
++MODULE_AUTHOR("Marek Behun <marek.behun@nic.cz>");
++MODULE_DESCRIPTION("Turris Mox Moxtet GPIO expander");
++MODULE_LICENSE("GPL v2");
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90117-watchdog-Add-support-for-Armada-37xx-CPU-watchdog.patch b/target/linux/mvebu/patches-4.14/90117-watchdog-Add-support-for-Armada-37xx-CPU-watchdog.patch
new file mode 100644
index 0000000..d2cf1e0
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90117-watchdog-Add-support-for-Armada-37xx-CPU-watchdog.patch
@@ -0,0 +1,461 @@
+From aff32743eabfb165e15b3a623e241cddeaa55ce3 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Sun, 2 Sep 2018 21:45:21 +0200
+Subject: [PATCH 117/126] watchdog: Add support for Armada 37xx CPU watchdog
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds support for the CPU watchdog found on Marvell Armada 37xx
+SoCs.
+
+There are 4 counters which can be set as CPU watchdog counters.
+This driver uses the second counter (ID 1, counting from 0) as watchdog
+counter, and first counter (ID 0) to implement pinging on the second
+counter without the need to disable it.
+
+Since counters IDs 2 and 3 are enabled already before even U-Boot
+starts, this driver does not use them at all, for example by adding a
+device tree property for counter selection.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+Reviewed-by: Guenter Roeck <linux@roeck-us.net>
+Tested-by: Miquel Raynal <miquel.raynal@bootlin.com>
+---
+ drivers/watchdog/Kconfig           |  11 +
+ drivers/watchdog/Makefile          |   1 +
+ drivers/watchdog/armada_37xx_wdt.c | 388 +++++++++++++++++++++++++++++
+ 3 files changed, 400 insertions(+)
+ create mode 100644 drivers/watchdog/armada_37xx_wdt.c
+
+diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
+index 3ece1335ba84..1deba6f2dece 100644
+--- a/drivers/watchdog/Kconfig
++++ b/drivers/watchdog/Kconfig
+@@ -255,6 +255,17 @@ config ARM_SBSA_WATCHDOG
+ 	  To compile this driver as module, choose M here: The module
+ 	  will be called sbsa_gwdt.
+ 
++config ARMADA_37XX_WATCHDOG
++	tristate "Armada 37xx watchdog"
++	depends on ARCH_MVEBU || COMPILE_TEST
++	select MFD_SYSCON
++	select WATCHDOG_CORE
++	help
++	   Say Y here to include support for the watchdog timer found on
++	   Marvell Armada 37xx SoCs.
++	   To compile this driver as a module, choose M here: the
++	   module will be called armada_37xx_wdt.
++
+ config ASM9260_WATCHDOG
+ 	tristate "Alphascale ASM9260 watchdog"
+ 	depends on MACH_ASM9260 || COMPILE_TEST
+diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
+index 715a21078e0c..eae72c5fa1e0 100644
+--- a/drivers/watchdog/Makefile
++++ b/drivers/watchdog/Makefile
+@@ -38,6 +38,7 @@ obj-$(CONFIG_USBPCWATCHDOG) += pcwd_usb.o
+ # ARM Architecture
+ obj-$(CONFIG_ARM_SP805_WATCHDOG) += sp805_wdt.o
+ obj-$(CONFIG_ARM_SBSA_WATCHDOG) += sbsa_gwdt.o
++obj-$(CONFIG_ARMADA_37XX_WATCHDOG) += armada_37xx_wdt.o
+ obj-$(CONFIG_ASM9260_WATCHDOG) += asm9260_wdt.o
+ obj-$(CONFIG_AT91RM9200_WATCHDOG) += at91rm9200_wdt.o
+ obj-$(CONFIG_AT91SAM9X_WATCHDOG) += at91sam9_wdt.o
+diff --git a/drivers/watchdog/armada_37xx_wdt.c b/drivers/watchdog/armada_37xx_wdt.c
+new file mode 100644
+index 000000000000..4b4054f54df9
+--- /dev/null
++++ b/drivers/watchdog/armada_37xx_wdt.c
+@@ -0,0 +1,388 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * Watchdog driver for Marvell Armada 37xx SoCs
++ *
++ * Author: Marek Behun <marek.behun@nic.cz>
++ */
++
++#include <linux/clk.h>
++#include <linux/err.h>
++#include <linux/interrupt.h>
++#include <linux/io.h>
++#include <linux/kernel.h>
++#include <linux/mfd/syscon.h>
++#include <linux/module.h>
++#include <linux/moduleparam.h>
++#include <linux/of.h>
++#include <linux/of_device.h>
++#include <linux/platform_device.h>
++#include <linux/regmap.h>
++#include <linux/types.h>
++#include <linux/watchdog.h>
++
++/*
++ * There are four counters that can be used for watchdog on Armada 37xx.
++ * The addresses for counter control registers are register base plus ID*0x10,
++ * where ID is 0, 1, 2 or 3.
++ *
++ * In this driver we use IDs 0 and 1. Counter ID 1 is used as watchdog counter,
++ * while counter ID 0 is used to implement pinging the watchdog: counter ID 1 is
++ * set to restart counting from initial value on counter ID 0 end count event.
++ * Pinging is done by forcing immediate end count event on counter ID 0.
++ * If only one counter was used, pinging would have to be implemented by
++ * disabling and enabling the counter, leaving the system in a vulnerable state
++ * for a (really) short period of time.
++ *
++ * Counters ID 2 and 3 are enabled by default even before U-Boot loads,
++ * therefore this driver does not provide a way to use them, eg. by setting a
++ * property in device tree.
++ */
++
++#define CNTR_ID_RETRIGGER		0
++#define CNTR_ID_WDOG			1
++
++/* relative to cpu_misc */
++#define WDT_TIMER_SELECT		0x64
++#define WDT_TIMER_SELECT_MASK		0xf
++#define WDT_TIMER_SELECT_VAL		BIT(CNTR_ID_WDOG)
++
++/* relative to reg */
++#define CNTR_CTRL(id)			((id) * 0x10)
++#define CNTR_CTRL_ENABLE		0x0001
++#define CNTR_CTRL_ACTIVE		0x0002
++#define CNTR_CTRL_MODE_MASK		0x000c
++#define CNTR_CTRL_MODE_ONESHOT		0x0000
++#define CNTR_CTRL_MODE_HWSIG		0x000c
++#define CNTR_CTRL_TRIG_SRC_MASK		0x00f0
++#define CNTR_CTRL_TRIG_SRC_PREV_CNTR	0x0050
++#define CNTR_CTRL_PRESCALE_MASK		0xff00
++#define CNTR_CTRL_PRESCALE_MIN		2
++#define CNTR_CTRL_PRESCALE_SHIFT	8
++
++#define CNTR_COUNT_LOW(id)		(CNTR_CTRL(id) + 0x4)
++#define CNTR_COUNT_HIGH(id)		(CNTR_CTRL(id) + 0x8)
++
++#define WATCHDOG_TIMEOUT		120
++
++static unsigned int timeout;
++module_param(timeout, int, 0);
++MODULE_PARM_DESC(timeout, "Watchdog timeout in seconds");
++
++static bool nowayout = WATCHDOG_NOWAYOUT;
++module_param(nowayout, bool, 0);
++MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default="
++			   __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
++
++struct armada_37xx_watchdog {
++	struct watchdog_device wdt;
++	struct regmap *cpu_misc;
++	void __iomem *reg;
++	u64 timeout; /* in clock ticks */
++	unsigned long clk_rate;
++	struct clk *clk;
++};
++
++static u64 get_counter_value(struct armada_37xx_watchdog *dev, int id)
++{
++	u64 val;
++
++	/*
++	 * when low is read, high is latched into flip-flops so that it can be
++	 * read consistently without using software debouncing
++	 */
++	val = readl(dev->reg + CNTR_COUNT_LOW(id));
++	val |= ((u64)readl(dev->reg + CNTR_COUNT_HIGH(id))) << 32;
++
++	return val;
++}
++
++static void set_counter_value(struct armada_37xx_watchdog *dev, int id, u64 val)
++{
++	writel(val & 0xffffffff, dev->reg + CNTR_COUNT_LOW(id));
++	writel(val >> 32, dev->reg + CNTR_COUNT_HIGH(id));
++}
++
++static void counter_enable(struct armada_37xx_watchdog *dev, int id)
++{
++	u32 reg;
++
++	reg = readl(dev->reg + CNTR_CTRL(id));
++	reg |= CNTR_CTRL_ENABLE;
++	writel(reg, dev->reg + CNTR_CTRL(id));
++}
++
++static void counter_disable(struct armada_37xx_watchdog *dev, int id)
++{
++	u32 reg;
++
++	reg = readl(dev->reg + CNTR_CTRL(id));
++	reg &= ~CNTR_CTRL_ENABLE;
++	writel(reg, dev->reg + CNTR_CTRL(id));
++}
++
++static void init_counter(struct armada_37xx_watchdog *dev, int id, u32 mode,
++			 u32 trig_src)
++{
++	u32 reg;
++
++	reg = readl(dev->reg + CNTR_CTRL(id));
++
++	reg &= ~(CNTR_CTRL_MODE_MASK | CNTR_CTRL_PRESCALE_MASK |
++		 CNTR_CTRL_TRIG_SRC_MASK);
++
++	/* set mode */
++	reg |= mode & CNTR_CTRL_MODE_MASK;
++
++	/* set prescaler to the min value */
++	reg |= CNTR_CTRL_PRESCALE_MIN << CNTR_CTRL_PRESCALE_SHIFT;
++
++	/* set trigger source */
++	reg |= trig_src & CNTR_CTRL_TRIG_SRC_MASK;
++
++	writel(reg, dev->reg + CNTR_CTRL(id));
++}
++
++static int armada_37xx_wdt_ping(struct watchdog_device *wdt)
++{
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++
++	/* counter 1 is retriggered by forcing end count on counter 0 */
++	counter_disable(dev, CNTR_ID_RETRIGGER);
++	counter_enable(dev, CNTR_ID_RETRIGGER);
++
++	return 0;
++}
++
++static unsigned int armada_37xx_wdt_get_timeleft(struct watchdog_device *wdt)
++{
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++	u64 res;
++
++	res = get_counter_value(dev, CNTR_ID_WDOG) * CNTR_CTRL_PRESCALE_MIN;
++	do_div(res, dev->clk_rate);
++
++	return res;
++}
++
++static int armada_37xx_wdt_set_timeout(struct watchdog_device *wdt,
++				       unsigned int timeout)
++{
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++
++	wdt->timeout = timeout;
++
++	/*
++	 * Compute the timeout in clock rate. We use smallest possible
++	 * prescaler, which divides the clock rate by 2
++	 * (CNTR_CTRL_PRESCALE_MIN).
++	 */
++	dev->timeout = (u64)dev->clk_rate * timeout;
++	do_div(dev->timeout, CNTR_CTRL_PRESCALE_MIN);
++
++	return 0;
++}
++
++static bool armada_37xx_wdt_is_running(struct armada_37xx_watchdog *dev)
++{
++	u32 reg;
++
++	regmap_read(dev->cpu_misc, WDT_TIMER_SELECT, &reg);
++	if ((reg & WDT_TIMER_SELECT_MASK) != WDT_TIMER_SELECT_VAL)
++		return false;
++
++	reg = readl(dev->reg + CNTR_CTRL(CNTR_ID_WDOG));
++	return !!(reg & CNTR_CTRL_ACTIVE);
++}
++
++static int armada_37xx_wdt_start(struct watchdog_device *wdt)
++{
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++
++	/* select counter 1 as watchdog counter */
++	regmap_write(dev->cpu_misc, WDT_TIMER_SELECT, WDT_TIMER_SELECT_VAL);
++
++	/* init counter 0 as retrigger counter for counter 1 */
++	init_counter(dev, CNTR_ID_RETRIGGER, CNTR_CTRL_MODE_ONESHOT, 0);
++	set_counter_value(dev, CNTR_ID_RETRIGGER, 0);
++
++	/* init counter 1 to be retriggerable by counter 0 end count */
++	init_counter(dev, CNTR_ID_WDOG, CNTR_CTRL_MODE_HWSIG,
++		     CNTR_CTRL_TRIG_SRC_PREV_CNTR);
++	set_counter_value(dev, CNTR_ID_WDOG, dev->timeout);
++
++	/* enable counter 1 */
++	counter_enable(dev, CNTR_ID_WDOG);
++
++	/* start counter 1 by forcing immediate end count on counter 0 */
++	counter_enable(dev, CNTR_ID_RETRIGGER);
++
++	return 0;
++}
++
++static int armada_37xx_wdt_stop(struct watchdog_device *wdt)
++{
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++
++	counter_disable(dev, CNTR_ID_WDOG);
++	counter_disable(dev, CNTR_ID_RETRIGGER);
++	regmap_write(dev->cpu_misc, WDT_TIMER_SELECT, 0);
++
++	return 0;
++}
++
++static const struct watchdog_info armada_37xx_wdt_info = {
++	.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,
++	.identity = "Armada 37xx Watchdog",
++};
++
++static const struct watchdog_ops armada_37xx_wdt_ops = {
++	.owner = THIS_MODULE,
++	.start = armada_37xx_wdt_start,
++	.stop = armada_37xx_wdt_stop,
++	.ping = armada_37xx_wdt_ping,
++	.set_timeout = armada_37xx_wdt_set_timeout,
++	.get_timeleft = armada_37xx_wdt_get_timeleft,
++};
++
++static int armada_37xx_wdt_probe(struct platform_device *pdev)
++{
++	struct armada_37xx_watchdog *dev;
++	struct resource *res;
++	struct regmap *regmap;
++	int ret;
++
++	dev = devm_kzalloc(&pdev->dev, sizeof(struct armada_37xx_watchdog),
++			   GFP_KERNEL);
++	if (!dev)
++		return -ENOMEM;
++
++	dev->wdt.info = &armada_37xx_wdt_info;
++	dev->wdt.ops = &armada_37xx_wdt_ops;
++
++	regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
++						 "marvell,system-controller");
++	if (IS_ERR(regmap))
++		return PTR_ERR(regmap);
++	dev->cpu_misc = regmap;
++
++	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++	if (!res)
++		return -ENODEV;
++	dev->reg = devm_ioremap(&pdev->dev, res->start, resource_size(res));
++
++	/* init clock */
++	dev->clk = devm_clk_get(&pdev->dev, NULL);
++	if (IS_ERR(dev->clk))
++		return PTR_ERR(dev->clk);
++
++	ret = clk_prepare_enable(dev->clk);
++	if (ret)
++		return ret;
++
++	dev->clk_rate = clk_get_rate(dev->clk);
++	if (!dev->clk_rate) {
++		ret = -EINVAL;
++		goto disable_clk;
++	}
++
++	/*
++	 * Since the timeout in seconds is given as 32 bit unsigned int, and
++	 * the counters hold 64 bit values, even after multiplication by clock
++	 * rate the counter can hold timeout of UINT_MAX seconds.
++	 */
++	dev->wdt.min_timeout = 1;
++	dev->wdt.max_timeout = UINT_MAX;
++	dev->wdt.parent = &pdev->dev;
++
++	/* default value, possibly override by module parameter or dtb */
++	dev->wdt.timeout = WATCHDOG_TIMEOUT;
++	watchdog_init_timeout(&dev->wdt, timeout, &pdev->dev);
++
++	platform_set_drvdata(pdev, &dev->wdt);
++	watchdog_set_drvdata(&dev->wdt, dev);
++
++	armada_37xx_wdt_set_timeout(&dev->wdt, dev->wdt.timeout);
++
++	if (armada_37xx_wdt_is_running(dev))
++		set_bit(WDOG_HW_RUNNING, &dev->wdt.status);
++
++	watchdog_set_nowayout(&dev->wdt, nowayout);
++	ret = watchdog_register_device(&dev->wdt);
++	if (ret)
++		goto disable_clk;
++
++	dev_info(&pdev->dev, "Initial timeout %d sec%s\n",
++		 dev->wdt.timeout, nowayout ? ", nowayout" : "");
++
++	return 0;
++
++disable_clk:
++	clk_disable_unprepare(dev->clk);
++	return ret;
++}
++
++static int armada_37xx_wdt_remove(struct platform_device *pdev)
++{
++	struct watchdog_device *wdt = platform_get_drvdata(pdev);
++	struct armada_37xx_watchdog *dev = watchdog_get_drvdata(wdt);
++
++	watchdog_unregister_device(wdt);
++	clk_disable_unprepare(dev->clk);
++	return 0;
++}
++
++static void armada_37xx_wdt_shutdown(struct platform_device *pdev)
++{
++	struct watchdog_device *wdt = platform_get_drvdata(pdev);
++
++	armada_37xx_wdt_stop(wdt);
++}
++
++static int __maybe_unused armada_37xx_wdt_suspend(struct device *dev)
++{
++	struct watchdog_device *wdt = dev_get_drvdata(dev);
++
++	return armada_37xx_wdt_stop(wdt);
++}
++
++static int __maybe_unused armada_37xx_wdt_resume(struct device *dev)
++{
++	struct watchdog_device *wdt = dev_get_drvdata(dev);
++
++	if (watchdog_active(wdt))
++		return armada_37xx_wdt_start(wdt);
++
++	return 0;
++}
++
++static const struct dev_pm_ops armada_37xx_wdt_dev_pm_ops = {
++	SET_SYSTEM_SLEEP_PM_OPS(armada_37xx_wdt_suspend,
++				armada_37xx_wdt_resume)
++};
++
++#ifdef CONFIG_OF
++static const struct of_device_id armada_37xx_wdt_match[] = {
++	{ .compatible = "marvell,armada-3700-wdt", },
++	{},
++};
++MODULE_DEVICE_TABLE(of, armada_37xx_wdt_match);
++#endif
++
++static struct platform_driver armada_37xx_wdt_driver = {
++	.probe		= armada_37xx_wdt_probe,
++	.remove		= armada_37xx_wdt_remove,
++	.shutdown	= armada_37xx_wdt_shutdown,
++	.driver		= {
++		.name	= "armada_37xx_wdt",
++		.of_match_table = of_match_ptr(armada_37xx_wdt_match),
++		.pm = &armada_37xx_wdt_dev_pm_ops,
++	},
++};
++
++module_platform_driver(armada_37xx_wdt_driver);
++
++MODULE_AUTHOR("Marek Behun <marek.behun@nic.cz>");
++MODULE_DESCRIPTION("Armada 37xx CPU Watchdog");
++
++MODULE_LICENSE("GPL v2");
++MODULE_ALIAS("platform:armada_37xx_wdt");
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90118-dt-bindings-watchdog-Document-armada-37xx-wdt-bindin.patch b/target/linux/mvebu/patches-4.14/90118-dt-bindings-watchdog-Document-armada-37xx-wdt-bindin.patch
new file mode 100644
index 0000000..0fe19ea
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90118-dt-bindings-watchdog-Document-armada-37xx-wdt-bindin.patch
@@ -0,0 +1,52 @@
+From 3d324b197a937ea27149f8e7808950ec2d7558dc Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Sun, 2 Sep 2018 21:49:24 +0200
+Subject: [PATCH 118/126] dt-bindings: watchdog: Document armada-37xx-wdt
+ binding
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds device tree binding documentation for the CPU watchdog found
+on Armada 37xx SOCs (EspressoBin, Turris Mox).
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+Cc: Rob Herring <robh+dt@kernel.org>
+Cc: devicetree@vger.kernel.org
+---
+ .../bindings/watchdog/armada-37xx-wdt.txt     | 23 +++++++++++++++++++
+ 1 file changed, 23 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/watchdog/armada-37xx-wdt.txt
+
+diff --git a/Documentation/devicetree/bindings/watchdog/armada-37xx-wdt.txt b/Documentation/devicetree/bindings/watchdog/armada-37xx-wdt.txt
+new file mode 100644
+index 000000000000..a8d00c31a1d8
+--- /dev/null
++++ b/Documentation/devicetree/bindings/watchdog/armada-37xx-wdt.txt
+@@ -0,0 +1,23 @@
++* Armada 37xx CPU Watchdog Timer Controller
++
++Required properties:
++- compatible : must be "marvell,armada-3700-wdt"
++- reg : base physical address of the controller and length of memory mapped
++	region.
++- clocks : the clock feeding the watchdog timer. See clock-bindings.txt
++- marvell,system-controller : reference to syscon node for the CPU Miscellaneous
++	Registers
++
++Example:
++
++	cpu_misc: system-controller@d000 {
++		compatible = "marvell,armada-3700-cpu-misc", "syscon";
++		reg = <0xd000 0x1000>;
++	};
++
++	wdt: watchdog@8300 {
++		compatible = "marvell,armada-3700-wdt";
++		reg = <0x8300 0x40>;
++		marvell,system-controller = <&cpu_misc>;
++		clocks = <&xtalclk>;
++	};
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90119-documentation-watchdog-add-documentation-for-armada-.patch b/target/linux/mvebu/patches-4.14/90119-documentation-watchdog-add-documentation-for-armada-.patch
new file mode 100644
index 0000000..d0eaf6c
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90119-documentation-watchdog-add-documentation-for-armada-.patch
@@ -0,0 +1,37 @@
+From 24003e346a2216b681081fd04a3326dd7b38a465 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Sun, 2 Sep 2018 21:53:00 +0200
+Subject: [PATCH 119/126] documentation: watchdog: add documentation for
+ armada-37xx-wdt
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add documentation for the kernel module parameters accepted by
+armada-37xx-wdt.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+Reviewed-by: Guenter Roeck <linux@roeck-us.net>
+---
+ Documentation/watchdog/watchdog-parameters.txt | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+diff --git a/Documentation/watchdog/watchdog-parameters.txt b/Documentation/watchdog/watchdog-parameters.txt
+index 6f9d7b418917..d322a907d231 100644
+--- a/Documentation/watchdog/watchdog-parameters.txt
++++ b/Documentation/watchdog/watchdog-parameters.txt
+@@ -45,6 +45,11 @@ timeout: Timeout value. Limited to be 1 or 2 seconds. (default=2)
+ nowayout: Watchdog cannot be stopped once started
+ 	(default=kernel config parameter)
+ -------------------------------------------------
++armada_37xx_wdt:
++timeout: Watchdog timeout in seconds. (default=120)
++nowayout: Disable watchdog shutdown on close
++	(default=kernel config parameter)
++-------------------------------------------------
+ at91rm9200_wdt:
+ wdt_time: Watchdog time in seconds. (default=5)
+ nowayout: Watchdog cannot be stopped once started
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90120-arm64-dts-marvell-armada-37xx-add-nodes-to-support-w.patch b/target/linux/mvebu/patches-4.14/90120-arm64-dts-marvell-armada-37xx-add-nodes-to-support-w.patch
new file mode 100644
index 0000000..7527bb0
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90120-arm64-dts-marvell-armada-37xx-add-nodes-to-support-w.patch
@@ -0,0 +1,44 @@
+From cd2c543d7c18dbd47844558330fc68f3cd280b36 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Sun, 2 Sep 2018 21:54:41 +0200
+Subject: [PATCH 120/126] arm64: dts: marvell: armada-37xx: add nodes to
+ support watchdog
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds the system controller node for CPU Miscellaneous Registers
+(which is needed for the watchdog node) and the watchdog node.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 13 +++++++++++++
+ 1 file changed, 13 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+index 783fbb7f3b47..70378339ab5b 100644
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -101,6 +101,19 @@
+ 			/* 32M internal register @ 0xd000_0000 */
+ 			ranges = <0x0 0x0 0xd0000000 0x2000000>;
+ 
++			wdt: watchdog@8300 {
++				compatible = "marvell,armada-3700-wdt";
++				reg = <0x8300 0x40>;
++				marvell,system-controller = <&cpu_misc>;
++				clocks = <&xtalclk>;
++			};
++
++			cpu_misc: system-controller@d000 {
++				compatible = "marvell,armada-3700-cpu-misc",
++					     "syscon";
++				reg = <0xd000 0x1000>;
++			};
++
+ 			spi0: spi@10600 {
+ 				compatible = "marvell,armada-3700-spi";
+ 				#address-cells = <1>;
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90121-PCI-aadrvark-warm-reset-the-cores-and-card.patch b/target/linux/mvebu/patches-4.14/90121-PCI-aadrvark-warm-reset-the-cores-and-card.patch
new file mode 100644
index 0000000..d0767bb
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90121-PCI-aadrvark-warm-reset-the-cores-and-card.patch
@@ -0,0 +1,121 @@
+From 96d797e5903817474c467140f2e01e9736934693 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Wed, 24 Oct 2018 16:55:11 +0200
+Subject: [PATCH 121/126] PCI: aadrvark: warm reset the cores and card
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Add code to do a warm reset on the PHY and PCIE cores and if PERSTN GPIO
+is specified in device tree (as reset-gpio), also reset the card.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ drivers/pci/host/pci-aardvark.c | 46 +++++++++++++++++++++++++++++++--
+ 1 file changed, 44 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/pci/host/pci-aardvark.c b/drivers/pci/host/pci-aardvark.c
+index 50e8addc22f9..ccce013bbef8 100644
+--- a/drivers/pci/host/pci-aardvark.c
++++ b/drivers/pci/host/pci-aardvark.c
+@@ -21,6 +21,7 @@
+ #include <linux/platform_device.h>
+ #include <linux/of_address.h>
+ #include <linux/of_pci.h>
++#include <linux/of_gpio.h>
+ 
+ /* PCIe core registers */
+ #define PCIE_CORE_CMD_STATUS_REG				0x4
+@@ -147,6 +148,9 @@
+ #define     CTRL_MODE_MASK			0x1
+ #define     PCIE_CORE_MODE_DIRECT		0x0
+ #define     PCIE_CORE_MODE_COMMAND		0x1
++#define CTRL_WARM_RESET_REG			(CTRL_CORE_BASE_ADDR + 0x4)
++#define     CTRL_PCIE_CORE_WARM_RESET		BIT(0)
++#define     CTRL_PHY_CORE_WARM_RESET		BIT(1)
+ 
+ /* PCIe Central Interrupts Registers */
+ #define CENTRAL_INT_BASE_ADDR			0x1b000
+@@ -270,8 +274,25 @@ static void advk_pcie_set_ob_win(struct advk_pcie *pcie,
+ 	advk_writel(pcie, match_ls | BIT(0), OB_WIN_MATCH_LS(win_num));
+ }
+ 
++static void advk_pcie_warm_reset(struct advk_pcie *pcie)
++{
++	u32 reg;
++
++	reg = advk_readl(pcie, CTRL_WARM_RESET_REG);
++	reg |= CTRL_PCIE_CORE_WARM_RESET | CTRL_PHY_CORE_WARM_RESET;
++	advk_writel(pcie, reg, CTRL_WARM_RESET_REG);
++
++	mdelay(100);
++
++	reg = advk_readl(pcie, CTRL_WARM_RESET_REG);
++	reg &= ~(CTRL_PCIE_CORE_WARM_RESET | CTRL_PHY_CORE_WARM_RESET);
++	advk_writel(pcie, reg, CTRL_WARM_RESET_REG);
++}
++
+ static void advk_pcie_setup_hw(struct advk_pcie *pcie)
+ {
++	struct device *dev = &pcie->pdev->dev;
++	struct device_node *node = dev->of_node;
+ 	u32 reg;
+ 	int i;
+ 
+@@ -311,10 +332,15 @@ static void advk_pcie_setup_hw(struct advk_pcie *pcie)
+ 		PCIE_CORE_CTRL2_TD_ENABLE;
+ 	advk_writel(pcie, reg, PCIE_CORE_CTRL2_REG);
+ 
+-	/* Set GEN2 */
++	/* Set GEN */
+ 	reg = advk_readl(pcie, PCIE_CORE_CTRL0_REG);
+ 	reg &= ~PCIE_GEN_SEL_MSK;
+-	reg |= SPEED_GEN_2;
++	if (of_pci_get_max_link_speed(node) == 1)
++		reg |= SPEED_GEN_1;
++	if (of_pci_get_max_link_speed(node) == 3)
++		reg |= SPEED_GEN_3;
++	else
++		reg |= SPEED_GEN_2;
+ 	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
+ 
+ 	/* Set lane X1 */
+@@ -948,6 +974,8 @@ static int advk_pcie_probe(struct platform_device *pdev)
+ 	struct pci_bus *bus, *child;
+ 	struct pci_host_bridge *bridge;
+ 	int ret, irq;
++	int reset_gpio;
++	enum of_gpio_flags flags;
+ 
+ 	bridge = devm_pci_alloc_host_bridge(dev, sizeof(struct advk_pcie));
+ 	if (!bridge)
+@@ -970,12 +998,26 @@ static int advk_pcie_probe(struct platform_device *pdev)
+ 		return ret;
+ 	}
+ 
++	advk_pcie_warm_reset(pcie);
++
+ 	ret = advk_pcie_parse_request_of_pci_ranges(pcie);
+ 	if (ret) {
+ 		dev_err(dev, "Failed to parse resources\n");
+ 		return ret;
+ 	}
+ 
++	/* Config reset gpio for pcie if there is valid gpio setting in DTS */
++	reset_gpio = of_get_named_gpio_flags(pdev->dev.of_node, "reset-gpio",
++					     0, &flags);
++	if (gpio_is_valid(reset_gpio)) {
++		struct gpio_desc *reset_gpiod;
++		reset_gpiod = gpio_to_desc(reset_gpio);
++		gpiod_direction_output(reset_gpiod, 0);
++		mdelay(200);
++		gpiod_direction_output(reset_gpiod, 1);
++		mdelay(200);
++	}
++
+ 	advk_pcie_setup_hw(pcie);
+ 
+ 	ret = advk_pcie_init_irq_domain(pcie);
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90122-mailbox-Add-support-for-Armada-37xx-rWTM-mailbox.patch b/target/linux/mvebu/patches-4.14/90122-mailbox-Add-support-for-Armada-37xx-rWTM-mailbox.patch
new file mode 100644
index 0000000..dbfc367
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90122-mailbox-Add-support-for-Armada-37xx-rWTM-mailbox.patch
@@ -0,0 +1,328 @@
+From 9d79a3d17da4a7a3a9ce2127a0ab9855e8b0ce63 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Mon, 26 Nov 2018 12:17:35 +0100
+Subject: [PATCH 122/126] mailbox: Add support for Armada 37xx rWTM mailbox
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds support for the mailbox via which the kernel can communicate
+with the firmware running on the secure processor of the Armada 37xx
+SOC.
+
+The rWTM secure processor has access to internal eFuses and
+cryptographic circuits, such as the Entropy Bit Generator to generate
+true random numbers.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ drivers/mailbox/Kconfig                    |  10 +
+ drivers/mailbox/Makefile                   |   2 +
+ drivers/mailbox/armada-37xx-rwtm-mailbox.c | 230 +++++++++++++++++++++
+ include/linux/armada-37xx-rwtm-mailbox.h   |  23 +++
+ 4 files changed, 265 insertions(+)
+ create mode 100644 drivers/mailbox/armada-37xx-rwtm-mailbox.c
+ create mode 100644 include/linux/armada-37xx-rwtm-mailbox.h
+
+diff --git a/drivers/mailbox/Kconfig b/drivers/mailbox/Kconfig
+index c5731e5e3c6c..6b0cfe37558f 100644
+--- a/drivers/mailbox/Kconfig
++++ b/drivers/mailbox/Kconfig
+@@ -35,6 +35,16 @@ config PL320_MBOX
+ 	  Management Engine, primarily for cpufreq. Say Y here if you want
+ 	  to use the PL320 IPCM support.
+ 
++config ARMADA_37XX_RWTM_MBOX
++	tristate "Armada 37xx rWTM BIU Mailbox"
++	depends on ARCH_MVEBU || COMPILE_TEST
++	depends on OF
++	help
++	  Mailbox implementation for communication with the the firmware
++	  running on the Cortex-M3 rWTM secure processor of the Armada 37xx
++	  SOC. Say Y here if you are building for such a device (for example
++	  the Turris Mox router).
++
+ config OMAP2PLUS_MBOX
+ 	tristate "OMAP2+ Mailbox framework support"
+ 	depends on ARCH_OMAP2PLUS
+diff --git a/drivers/mailbox/Makefile b/drivers/mailbox/Makefile
+index 4896f8dcae95..4aebeac2a6bd 100644
+--- a/drivers/mailbox/Makefile
++++ b/drivers/mailbox/Makefile
+@@ -7,6 +7,8 @@ obj-$(CONFIG_MAILBOX_TEST)	+= mailbox-test.o
+ 
+ obj-$(CONFIG_ARM_MHU)	+= arm_mhu.o
+ 
++obj-$(CONFIG_ARMADA_37XX_RWTM_MBOX)	+= armada-37xx-rwtm-mailbox.o
++
+ obj-$(CONFIG_PLATFORM_MHU)	+= platform_mhu.o
+ 
+ obj-$(CONFIG_PL320_MBOX)	+= pl320-ipc.o
+diff --git a/drivers/mailbox/armada-37xx-rwtm-mailbox.c b/drivers/mailbox/armada-37xx-rwtm-mailbox.c
+new file mode 100644
+index 000000000000..483a16d312cc
+--- /dev/null
++++ b/drivers/mailbox/armada-37xx-rwtm-mailbox.c
+@@ -0,0 +1,230 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * rWTM BIU Mailbox driver for Armada 37xx
++ *
++ * Author: Marek Behun <marek.behun@nic.cz>
++ */
++
++#include <linux/device.h>
++#include <linux/interrupt.h>
++#include <linux/io.h>
++#include <linux/kernel.h>
++#include <linux/mailbox_controller.h>
++#include <linux/module.h>
++#include <linux/of.h>
++#include <linux/platform_device.h>
++#include <linux/armada-37xx-rwtm-mailbox.h>
++
++#define DRIVER_NAME	"armada-37xx-rwtm-mailbox"
++
++/* relative to rWTM BIU Mailbox Registers */
++#define RWTM_MBOX_PARAM(i)		(0x0 + ((i) << 2))
++#define RWTM_MBOX_COMMAND		0x40
++#define RWTM_MBOX_RETURN_STATUS		0x80
++#define RWTM_MBOX_STATUS(i)		(0x84 + ((i) << 2))
++#define RWTM_MBOX_FIFO_STATUS		0xc4
++#define FIFO_STS_RDY			0x100
++#define FIFO_STS_CNTR_MASK		0x7
++#define FIFO_STS_CNTR_MAX		4
++
++#define RWTM_HOST_INT_RESET		0xc8
++#define RWTM_HOST_INT_MASK		0xcc
++#define SP_CMD_COMPLETE			BIT(0)
++#define SP_CMD_QUEUE_FULL_ACCESS	BIT(17)
++#define SP_CMD_QUEUE_FULL		BIT(18)
++
++
++struct a37xx_mbox {
++	struct device *dev;
++	struct mbox_controller controller;
++	void __iomem *base;
++	int irq;
++};
++
++static void a37xx_mbox_receive(struct mbox_chan *chan)
++{
++	struct a37xx_mbox *mbox = chan->con_priv;
++	struct armada_37xx_rwtm_rx_msg rx_msg;
++	int i;
++
++	rx_msg.retval = readl(mbox->base + RWTM_MBOX_RETURN_STATUS);
++	for (i = 0; i < 16; ++i)
++		rx_msg.status[i] = readl(mbox->base + RWTM_MBOX_STATUS(i));
++
++	mbox_chan_received_data(chan, &rx_msg);
++}
++
++static irqreturn_t a37xx_mbox_irq_handler(int irq, void *data)
++{
++	struct mbox_chan *chan = data;
++	struct a37xx_mbox *mbox = chan->con_priv;
++	u32 reg;
++
++	reg = readl(mbox->base + RWTM_HOST_INT_RESET);
++
++	if (reg & SP_CMD_COMPLETE)
++		a37xx_mbox_receive(chan);
++
++	if (reg & (SP_CMD_QUEUE_FULL_ACCESS | SP_CMD_QUEUE_FULL))
++		dev_err(mbox->dev, "Secure processor command queue full\n");
++
++	writel(reg, mbox->base + RWTM_HOST_INT_RESET);
++	if (reg)
++		mbox_chan_txdone(chan, 0);
++
++	return reg ? IRQ_HANDLED : IRQ_NONE;
++}
++
++static int a37xx_mbox_send_data(struct mbox_chan *chan, void *data)
++{
++	struct a37xx_mbox *mbox = chan->con_priv;
++	struct armada_37xx_rwtm_tx_msg *msg = data;
++	int i;
++	u32 reg;
++
++	if (!data)
++		return -EINVAL;
++
++	reg = readl(mbox->base + RWTM_MBOX_FIFO_STATUS);
++	if (!(reg & FIFO_STS_RDY)) {
++		dev_err(mbox->dev, "Secure processor not ready\n");
++		return -EAGAIN;
++	}
++
++	if ((reg & FIFO_STS_CNTR_MASK) >= FIFO_STS_CNTR_MAX) {
++		dev_err(mbox->dev, "Secure processor command queue full\n");
++		return -EBUSY;
++	}
++
++	for (i = 0; i < 16; ++i)
++		writel(msg->args[i], mbox->base + RWTM_MBOX_PARAM(i));
++	writel(msg->command, mbox->base + RWTM_MBOX_COMMAND);
++
++	return 0;
++}
++
++static int a37xx_mbox_startup(struct mbox_chan *chan)
++{
++	struct a37xx_mbox *mbox = chan->con_priv;
++	u32 reg;
++	int ret;
++
++	ret = devm_request_irq(mbox->dev, mbox->irq, a37xx_mbox_irq_handler, 0,
++			       DRIVER_NAME, chan);
++	if (ret < 0) {
++		dev_err(mbox->dev, "Cannot request irq\n");
++		return ret;
++	}
++
++	dev_info(mbox->dev, "Trust Status: %08x\n", readl(mbox->base + 0xd4));
++
++	/* enable IRQ generation */
++	reg = readl(mbox->base + RWTM_HOST_INT_MASK);
++	reg &= ~(SP_CMD_COMPLETE | SP_CMD_QUEUE_FULL_ACCESS | SP_CMD_QUEUE_FULL);
++	writel(reg, mbox->base + RWTM_HOST_INT_MASK);
++
++	return 0;
++}
++
++static void a37xx_mbox_shutdown(struct mbox_chan *chan)
++{
++	u32 reg;
++	struct a37xx_mbox *mbox = chan->con_priv;
++
++	/* disable interrupt generation */
++	reg = readl(mbox->base + RWTM_HOST_INT_MASK);
++	reg |= SP_CMD_COMPLETE | SP_CMD_QUEUE_FULL_ACCESS | SP_CMD_QUEUE_FULL;
++	writel(reg, mbox->base + RWTM_HOST_INT_MASK);
++
++	devm_free_irq(mbox->dev, mbox->irq, chan);
++}
++
++static const struct mbox_chan_ops a37xx_mbox_ops = {
++	.send_data	= a37xx_mbox_send_data,
++	.startup	= a37xx_mbox_startup,
++	.shutdown	= a37xx_mbox_shutdown,
++};
++
++static int armada_37xx_mbox_probe(struct platform_device *pdev)
++{
++	struct a37xx_mbox *mbox;
++	struct resource *regs;
++	struct mbox_chan *chans;
++	int ret;
++
++	mbox = devm_kzalloc(&pdev->dev, sizeof(*mbox), GFP_KERNEL);
++	if (!mbox)
++		return -ENOMEM;
++
++	/* Allocated one channel */
++	chans = devm_kzalloc(&pdev->dev, sizeof(*chans), GFP_KERNEL);
++	if (!chans)
++		return -ENOMEM;
++
++	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
++
++	mbox->base = devm_ioremap_resource(&pdev->dev, regs);
++	if (IS_ERR(mbox->base)) {
++		dev_err(&pdev->dev, "ioremap failed\n");
++		return PTR_ERR(mbox->base);
++	}
++
++	mbox->irq = platform_get_irq(pdev, 0);
++	if (mbox->irq < 0) {
++		dev_err(&pdev->dev, "Cannot get irq\n");
++		return mbox->irq;
++	}
++
++	mbox->dev = &pdev->dev;
++
++	/* Hardware supports only one channel. */
++	chans[0].con_priv = mbox;
++	mbox->controller.dev = mbox->dev;
++	mbox->controller.num_chans = 1;
++	mbox->controller.chans = chans;
++	mbox->controller.ops = &a37xx_mbox_ops;
++	mbox->controller.txdone_irq = true;
++
++	ret = mbox_controller_register(&mbox->controller);
++	if (ret) {
++		dev_err(&pdev->dev, "Could not register mailbox controller\n");
++		return ret;
++	}
++
++	platform_set_drvdata(pdev, mbox);
++	return ret;
++}
++
++static int armada_37xx_mbox_remove(struct platform_device *pdev)
++{
++	struct a37xx_mbox *mbox = platform_get_drvdata(pdev);
++
++	if (!mbox)
++		return -EINVAL;
++
++	mbox_controller_unregister(&mbox->controller);
++
++	return 0;
++}
++
++static const struct of_device_id armada_37xx_mbox_match[] = {
++	{ .compatible = "marvell,armada-37xx-rwtm-mailbox" },
++	{ },
++};
++
++MODULE_DEVICE_TABLE(of, armada_37xx_mbox_match);
++
++static struct platform_driver armada_37xx_mbox_driver = {
++	.probe	= armada_37xx_mbox_probe,
++	.remove	= armada_37xx_mbox_remove,
++	.driver	= {
++		.name		= DRIVER_NAME,
++		.of_match_table	= armada_37xx_mbox_match,
++	},
++};
++
++module_platform_driver(armada_37xx_mbox_driver);
++
++MODULE_LICENSE("GPL v2");
++MODULE_DESCRIPTION("rWTM BIU Mailbox driver for Armada 37xx");
++MODULE_AUTHOR("Marek Behun <marek.behun@nic.cz>");
+diff --git a/include/linux/armada-37xx-rwtm-mailbox.h b/include/linux/armada-37xx-rwtm-mailbox.h
+new file mode 100644
+index 000000000000..57bb54f6767a
+--- /dev/null
++++ b/include/linux/armada-37xx-rwtm-mailbox.h
+@@ -0,0 +1,23 @@
++/* SPDX-License-Identifier: GPL-2.0+ */
++/*
++ * rWTM BIU Mailbox driver for Armada 37xx
++ *
++ * Author: Marek Behun <marek.behun@nic.cz>
++ */
++
++#ifndef _LINUX_ARMADA_37XX_RWTM_MAILBOX_H_
++#define _LINUX_ARMADA_37XX_RWTM_MAILBOX_H_
++
++#include <linux/types.h>
++
++struct armada_37xx_rwtm_tx_msg {
++	u16 command;
++	u32 args[16];
++};
++
++struct armada_37xx_rwtm_rx_msg {
++	u32 retval;
++	u32 status[16];
++};
++
++#endif /* _LINUX_ARMADA_37XX_RWTM_MAILBOX_H_ */
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90123-arm64-dts-marvell-armada37xx-add-rWTM-mailbox-node.patch b/target/linux/mvebu/patches-4.14/90123-arm64-dts-marvell-armada37xx-add-rWTM-mailbox-node.patch
new file mode 100644
index 0000000..c065b66
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90123-arm64-dts-marvell-armada37xx-add-rWTM-mailbox-node.patch
@@ -0,0 +1,38 @@
+From a29a9e62c9bad5b868f78e4ee80292abcc40c76a Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Mon, 26 Nov 2018 12:21:44 +0100
+Subject: [PATCH 123/126] arm64: dts: marvell: armada37xx: add rWTM mailbox
+ node
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds node for the rWTM mailbox. rWTM is a Cortex-M3 processor on
+the Armada 37xx SOC used for security purposes.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+index 70378339ab5b..72b38abbff31 100644
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -335,6 +335,13 @@
+ 				clocks = <&nb_periph_clk 15>;
+ 			};
+ 
++			rwtm: mailbox@b0000 {
++				compatible = "marvell,armada-37xx-rwtm-mailbox";
++				reg = <0xb0000 0x100>;
++				interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>;
++				#mbox-cells = <1>;
++			};
++
+ 			sdhci1: sdhci@d0000 {
+ 				compatible = "marvell,armada-3700-sdhci",
+ 					     "marvell,sdhci-xenon";
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90124-crypto-Add-Turris-Mox-rWTM-firmware-driver.patch b/target/linux/mvebu/patches-4.14/90124-crypto-Add-Turris-Mox-rWTM-firmware-driver.patch
new file mode 100644
index 0000000..b606460
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90124-crypto-Add-Turris-Mox-rWTM-firmware-driver.patch
@@ -0,0 +1,454 @@
+From 30ed67c5a721bd7c0967a6fee472d14fb056d306 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Mon, 26 Nov 2018 12:23:05 +0100
+Subject: [PATCH 124/126] crypto: Add Turris Mox rWTM firmware driver
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds a driver to communicate with the firmware running on the
+secure processor of the Turris Mox router, enabling the kernel to
+retrieve true random numbers from the Entropy Bit Generator and to
+sign messages with the ECDSA private key burned into each Turris Mox
+device.
+
+This also adds support to read the device serial number and other
+manufacturing information.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ drivers/crypto/Kconfig           |  15 ++
+ drivers/crypto/Makefile          |   1 +
+ drivers/crypto/turris-mox-rwtm.c | 382 +++++++++++++++++++++++++++++++
+ 3 files changed, 398 insertions(+)
+ create mode 100644 drivers/crypto/turris-mox-rwtm.c
+
+diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
+index 342bc777841c..c57ca4b00103 100644
+--- a/drivers/crypto/Kconfig
++++ b/drivers/crypto/Kconfig
+@@ -709,6 +709,21 @@ config CRYPTO_DEV_SAFEXCEL
+ 	  chain mode, AES cipher mode and SHA1/SHA224/SHA256/SHA512 hash
+ 	  algorithms.
+ 
++config CRYPTO_DEV_TURRIS_MOX_RWTM
++	tristate "Turris Mox rWTM secure firmware driver"
++	depends on HAS_DMA && OF
++	depends on MAILBOX
++	select HW_RANDOM
++	select CRYPTO_AKCIPHER
++	select ARMADA_37XX_RWTM_MBOX
++	help
++	  This driver communicates with the firmware on the Cortex-M3 secure
++	  processor of the Turris Mox router. Enable if you are building for
++	  Turris Mox, and you will be able to read the serial number and
++	  other manufacturing data, sign messages with the internal ECDSA-521
++	  private key and utilize the Entropy Bit Generator as hardware random
++	  number generator.
++
+ config CRYPTO_DEV_ARTPEC6
+ 	tristate "Support for Axis ARTPEC-6/7 hardware crypto acceleration."
+ 	depends on ARM && (ARCH_ARTPEC || COMPILE_TEST)
+diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
+index c00708d04be6..7d3dde966e2d 100644
+--- a/drivers/crypto/Makefile
++++ b/drivers/crypto/Makefile
+@@ -40,6 +40,7 @@ obj-$(CONFIG_CRYPTO_DEV_SAHARA) += sahara.o
+ obj-$(CONFIG_ARCH_STM32) += stm32/
+ obj-$(CONFIG_CRYPTO_DEV_SUN4I_SS) += sunxi-ss/
+ obj-$(CONFIG_CRYPTO_DEV_TALITOS) += talitos.o
++obj-$(CONFIG_CRYPTO_DEV_TURRIS_MOX_RWTM) += turris-mox-rwtm.o
+ obj-$(CONFIG_CRYPTO_DEV_UX500) += ux500/
+ obj-$(CONFIG_CRYPTO_DEV_VIRTIO) += virtio/
+ obj-$(CONFIG_CRYPTO_DEV_VMX) += vmx/
+diff --git a/drivers/crypto/turris-mox-rwtm.c b/drivers/crypto/turris-mox-rwtm.c
+new file mode 100644
+index 000000000000..212337293b38
+--- /dev/null
++++ b/drivers/crypto/turris-mox-rwtm.c
+@@ -0,0 +1,382 @@
++// SPDX-License-Identifier: GPL-2.0+
++/*
++ * Turris Mox rWTM firmware driver
++ *
++ * Author: Marek Behun <marek.behun@nic.cz>
++ */
++
++#include <linux/armada-37xx-rwtm-mailbox.h>
++#include <linux/completion.h>
++#include <linux/dma-mapping.h>
++#include <linux/hw_random.h>
++#include <linux/mailbox_client.h>
++#include <linux/module.h>
++#include <linux/mutex.h>
++#include <linux/of.h>
++#include <linux/platform_device.h>
++
++#define DRIVER_NAME		"turris-mox-rwtm"
++
++#define MBOX_STS_SUCCESS	(0 << 30)
++#define MBOX_STS_FAIL		(1 << 30)
++#define MBOX_STS_BADCMD		(2 << 30)
++#define MBOX_STS_ERROR(s)	((s) & (3 << 30))
++#define MBOX_STS_VALUE(s)	(((s) >> 10) & 0xfffff)
++#define MBOX_STS_CMD(s)		((s) & 0x3ff)
++
++enum mbox_cmd {
++	MBOX_CMD_GET_RANDOM	= 1,
++	MBOX_CMD_BOARD_INFO,
++	MBOX_CMD_ECDSA_PUB_KEY,
++	MBOX_CMD_HASH,
++	MBOX_CMD_SIGN,
++	MBOX_CMD_VERIFY,
++
++	MBOX_CMD_OTP_READ,
++	MBOX_CMD_OTP_WRITE
++};
++
++struct mox_rwtm {
++	struct device *dev;
++	void *buf;
++	dma_addr_t buf_phys;
++	struct mbox_client mbox_client;
++	struct mbox_chan *mbox;
++	struct mutex busy;
++	struct completion cmd_done;
++	struct armada_37xx_rwtm_rx_msg reply;
++	struct hwrng hwrng;
++
++	/* board information */
++	u64 serial_number;
++	int board_version, ram_size;
++	u8 mac_address1[6], mac_address2[6];
++	u8 pubkey[135];
++	u8 last_sig[136];
++	int last_sig_done;
++};
++
++#define MOX_ATTR(name, format)						\
++static ssize_t								\
++mox_##name##_show(struct device *dev, struct device_attribute *a,	\
++		  char *buf)						\
++{									\
++	struct mox_rwtm *rwtm = dev_get_drvdata(dev);			\
++	return sprintf(buf, format, rwtm->name);			\
++}									\
++static DEVICE_ATTR_RO(mox_##name);
++
++MOX_ATTR(serial_number, "%016llX\n");
++MOX_ATTR(board_version, "%i\n");
++MOX_ATTR(ram_size, "%i\n");
++MOX_ATTR(mac_address1, "%pM\n");
++MOX_ATTR(mac_address2, "%pM\n");
++MOX_ATTR(pubkey, "%s\n");
++
++static ssize_t
++mox_do_sign_show(struct device *dev, struct device_attribute *a, char *buf)
++{
++	struct mox_rwtm *rwtm = dev_get_drvdata(dev);
++
++	if (!rwtm->last_sig_done)
++		return -ENODATA;
++
++	rwtm->last_sig_done = 0;
++	memcpy(buf, rwtm->last_sig, 136);
++	return 136;
++}
++
++static void be32_to_cpu_array(u32 *buf, int n)
++{
++	for (; n > 0; --n, ++buf)
++		*buf = be32_to_cpu(*buf);
++}
++
++static void cpu_to_be32_array(u32 *buf, int n)
++{
++	for (; n > 0; --n, ++buf)
++		*buf = cpu_to_be32(*buf);
++}
++
++static ssize_t
++mox_do_sign_store(struct device *dev, struct device_attribute *a,
++		  const char *buf, size_t count)
++{
++	struct mox_rwtm *rwtm = dev_get_drvdata(dev);
++	struct armada_37xx_rwtm_rx_msg *reply = &rwtm->reply;
++	struct armada_37xx_rwtm_tx_msg msg;
++	int ret;
++
++	if (count != 64)
++		return -EINVAL;
++
++	if (rwtm->last_sig_done)
++		return -EBUSY;
++
++	if (!mutex_trylock(&rwtm->busy))
++		return -EBUSY;
++
++	memset(rwtm->buf, 0, 4);
++	memcpy(rwtm->buf + 4, buf, 64);
++	be32_to_cpu_array(rwtm->buf, 17);
++
++	msg.command = MBOX_CMD_SIGN;
++	msg.args[0] = 1;
++	msg.args[1] = rwtm->buf_phys;
++	msg.args[2] = rwtm->buf_phys + 68;
++	msg.args[3] = rwtm->buf_phys + 2 * 68;
++	ret = mbox_send_message(rwtm->mbox, &msg);
++	if (ret < 0)
++		goto unlock_mutex;
++
++	ret = wait_for_completion_interruptible(&rwtm->cmd_done);
++	if (ret < 0)
++		goto unlock_mutex;
++
++	ret = MBOX_STS_VALUE(reply->retval);
++	if (MBOX_STS_ERROR(reply->retval) != MBOX_STS_SUCCESS)
++		goto unlock_mutex;
++
++	memcpy(rwtm->last_sig, rwtm->buf + 68, 136);
++	cpu_to_be32_array((u32 *) rwtm->last_sig, 34);
++	rwtm->last_sig_done = 1;
++
++	mutex_unlock(&rwtm->busy);
++	return count;
++unlock_mutex:
++	mutex_unlock(&rwtm->busy);
++	return ret;
++}
++
++static DEVICE_ATTR_RW(mox_do_sign);
++
++static struct attribute *mox_rwtm_attrs[] = {
++	&dev_attr_mox_serial_number.attr,
++	&dev_attr_mox_board_version.attr,
++	&dev_attr_mox_ram_size.attr,
++	&dev_attr_mox_mac_address1.attr,
++	&dev_attr_mox_mac_address2.attr,
++	&dev_attr_mox_pubkey.attr,
++	&dev_attr_mox_do_sign.attr,
++	NULL
++};
++ATTRIBUTE_GROUPS(mox_rwtm);
++
++static void mox_rwtm_rx_callback(struct mbox_client *cl, void *data)
++{
++	struct mox_rwtm *rwtm = dev_get_drvdata(cl->dev);
++	struct armada_37xx_rwtm_rx_msg *msg = data;
++
++	rwtm->reply = *msg;
++	complete(&rwtm->cmd_done);
++}
++
++static int mox_get_status(enum mbox_cmd cmd, u32 retval)
++{
++	if (MBOX_STS_CMD(retval) != cmd ||
++	    MBOX_STS_ERROR(retval) != MBOX_STS_SUCCESS)
++		return -EIO;
++	else if (MBOX_STS_ERROR(retval) == MBOX_STS_FAIL)
++		return -(int)MBOX_STS_VALUE(retval);
++	else
++		return MBOX_STS_VALUE(retval);
++}
++
++static void reply_to_mac(u8 *mac, u32 t1, u32 t2)
++{
++	mac[0] = t1 >> 8;
++	mac[1] = t1;
++	mac[2] = t2 >> 24;
++	mac[3] = t2 >> 16;
++	mac[4] = t2 >> 8;
++	mac[5] = t2;
++}
++
++static int mox_board_info(struct mox_rwtm *rwtm)
++{
++	struct armada_37xx_rwtm_tx_msg msg;
++	struct armada_37xx_rwtm_rx_msg *reply = &rwtm->reply;
++	int ret;
++
++	msg.command = MBOX_CMD_BOARD_INFO;
++	ret = mbox_send_message(rwtm->mbox, &msg);
++	if (ret < 0)
++		return ret;
++
++	ret = wait_for_completion_timeout(&rwtm->cmd_done, HZ / 2);
++	if (ret < 0)
++		return ret;
++
++	ret = mox_get_status(MBOX_CMD_BOARD_INFO, reply->retval);
++	if (ret < 0)
++		return ret;
++
++	rwtm->serial_number = reply->status[1];
++	rwtm->serial_number <<= 32;
++	rwtm->serial_number |= reply->status[0];
++	rwtm->board_version = reply->status[2];
++	rwtm->ram_size = reply->status[3];
++	reply_to_mac(rwtm->mac_address1, reply->status[4], reply->status[5]);
++	reply_to_mac(rwtm->mac_address2, reply->status[6], reply->status[7]);
++
++	pr_info("Turris Mox serial number %016llX\n", rwtm->serial_number);
++	pr_info("           board version %i\n", rwtm->board_version);
++	pr_info("           burned RAM size %i MiB\n", rwtm->ram_size);
++
++	msg.command = MBOX_CMD_ECDSA_PUB_KEY;
++	ret = mbox_send_message(rwtm->mbox, &msg);
++	if (ret < 0)
++		return ret;
++
++	ret = wait_for_completion_timeout(&rwtm->cmd_done, HZ / 2);
++	if (ret < 0)
++		return ret;
++
++	ret = mox_get_status(MBOX_CMD_ECDSA_PUB_KEY, reply->retval);
++	if (ret < 0 && ret != -ENODATA) {
++		return ret;
++	} else if (ret == -ENODATA) {
++		strcpy(rwtm->pubkey, "none");
++	} else {
++		u32 *s = reply->status;
++		sprintf(rwtm->pubkey,
++			"%06x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x",
++			ret, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],
++			s[8], s[9], s[10], s[11], s[12], s[13], s[14], s[15]);
++	}
++
++	return 0;
++}
++
++static int mox_hwrng_read(struct hwrng *rng, void *data, size_t max, bool wait)
++{
++	struct mox_rwtm *rwtm = (struct mox_rwtm *) rng->priv;
++	struct armada_37xx_rwtm_tx_msg msg;
++	int ret;
++
++	if (max > 4096)
++		max = 4096;
++
++	msg.command = MBOX_CMD_GET_RANDOM;
++	msg.args[0] = 1;
++	msg.args[1] = rwtm->buf_phys;
++	msg.args[2] = (max + 3) & ~3;
++
++	if (!wait) {
++		if (!mutex_trylock(&rwtm->busy))
++			return -EBUSY;
++	} else {
++		mutex_lock(&rwtm->busy);
++	}
++
++	ret = mbox_send_message(rwtm->mbox, &msg);
++	if (ret < 0)
++		goto unlock_mutex;
++
++	ret = wait_for_completion_interruptible(&rwtm->cmd_done);
++	if (ret < 0)
++		goto unlock_mutex;
++
++	ret = mox_get_status(MBOX_CMD_GET_RANDOM, rwtm->reply.retval);
++	if (ret < 0)
++		goto unlock_mutex;
++
++	memcpy(data, rwtm->buf, max);
++	ret = max;
++
++unlock_mutex:
++	mutex_unlock(&rwtm->busy);
++	return ret;
++}
++
++static int turris_mox_rwtm_probe(struct platform_device *pdev)
++{
++	struct mox_rwtm *rwtm;
++	struct device *dev = &pdev->dev;
++	int ret;
++
++	rwtm = devm_kzalloc(dev, sizeof(*rwtm), GFP_KERNEL);
++	if (!rwtm)
++		return -ENOMEM;
++
++	rwtm->dev = dev;
++	rwtm->buf = dmam_alloc_coherent(dev, PAGE_SIZE, &rwtm->buf_phys,
++					GFP_KERNEL);
++	if (!rwtm->buf)
++		return -ENOMEM;
++
++	ret = devm_device_add_groups(dev, mox_rwtm_groups);
++	if (ret < 0)
++		return ret;
++
++	platform_set_drvdata(pdev, rwtm);
++
++	mutex_init(&rwtm->busy);
++
++	rwtm->mbox_client.dev = dev;
++	rwtm->mbox_client.rx_callback = mox_rwtm_rx_callback;
++
++	rwtm->mbox = mbox_request_channel(&rwtm->mbox_client, 0);
++	if (IS_ERR(rwtm->mbox)) {
++		ret = PTR_ERR(rwtm->mbox);
++		if (ret != -EPROBE_DEFER)
++			dev_err(dev, "Cannot request mailbox channel: %i\n",
++				ret);
++		return ret;
++	}
++
++	init_completion(&rwtm->cmd_done);
++
++	ret = mox_board_info(rwtm);
++	if (ret < 0) {
++		dev_err(dev, "Cannot read board information!\n");
++		goto free_channel;
++	}
++
++	rwtm->hwrng.name = DRIVER_NAME "_hwrng";
++	rwtm->hwrng.read = mox_hwrng_read;
++	rwtm->hwrng.priv = (unsigned long) rwtm;
++	rwtm->hwrng.quality = 1024;
++
++	ret = devm_hwrng_register(dev, &rwtm->hwrng);
++	if (ret < 0) {
++		dev_err(dev, "Cannot register HWRNG: %i\n", ret);
++		goto free_channel;
++	}
++
++	return 0;
++
++free_channel:
++	mbox_free_channel(rwtm->mbox);
++	return ret;
++}
++
++static int turris_mox_rwtm_remove(struct platform_device *pdev)
++{
++	struct mox_rwtm *rwtm = platform_get_drvdata(pdev);
++
++	mbox_free_channel(rwtm->mbox);
++
++	return 0;
++}
++
++static const struct of_device_id turris_mox_rwtm_match[] = {
++	{ .compatible = "cznic,turris-mox-rwtm", },
++	{ },
++};
++
++MODULE_DEVICE_TABLE(of, turris_mox_rwtm_match);
++
++static struct platform_driver turris_mox_rwtm_driver = {
++	.probe	= turris_mox_rwtm_probe,
++	.remove	= turris_mox_rwtm_remove,
++	.driver	= {
++		.name		= DRIVER_NAME,
++		.of_match_table	= turris_mox_rwtm_match,
++	},
++};
++module_platform_driver(turris_mox_rwtm_driver);
++
++MODULE_LICENSE("GPL v2");
++MODULE_DESCRIPTION("Turris Mox rWTM firmware driver");
++MODULE_AUTHOR("Marek Behun <marek.behun@nic.cz>");
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/90125-ARM64-dts-marvell-Add-DTS-file-for-Turris-Mox.patch b/target/linux/mvebu/patches-4.14/90125-ARM64-dts-marvell-Add-DTS-file-for-Turris-Mox.patch
new file mode 100644
index 0000000..785206a
--- /dev/null
+++ b/target/linux/mvebu/patches-4.14/90125-ARM64-dts-marvell-Add-DTS-file-for-Turris-Mox.patch
@@ -0,0 +1,931 @@
+From 49ba023db8bed0af25f2fb6b8d0ccd8e1e310610 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
+Date: Wed, 24 Oct 2018 17:01:12 +0200
+Subject: [PATCH 125/126] ARM64: dts: marvell: Add DTS file for Turris Mox
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds basic support for the Turris Mox board from CZ.NIC.
+
+Turris Mox is a modular router based on the Armada 3720 SOC (same as
+EspressoBin).
+
+The basic module can be extended by different modules.
+When those modules are connected, U-Boot shall patch this basic
+device-tree with nodes corresponding to those modules.
+
+Signed-off-by: Marek Behún <marek.behun@nic.cz>
+---
+ .../arm/marvell/armada-3720-turris-mox.txt    |   6 +
+ MAINTAINERS                                   |   1 +
+ arch/arm64/boot/dts/marvell/Makefile          |   1 +
+ .../dts/marvell/armada-3720-turris-mox.dts    | 859 ++++++++++++++++++
+ 4 files changed, 867 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/arm/marvell/armada-3720-turris-mox.txt
+ create mode 100644 arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
+
+diff --git a/Documentation/devicetree/bindings/arm/marvell/armada-3720-turris-mox.txt b/Documentation/devicetree/bindings/arm/marvell/armada-3720-turris-mox.txt
+new file mode 100644
+index 000000000000..408fc07a9bbf
+--- /dev/null
++++ b/Documentation/devicetree/bindings/arm/marvell/armada-3720-turris-mox.txt
+@@ -0,0 +1,6 @@
++CZ.NIC's Turris Mox SOHO router Device Tree Bindings
++----------------------------------------------------
++
++Required root node property:
++
++compatible: must contain "cznic,turris-mox"
+diff --git a/MAINTAINERS b/MAINTAINERS
+index 155e88024387..791f306df34c 100644
+--- a/MAINTAINERS
++++ b/MAINTAINERS
+@@ -1348,6 +1348,7 @@ ARM/CZ.NIC TURRIS MOX SUPPORT
+ M:	Marek Behun <marek.behun@nic.cz>
+ W:	http://mox.turris.cz
+ S:	Maintained
++F:	arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
+ F:	include/mfd/moxtet.h
+ F:	drivers/gpio/gpio-moxtet.c
+ F:	drivers/mfd/moxtet.c
+diff --git a/arch/arm64/boot/dts/marvell/Makefile b/arch/arm64/boot/dts/marvell/Makefile
+index 5633676fa9d0..51782b31b441 100644
+--- a/arch/arm64/boot/dts/marvell/Makefile
++++ b/arch/arm64/boot/dts/marvell/Makefile
+@@ -6,6 +6,7 @@ dtb-$(CONFIG_ARCH_BERLIN) += berlin4ct-stb.dtb
+ # Mvebu SoC Family
+ dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-db.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-espressobin.dtb
++dtb-$(CONFIG_ARCH_MVEBU) += armada-3720-turris-mox.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += armada-7040-db.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += armada-8040-db.dtb
+ dtb-$(CONFIG_ARCH_MVEBU) += armada-8040-mcbin.dtb
+diff --git a/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
+new file mode 100644
+index 000000000000..f397be1c4244
+--- /dev/null
++++ b/arch/arm64/boot/dts/marvell/armada-3720-turris-mox.dts
+@@ -0,0 +1,859 @@
++// SPDX-License-Identifier: GPL-2.0+ or X11
++/*
++ * Device Tree file for CZ.NIC Turris Mox Board
++ * 2018 by Marek Behun <marek.behun@nic.cz>
++ */
++
++/dts-v1/;
++
++#include <dt-bindings/gpio/gpio.h>
++#include <dt-bindings/input/input.h>
++#include "armada-372x.dtsi"
++
++/ {
++	model = "CZ.NIC Turris Mox Board";
++	compatible = "cznic,turris-mox", "marvell,armada3720",
++		     "marvell,armada3710";
++
++	aliases {
++		spi0 = &spi0;
++		ethernet1 = &eth1;
++	};
++
++	chosen {
++		stdout-path = "serial0:115200n8";
++	};
++
++	memory@0 {
++		device_type = "memory";
++		reg = <0x00000000 0x00000000 0x00000000 0x20000000>;
++	};
++
++	leds {
++		compatible = "gpio-leds";
++		red {
++			gpios = <&gpiosb 21 GPIO_ACTIVE_LOW>;
++			linux,default-trigger = "default-on";
++		};
++	};
++
++	gpio-keys {
++		compatible = "gpio-keys";
++
++		reset-button {
++			label = "reset";
++			linux,code = <BTN_MISC>;
++			gpios = <&gpiosb 20 GPIO_ACTIVE_LOW>;
++			debounce-interval = <60>;
++		};
++	};
++
++	exp_usb3_vbus: usb3-vbus {
++		compatible = "regulator-fixed";
++		regulator-name = "usb3-vbus";
++		regulator-min-microvolt = <5000000>;
++		regulator-max-microvolt = <5000000>;
++		enable-active-high;
++		regulator-always-on;
++		gpio = <&gpiosb 0 GPIO_ACTIVE_HIGH>;
++	};
++
++	usb3_phy: usb3-phy {
++		compatible = "usb-nop-xceiv";
++		vcc-supply = <&exp_usb3_vbus>;
++	};
++
++	vsdc_reg: vsdc-reg {
++		compatible = "regulator-gpio";
++		regulator-name = "vsdc";
++		regulator-min-microvolt = <1800000>;
++		regulator-max-microvolt = <3300000>;
++		regulator-boot-on;
++
++		gpios = <&gpiosb 23 GPIO_ACTIVE_HIGH>;
++		gpios-states = <0>;
++		states = <1800000 0x1
++			  3300000 0x0>;
++		enable-active-high;
++	};
++
++	vsdio_reg: vsdio-reg {
++		compatible = "regulator-gpio";
++		regulator-name = "vsdio";
++		regulator-min-microvolt = <1800000>;
++		regulator-max-microvolt = <3300000>;
++		regulator-boot-on;
++
++		gpios = <&gpiosb 22 GPIO_ACTIVE_HIGH>;
++		gpios-states = <0>;
++		states = <1800000 0x1
++			  3300000 0x0>;
++		enable-active-high;
++	};
++
++	sdhci1_pwrseq: sdhci1-pwrseq {
++		compatible = "mmc-pwrseq-simple";
++		reset-gpios = <&gpionb 19 GPIO_ACTIVE_HIGH>;
++		status = "okay";
++	};
++
++	sfp: sfp {
++		compatible = "sff,sfp+";
++		i2c-bus = <&i2c0>;
++		los-gpio = <&moxtet_sfp 0 GPIO_ACTIVE_HIGH>;
++		tx-fault-gpio = <&moxtet_sfp 1 GPIO_ACTIVE_HIGH>;
++		mod-def0-gpio = <&moxtet_sfp 2 GPIO_ACTIVE_LOW>;
++		tx-disable-gpio = <&moxtet_sfp 3 GPIO_ACTIVE_HIGH>;
++		rate-select0-gpio = <&moxtet_sfp 4 GPIO_ACTIVE_HIGH>;
++		status = "disabled";
++	};
++
++	soc {
++		internal-regs@d0000000 {
++			turris_mox_crypto: crypto@0 {
++				compatible = "cznic,turris-mox-rwtm";
++				mboxes = <&rwtm 0>;
++				status = "okay";
++			};
++		};
++	};
++};
++
++&pinctrl_nb {
++	spi_cs1_pins: spi-cs1-pins {
++		groups = "spi_cs1";
++		function = "spi";
++	};
++
++	sdio0_pins: sdio0-pins {
++		groups = "sdio0";
++		function = "sdio";
++	};
++};
++
++&pinctrl_sb {
++	sdio_sb_pins: sdio-sb-pins {
++		groups = "sdio_sb";
++		function = "sdio";
++	};
++
++	smi_pins: smi-pins {
++		groups = "smi";
++		function = "smi";
++	};
++
++	pcie_pins: pcie1-pins {
++		groups = "pcie1";
++		function = "gpio";
++	};
++};
++
++&i2c0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&i2c1_pins>;
++	status = "okay";
++
++	rtc@6f {
++		compatible = "microchip,mcp7940x";
++		reg = <0x6f>;
++	};
++};
++
++&pcie0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&pcie_pins>;
++	status = "okay";
++	max-link-speed = <2>;
++	reset-gpio = <&gpiosb 3 GPIO_ACTIVE_HIGH>;
++
++	/* this shall be enabled by u-boot if the PCIe module is present */
++	status = "disabled";
++};
++
++&uart0 {
++	status = "okay";
++};
++
++&eth0 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&rgmii_pins>;
++	phy-mode = "rgmii-id";
++	phy = <&phy1>;
++	status = "okay";
++};
++
++&eth1 {
++	phy-mode = "1000base-x";
++	managed = "in-band-status";
++};
++
++&mdio {
++	pinctrl-names = "default";
++	pinctrl-0 = <&smi_pins>;
++	status = "okay";
++
++	phy1: ethernet-phy@1 {
++		reg = <1>;
++	};
++
++	switch0@10 {
++		compatible = "marvell,mv88e6190";
++		reg = <0x10 0>;
++		dsa,member = <0 0>;
++		interrupt-parent = <&gpiosb>;
++		interrupts = <5 IRQ_TYPE_EDGE_FALLING>;
++		status = "disabled";
++
++		mdio {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			switch0phy1: switch0phy1@1 {
++				reg = <0x1>;
++			};
++
++			switch0phy2: switch0phy2@2 {
++				reg = <0x2>;
++			};
++
++			switch0phy3: switch0phy3@3 {
++				reg = <0x3>;
++			};
++
++			switch0phy4: switch0phy4@4 {
++				reg = <0x4>;
++			};
++
++			switch0phy5: switch0phy5@5 {
++				reg = <0x5>;
++			};
++
++			switch0phy6: switch0phy6@6 {
++				reg = <0x6>;
++			};
++
++			switch0phy7: switch0phy7@7 {
++				reg = <0x7>;
++			};
++
++			switch0phy8: switch0phy8@8 {
++				reg = <0x8>;
++			};
++		};
++
++		ports {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			port@1 {
++				reg = <0x1>;
++				label = "lan1";
++				phy-handle = <&switch0phy1>;
++			};
++
++			port@2 {
++				reg = <0x2>;
++				label = "lan2";
++				phy-handle = <&switch0phy2>;
++			};
++
++			port@3 {
++				reg = <0x3>;
++				label = "lan3";
++				phy-handle = <&switch0phy3>;
++			};
++
++			port@4 {
++				reg = <0x4>;
++				label = "lan4";
++				phy-handle = <&switch0phy4>;
++			};
++
++			port@5 {
++				reg = <0x5>;
++				label = "lan5";
++				phy-handle = <&switch0phy5>;
++			};
++
++			port@6 {
++				reg = <0x6>;
++				label = "lan6";
++				phy-handle = <&switch0phy6>;
++			};
++
++			port@7 {
++				reg = <0x7>;
++				label = "lan7";
++				phy-handle = <&switch0phy7>;
++			};
++
++			port@8 {
++				reg = <0x8>;
++				label = "lan8";
++				phy-handle = <&switch0phy8>;
++			};
++
++			port@9 {
++				reg = <0x9>;
++				label = "cpu";
++				ethernet = <&eth1>;
++			};
++
++			switch0port10: port@a {
++				reg = <0xa>;
++				label = "dsa";
++				phy-mode = "2500base-x";
++				link = <&switch1port9 &switch2port9>;
++				status = "disabled";
++			};
++
++			port-sfp@a {
++				reg = <0xa>;
++				label = "sfp";
++				sfp = <&sfp>;
++				phy-mode = "sgmii";
++				managed = "in-band-status";
++				status = "disabled";
++			};
++		};
++	};
++
++	switch0@2 {
++		compatible = "marvell,mv88e6085";
++		reg = <0x2 0>;
++		dsa,member = <0 0>;
++		interrupt-parent = <&gpiosb>;
++		interrupts = <5 IRQ_TYPE_EDGE_FALLING>;
++		status = "disabled";
++
++		mdio {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			switch0phy1_topaz: switch0phy1@11 {
++				reg = <0x11>;
++			};
++
++			switch0phy2_topaz: switch0phy2@12 {
++				reg = <0x12>;
++			};
++
++			switch0phy3_topaz: switch0phy3@13 {
++				reg = <0x13>;
++			};
++
++			switch0phy4_topaz: switch0phy4@14 {
++				reg = <0x14>;
++			};
++		};
++
++		ports {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			port@1 {
++				reg = <0x1>;
++				label = "lan1";
++				phy-handle = <&switch0phy1_topaz>;
++			};
++
++			port@2 {
++				reg = <0x2>;
++				label = "lan2";
++				phy-handle = <&switch0phy2_topaz>;
++			};
++
++			port@3 {
++				reg = <0x3>;
++				label = "lan3";
++				phy-handle = <&switch0phy3_topaz>;
++			};
++
++			port@4 {
++				reg = <0x4>;
++				label = "lan4";
++				phy-handle = <&switch0phy4_topaz>;
++			};
++
++			port@5 {
++				reg = <0x5>;
++				label = "cpu";
++				ethernet = <&eth1>;
++			};
++		};
++	};
++
++	switch1@11 {
++		compatible = "marvell,mv88e6190";
++		reg = <0x11 0>;
++		dsa,member = <0 1>;
++		interrupt-parent = <&gpiosb>;
++		interrupts = <5 IRQ_TYPE_EDGE_FALLING>;
++		status = "disabled";
++
++		mdio {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			switch1phy1: switch1phy1@1 {
++				reg = <0x1>;
++			};
++
++			switch1phy2: switch1phy2@2 {
++				reg = <0x2>;
++			};
++
++			switch1phy3: switch1phy3@3 {
++				reg = <0x3>;
++			};
++
++			switch1phy4: switch1phy4@4 {
++				reg = <0x4>;
++			};
++
++			switch1phy5: switch1phy5@5 {
++				reg = <0x5>;
++			};
++
++			switch1phy6: switch1phy6@6 {
++				reg = <0x6>;
++			};
++
++			switch1phy7: switch1phy7@7 {
++				reg = <0x7>;
++			};
++
++			switch1phy8: switch1phy8@8 {
++				reg = <0x8>;
++			};
++		};
++
++		ports {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			port@1 {
++				reg = <0x1>;
++				label = "lan9";
++				phy-handle = <&switch1phy1>;
++			};
++
++			port@2 {
++				reg = <0x2>;
++				label = "lan10";
++				phy-handle = <&switch1phy2>;
++			};
++
++			port@3 {
++				reg = <0x3>;
++				label = "lan11";
++				phy-handle = <&switch1phy3>;
++			};
++
++			port@4 {
++				reg = <0x4>;
++				label = "lan12";
++				phy-handle = <&switch1phy4>;
++			};
++
++			port@5 {
++				reg = <0x5>;
++				label = "lan13";
++				phy-handle = <&switch1phy5>;
++			};
++
++			port@6 {
++				reg = <0x6>;
++				label = "lan14";
++				phy-handle = <&switch1phy6>;
++			};
++
++			port@7 {
++				reg = <0x7>;
++				label = "lan15";
++				phy-handle = <&switch1phy7>;
++			};
++
++			port@8 {
++				reg = <0x8>;
++				label = "lan16";
++				phy-handle = <&switch1phy8>;
++			};
++
++			switch1port9: port@9 {
++				reg = <0x9>;
++				label = "dsa";
++				phy-mode = "2500base-x";
++				link = <&switch0port10>;
++			};
++
++			switch1port10: port@a {
++				reg = <0xa>;
++				label = "dsa";
++				phy-mode = "2500base-x";
++				link = <&switch2port9>;
++				status = "disabled";
++			};
++
++			port-sfp@a {
++				reg = <0xa>;
++				label = "sfp";
++				sfp = <&sfp>;
++				phy-mode = "sgmii";
++				managed = "in-band-status";
++				status = "disabled";
++			};
++		};
++	};
++
++	switch1@2 {
++		compatible = "marvell,mv88e6085";
++		reg = <0x2 0>;
++		dsa,member = <0 1>;
++		interrupt-parent = <&gpiosb>;
++		interrupts = <5 IRQ_TYPE_EDGE_FALLING>;
++		status = "disabled";
++
++		mdio {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			switch1phy1_topaz: switch1phy1@11 {
++				reg = <0x11>;
++			};
++
++			switch1phy2_topaz: switch1phy2@12 {
++				reg = <0x12>;
++			};
++
++			switch1phy3_topaz: switch1phy3@13 {
++				reg = <0x13>;
++			};
++
++			switch1phy4_topaz: switch1phy4@14 {
++				reg = <0x14>;
++			};
++		};
++
++		ports {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			port@1 {
++				reg = <0x1>;
++				label = "lan9";
++				phy-handle = <&switch1phy1_topaz>;
++			};
++
++			port@2 {
++				reg = <0x2>;
++				label = "lan10";
++				phy-handle = <&switch1phy2_topaz>;
++			};
++
++			port@3 {
++				reg = <0x3>;
++				label = "lan11";
++				phy-handle = <&switch1phy3_topaz>;
++			};
++
++			port@4 {
++				reg = <0x4>;
++				label = "lan12";
++				phy-handle = <&switch1phy4_topaz>;
++			};
++
++			port@5 {
++				reg = <0x5>;
++				label = "dsa";
++				phy-mode = "2500base-x";
++				link = <&switch0port10>;
++			};
++		};
++	};
++
++	switch2@12 {
++		compatible = "marvell,mv88e6190";
++		reg = <0x12 0>;
++		dsa,member = <0 2>;
++		interrupt-parent = <&gpiosb>;
++		interrupts = <5 IRQ_TYPE_EDGE_FALLING>;
++		status = "disabled";
++
++		mdio {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			switch2phy1: switch2phy1@1 {
++				reg = <0x1>;
++			};
++
++			switch2phy2: switch2phy2@2 {
++				reg = <0x2>;
++			};
++
++			switch2phy3: switch2phy3@3 {
++				reg = <0x3>;
++			};
++
++			switch2phy4: switch2phy4@4 {
++				reg = <0x4>;
++			};
++
++			switch2phy5: switch2phy5@5 {
++				reg = <0x5>;
++			};
++
++			switch2phy6: switch2phy6@6 {
++				reg = <0x6>;
++			};
++
++			switch2phy7: switch2phy7@7 {
++				reg = <0x7>;
++			};
++
++			switch2phy8: switch2phy8@8 {
++				reg = <0x8>;
++			};
++		};
++
++		ports {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			port@1 {
++				reg = <0x1>;
++				label = "lan17";
++				phy-handle = <&switch2phy1>;
++			};
++
++			port@2 {
++				reg = <0x2>;
++				label = "lan18";
++				phy-handle = <&switch2phy2>;
++			};
++
++			port@3 {
++				reg = <0x3>;
++				label = "lan19";
++				phy-handle = <&switch2phy3>;
++			};
++
++			port@4 {
++				reg = <0x4>;
++				label = "lan20";
++				phy-handle = <&switch2phy4>;
++			};
++
++			port@5 {
++				reg = <0x5>;
++				label = "lan21";
++				phy-handle = <&switch2phy5>;
++			};
++
++			port@6 {
++				reg = <0x6>;
++				label = "lan22";
++				phy-handle = <&switch2phy6>;
++			};
++
++			port@7 {
++				reg = <0x7>;
++				label = "lan23";
++				phy-handle = <&switch2phy7>;
++			};
++
++			port@8 {
++				reg = <0x8>;
++				label = "lan24";
++				phy-handle = <&switch2phy8>;
++			};
++
++			switch2port9: port@9 {
++				reg = <0x9>;
++				label = "dsa";
++				phy-mode = "2500base-x";
++				link = <&switch1port10 &switch0port10>;
++			};
++
++			port-sfp@a {
++				reg = <0xa>;
++				label = "sfp";
++				sfp = <&sfp>;
++				phy-mode = "sgmii";
++				managed = "in-band-status";
++				status = "disabled";
++			};
++		};
++	};
++
++	switch2@2 {
++		compatible = "marvell,mv88e6085";
++		reg = <0x2 0>;
++		dsa,member = <0 2>;
++		interrupt-parent = <&gpiosb>;
++		interrupts = <5 IRQ_TYPE_EDGE_FALLING>;
++		status = "disabled";
++
++		mdio {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			switch2phy1_topaz: switch2phy1@11 {
++				reg = <0x11>;
++			};
++
++			switch2phy2_topaz: switch2phy2@12 {
++				reg = <0x12>;
++			};
++
++			switch2phy3_topaz: switch2phy3@13 {
++				reg = <0x13>;
++			};
++
++			switch2phy4_topaz: switch2phy4@14 {
++				reg = <0x14>;
++			};
++		};
++
++		ports {
++			#address-cells = <1>;
++			#size-cells = <0>;
++
++			port@1 {
++				reg = <0x1>;
++				label = "lan17";
++				phy-handle = <&switch2phy1_topaz>;
++			};
++
++			port@2 {
++				reg = <0x2>;
++				label = "lan18";
++				phy-handle = <&switch2phy2_topaz>;
++			};
++
++			port@3 {
++				reg = <0x3>;
++				label = "lan19";
++				phy-handle = <&switch2phy3_topaz>;
++			};
++
++			port@4 {
++				reg = <0x4>;
++				label = "lan20";
++				phy-handle = <&switch2phy4_topaz>;
++			};
++
++			port@5 {
++				reg = <0x5>;
++				label = "dsa";
++				phy-mode = "2500base-x";
++				link = <&switch1port10 &switch0port10>;
++			};
++		};
++	};
++
++};
++
++&sdhci0 {
++	wp-inverted;
++	bus-width = <4>;
++	cd-gpios = <&gpionb 10 GPIO_ACTIVE_HIGH>;
++	vqmmc-supply = <&vsdc_reg>;
++	marvell,pad-type = "sd";
++	status = "okay";
++};
++
++&sdhci1 {
++	pinctrl-names = "default";
++	pinctrl-0 = <&sdio0_pins &sdio_sb_pins>;
++	non-removable;
++	bus-width = <4>;
++	marvell,pad-type = "sd";
++	vqmmc-supply = <&vsdio_reg>;
++	mmc-pwrseq = <&sdhci1_pwrseq>;
++	status = "okay";
++};
++
++&spi0 {
++	status = "okay";
++	pinctrl-names = "default";
++	pinctrl-0 = <&spi_quad_pins &spi_cs1_pins>;
++	assigned-clocks = <&nb_periph_clk 7>;
++	assigned-clock-parents = <&tbg 1>;
++	assigned-clock-rates = <20000000>;
++
++	spi-flash@0 {
++		#address-cells = <1>;
++		#size-cells = <1>;
++		compatible = "jedec,spi-nor";
++		reg = <0>;
++		spi-max-frequency = <20000000>;
++
++		partitions {
++			compatible = "fixed-partitions";
++			#address-cells = <1>;
++			#size-cells = <1>;
++
++			partition@0 {
++				label = "secure-firmware";
++				reg = <0x0 0x20000>;
++			};
++
++			partition@20000 {
++				label = "u-boot";
++				reg = <0x20000 0x160000>;
++			};
++
++			partition@180000 {
++				label = "u-boot-env";
++				reg = <0x180000 0x10000>;
++			};
++
++			partition@190000 {
++				label = "Rescue system";
++				reg = <0x190000 0x660000>;
++			};
++
++			partition@7f0000 {
++				label = "dtb";
++				reg = <0x7f0000 0x10000>;
++			};
++		};
++	};
++
++	moxtet@1 {
++		#address-cells = <1>;
++		#size-cells = <0>;
++		compatible = "cznic,moxtet";
++		reg = <1>;
++		reset-gpios = <&gpiosb 2 GPIO_ACTIVE_LOW>;
++		spi-max-frequency = <10000000>;
++		spi-cpol;
++		spi-cpha;
++
++		moxtet_sfp: gpio@0 {
++			compatible = "cznic,moxtet-gpio";
++			gpio-controller;
++			#gpio-cells = <2>;
++			reg = <0>;
++			moxtet,id = <1>;
++			moxtet,input-mask = <0x7>;
++			moxtet,output-mask = <0x3>;
++			status = "disabled";
++		};
++	};
++};
++
++&rwtm {
++	status = "okay";
++};
++
++&usb2 {
++	status = "okay";
++};
++
++&usb3 {
++	status = "okay";
++	usb-phy = <&usb3_phy>;
++};
+-- 
+2.21.0
+
diff --git a/target/linux/mvebu/patches-4.14/9999-arm64-restart-Armada-3700-restart-code.patch b/target/linux/mvebu/patches-4.14/90126-arm64-restart-Armada-3700-restart-code.patch
similarity index 89%
rename from target/linux/mvebu/patches-4.14/9999-arm64-restart-Armada-3700-restart-code.patch
rename to target/linux/mvebu/patches-4.14/90126-arm64-restart-Armada-3700-restart-code.patch
index b442f71..2a9460e 100644
--- a/target/linux/mvebu/patches-4.14/9999-arm64-restart-Armada-3700-restart-code.patch
+++ b/target/linux/mvebu/patches-4.14/90126-arm64-restart-Armada-3700-restart-code.patch
@@ -1,7 +1,7 @@
-From d419edef1a2429acfa35341eb6fbfaea3b6c87c4 Mon Sep 17 00:00:00 2001
+From 590c614469090540b43012223079d216da4e1b00 Mon Sep 17 00:00:00 2001
 From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
 Date: Mon, 14 Jan 2019 17:00:04 +0100
-Subject: [PATCH] arm64: restart: Armada 3700 restart code
+Subject: [PATCH 126/126] arm64: restart: Armada 3700 restart code
 MIME-Version: 1.0
 Content-Type: text/plain; charset=UTF-8
 Content-Transfer-Encoding: 8bit
@@ -40,5 +40,5 @@ index 9e773732520c..2ae392c218fc 100644
  	/*
  	 * Whoops - the architecture was unable to reboot.
 -- 
-2.19.2
+2.21.0
 
diff --git a/target/linux/mvebu/patches-4.14/509-cpufreq-armada-37xx-Fix-clock-leak.patch b/target/linux/mvebu/patches-4.14/9509-cpufreq-armada-37xx-Fix-clock-leak.patch
similarity index 100%
rename from target/linux/mvebu/patches-4.14/509-cpufreq-armada-37xx-Fix-clock-leak.patch
rename to target/linux/mvebu/patches-4.14/9509-cpufreq-armada-37xx-Fix-clock-leak.patch
diff --git a/target/linux/mvebu/patches-4.14/510-clk-mvebu-armada-37xx-periph-Fix-switching-CPU-rate-.patch b/target/linux/mvebu/patches-4.14/99510-clk-mvebu-armada-37xx-periph-Fix-switching-CPU-rate-.patch
similarity index 100%
rename from target/linux/mvebu/patches-4.14/510-clk-mvebu-armada-37xx-periph-Fix-switching-CPU-rate-.patch
rename to target/linux/mvebu/patches-4.14/99510-clk-mvebu-armada-37xx-periph-Fix-switching-CPU-rate-.patch
diff --git a/target/linux/mvebu/patches-4.14/511-clk-mvebu-armada-37xx-periph-Fix-wrong-return-value-.patch b/target/linux/mvebu/patches-4.14/99511-clk-mvebu-armada-37xx-periph-Fix-wrong-return-value-.patch
similarity index 100%
rename from target/linux/mvebu/patches-4.14/511-clk-mvebu-armada-37xx-periph-Fix-wrong-return-value-.patch
rename to target/linux/mvebu/patches-4.14/99511-clk-mvebu-armada-37xx-periph-Fix-wrong-return-value-.patch
diff --git a/target/linux/mvebu/patches-4.14/512-clk-mvebu-armada-37xx-periph-Remove-unused-var-num_p.patch b/target/linux/mvebu/patches-4.14/99512-clk-mvebu-armada-37xx-periph-Remove-unused-var-num_p.patch
similarity index 100%
rename from target/linux/mvebu/patches-4.14/512-clk-mvebu-armada-37xx-periph-Remove-unused-var-num_p.patch
rename to target/linux/mvebu/patches-4.14/99512-clk-mvebu-armada-37xx-periph-Remove-unused-var-num_p.patch
-- 
2.21.0

